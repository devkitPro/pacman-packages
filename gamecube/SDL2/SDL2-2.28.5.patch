diff --git a/.github/workflows/ngc.yml b/.github/workflows/ngc.yml
new file mode 100644
index 0000000000..aeaf6b9269
--- /dev/null
+++ b/.github/workflows/ngc.yml
@@ -0,0 +1,47 @@
+name: Build (Nintendo GameCube)
+
+on: [push, pull_request]
+
+jobs:
+  ngcn:
+    runs-on: ubuntu-latest
+    container:
+      image: devkitpro/devkitppc:latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Install build requirements
+        run: |
+          apt update
+          apt install ninja-build
+      - name: Configure CMake
+        run: |
+          /opt/devkitpro/portlibs/gamecube/bin/powerpc-eabi-cmake -S . -B build -G Ninja \
+          -DCMAKE_INSTALL_PREFIX=prefix
+      - name: Build
+        run: cmake --build build --verbose --parallel
+      - name: Install CMake
+        run: |
+          echo "SDL2_DIR=$(pwd)/prefix" >> $GITHUB_ENV
+          cmake --install build/
+          ( cd prefix; find ) | LC_ALL=C sort -u
+      - name: Verify CMake configuration files
+        run: |
+          /opt/devkitpro/portlibs/gamecube/bin/powerpc-eabi-cmake -S cmake/test -B cmake_config_build -G Ninja \
+            -DTEST_SHARED=FALSE \
+            -DCMAKE_PREFIX_PATH=${{ env.SDL2_DIR }} \
+            -DCMAKE_BUILD_TYPE=Release
+          cmake --build cmake_config_build --verbose
+      - name: Extract CC/CXX/CFLAGS/CXXFLAGS from CMake toolchain
+        run: |
+          /opt/devkitpro/portlibs/gamecube/bin/powerpc-eabi-cmake -S .github/cmake -B /tmp/cmake_extract \
+            -DCMAKE_BUILD_TYPE=Release \
+            -DVAR_PATH=/tmp/ngc_env.txt
+          cat /tmp/ngc_env.txt >> $GITHUB_ENV
+      - name: Verify sdl2-config
+        run: |
+          export PATH=${{ env.SDL2_DIR }}/bin:$PATH
+          cmake/test/test_sdlconfig.sh
+      - name: Verify sdl2.pc
+        run: |
+          export PKG_CONFIG_PATH=${{ env.SDL2_DIR }}/lib/pkgconfig
+          cmake/test/test_pkgconfig.sh
diff --git a/.github/workflows/nwii.yml b/.github/workflows/nwii.yml
new file mode 100644
index 0000000000..625de93b93
--- /dev/null
+++ b/.github/workflows/nwii.yml
@@ -0,0 +1,47 @@
+name: Build (Nintendo Wii)
+
+on: [push, pull_request]
+
+jobs:
+  nwii:
+    runs-on: ubuntu-latest
+    container:
+      image: devkitpro/devkitppc:latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Install build requirements
+        run: |
+          apt update
+          apt install ninja-build
+      - name: Configure CMake
+        run: |
+          /opt/devkitpro/portlibs/wii/bin/powerpc-eabi-cmake -S . -B build -G Ninja \
+          -DCMAKE_INSTALL_PREFIX=prefix
+      - name: Build
+        run: cmake --build build --verbose --parallel
+      - name: Install CMake
+        run: |
+          echo "SDL2_DIR=$(pwd)/prefix" >> $GITHUB_ENV
+          cmake --install build/
+          ( cd prefix; find ) | LC_ALL=C sort -u
+      - name: Verify CMake configuration files
+        run: |
+          /opt/devkitpro/portlibs/wii/bin/powerpc-eabi-cmake -S cmake/test -B cmake_config_build -G Ninja \
+            -DTEST_SHARED=FALSE \
+            -DCMAKE_PREFIX_PATH=${{ env.SDL2_DIR }} \
+            -DCMAKE_BUILD_TYPE=Release
+          cmake --build cmake_config_build --verbose
+      - name: Extract CC/CXX/CFLAGS/CXXFLAGS from CMake toolchain
+        run: |
+          /opt/devkitpro/portlibs/wii/bin/powerpc-eabi-cmake -S .github/cmake -B /tmp/cmake_extract \
+            -DCMAKE_BUILD_TYPE=Release \
+            -DVAR_PATH=/tmp/ngc_env.txt
+          cat /tmp/ngc_env.txt >> $GITHUB_ENV
+      - name: Verify sdl2-config
+        run: |
+          export PATH=${{ env.SDL2_DIR }}/bin:$PATH
+          cmake/test/test_sdlconfig.sh
+      - name: Verify sdl2.pc
+        run: |
+          export PKG_CONFIG_PATH=${{ env.SDL2_DIR }}/lib/pkgconfig
+          cmake/test/test_pkgconfig.sh
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b38a8bbc11..9129cea2a9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -141,6 +141,7 @@ check_cpu_architecture(x64 SDL_CPU_X64)
 check_cpu_architecture(arm32 SDL_CPU_ARM32)
 check_cpu_architecture(arm64 SDL_CPU_ARM64)
 check_cpu_architecture(loongarch64 SDL_CPU_LOONGARCH64)
+check_cpu_architecture(powerpc SDL_CPU_POWERPC)
 
 # Check for 64 or 32 bit
 set(SIZEOF_VOIDP ${CMAKE_SIZEOF_VOID_P})
@@ -238,7 +239,7 @@ if(USE_GCC OR USE_CLANG OR USE_INTELCC OR USE_QCC)
 endif()
 
 # Default option knobs
-if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS)
+if(UNIX OR MINGW OR MSYS OR (USE_CLANG AND NOT WINDOWS) OR VITA OR PSP OR PS2 OR N3DS OR OGC)
   set(OPT_DEF_LIBC ON)
 endif()
 
@@ -350,7 +351,7 @@ if(EMSCRIPTEN)
   set(SDL_CPUINFO_ENABLED_BY_DEFAULT OFF)
 endif()
 
-if(VITA OR PSP OR PS2 OR N3DS)
+if(VITA OR PSP OR PS2 OR N3DS OR OGC)
   set(SDL_SHARED_ENABLED_BY_DEFAULT OFF)
   set(SDL_LOADSO_ENABLED_BY_DEFAULT OFF)
 endif()
@@ -840,7 +841,7 @@ if(SDL_ASSEMBLY)
 
     check_include_file("immintrin.h" HAVE_IMMINTRIN_H)
 
-    if(SDL_ALTIVEC)
+    if(SDL_ALTIVEC AND NOT OGC)
       set(CMAKE_REQUIRED_FLAGS "-maltivec")
       check_c_source_compiles("
           #include <altivec.h>
@@ -1082,7 +1083,7 @@ if(SDL_LIBC)
     endforeach()
     if(HAVE_LIBM)
       set(CMAKE_REQUIRED_LIBRARIES)
-      if(NOT VITA)
+      if(NOT VITA AND NOT NINTENDO_SWITCH AND NOT NINTENDO_WII)
         list(APPEND EXTRA_LIBS m)
       endif()
     endif()
@@ -2883,6 +2884,76 @@ elseif(N3DS)
     endif()
     list(APPEND EXTRA_LIBS ${lib})
   endforeach()
+
+elseif(OGC)
+  if(CMAKE_SYSTEM_NAME MATCHES "NintendoWii")
+    file(GLOB OGC_MAIN_SOURCES ${SDL2_SOURCE_DIR}/src/main/wii/*.c)
+  else()
+    file(GLOB OGC_MAIN_SOURCES ${SDL2_SOURCE_DIR}/src/main/gamecube/*.c)
+  endif()
+  set(SDLMAIN_SOURCES ${SDLMAIN_SOURCES} ${OGC_MAIN_SOURCES})
+
+  if(SDL_AUDIO)
+    set(SDL_AUDIO_DRIVER_OGC 1)
+    file(GLOB OGC_AUDIO_SOURCES ${SDL2_SOURCE_DIR}/src/audio/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_AUDIO_SOURCES})
+    set(HAVE_SDL_AUDIO TRUE)
+    list(APPEND EXTRA_LIBS "aesnd")
+  endif()
+
+  if(SDL_FILESYSTEM)
+    set(SDL_FILESYSTEM_OGC 1)
+    file(GLOB OGC_FILESYSTEM_SOURCES ${SDL2_SOURCE_DIR}/src/filesystem/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_FILESYSTEM_SOURCES})
+    set(HAVE_SDL_FILESYSTEM TRUE)
+  endif()
+
+  if(SDL_JOYSTICK)
+    set(SDL_JOYSTICK_OGC 1)
+    file(GLOB OGC_JOYSTICK_SOURCES ${SDL2_SOURCE_DIR}/src/joystick/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_JOYSTICK_SOURCES})
+    set(HAVE_SDL_JOYSTICK TRUE)
+  endif()
+
+  if(SDL_THREADS)
+    set(SDL_THREAD_OGC 1)
+    file(GLOB OGC_THREAD_SOURCES ${SDL2_SOURCE_DIR}/src/thread/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_THREAD_SOURCES} ${SDL2_SOURCE_DIR}/src/thread/generic/SDL_systls.c)
+    set(HAVE_SDL_THREADS TRUE)
+  endif()
+
+  if(SDL_TIMERS)
+    set(SDL_TIMER_OGC 1)
+    file(GLOB OGC_TIMER_SOURCES ${SDL2_SOURCE_DIR}/src/timer/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_TIMER_SOURCES})
+    set(HAVE_SDL_TIMERS TRUE)
+  endif()
+
+  if(SDL_VIDEO)
+    set(SDL_VIDEO_DRIVER_OGC 1)
+    set(SDL_VIDEO_RENDER_OGC 1)
+    file(GLOB OGC_VIDEO_SOURCES ${SDL2_SOURCE_DIR}/src/video/ogc/*.c ${SDL2_SOURCE_DIR}/src/render/ogc/*.c)
+    list(APPEND SOURCE_FILES ${OGC_VIDEO_SOURCES})
+    set(SDL_VIDEO_OPENGL 0)
+    set(HAVE_SDL_VIDEO TRUE)
+    if(SDL_OPENGL)
+      pkg_search_module(OPENGX opengl REQUIRED IMPORTED_TARGET)
+      set(SDL_VIDEO_OPENGL 1)
+      set(HAVE_OPENGL TRUE)
+      list(APPEND EXTRA_LIBS "opengx")
+      target_include_directories(sdl-build-options INTERFACE ${OPENGX_INCLUDE_DIRS})
+    endif()
+  endif()
+
+  if(NOT SDL2_DISABLE_SDL2MAIN)
+    list(INSERT SDL_LIBS 0 "-lSDL2main")
+    list(APPEND EXTRA_LIBS "fat")
+  endif()
+  list(APPEND EXTRA_LDFLAGS "${OGC_ARCH_SETTINGS} ${OGC_LINKER_FLAGS}")
+  if(NINTENDO_WII)
+    list(APPEND EXTRA_LIBS "wiiuse;bte;wiikeyboard")
+  endif()
+  list(APPEND EXTRA_LIBS "ogc;m")
 endif()
 
 if(HAVE_VULKAN AND NOT SDL_LOADSO)
diff --git a/cmake/CheckCPUArchitecture.cmake b/cmake/CheckCPUArchitecture.cmake
index 7e3e459470..64ddea7440 100644
--- a/cmake/CheckCPUArchitecture.cmake
+++ b/cmake/CheckCPUArchitecture.cmake
@@ -34,6 +34,8 @@ function(check_cpu_architecture ARCH VARIABLE)
     _internal_check_cpu_architecture("defined(__aarch64__) || defined(_M_ARM64)" arm64 ${VARIABLE})
   elseif(ARCH STREQUAL "loongarch64")
     _internal_check_cpu_architecture("defined(__loongarch64)" loongarch64 ${VARIABLE})
+  elseif(ARCH STREQUAL "powerpc")
+    _internal_check_cpu_architecture("defined(PPC)" powerpc ${VARIABLE})
   else()
     message(WARNING "Unknown CPU architectures (${ARCH}).")
     set(${VARIABLE} FALSE)
diff --git a/cmake/sdlplatform.cmake b/cmake/sdlplatform.cmake
index 6d8ece6ac5..ea0b7dd8d6 100644
--- a/cmake/sdlplatform.cmake
+++ b/cmake/sdlplatform.cmake
@@ -50,6 +50,8 @@ macro(SDL_DetectCMakePlatform)
     set(SDL_CMAKE_PLATFORM HAIKU)
   elseif(NINTENDO_3DS)
     set(SDL_CMAKE_PLATFORM N3DS)
+  elseif(CMAKE_SYSTEM_NAME MATCHES "NintendoWii|NintendoGameCube")
+    set(SDL_CMAKE_PLATFORM OGC)
   elseif(OS2)
     set(SDL_CMAKE_PLATFORM OS2)
   endif()
diff --git a/docs/README-ogc.md b/docs/README-ogc.md
new file mode 100644
index 0000000000..619c87a0dc
--- /dev/null
+++ b/docs/README-ogc.md
@@ -0,0 +1,22 @@
+# Nintendo GameCube/Nintendo Wii
+
+SDL port for the Nintendo GameCube and Nintendo Wii [Homebrew toolchain](https://devkitpro.org/).
+
+Credits to:
+
+-   The awesome people who ported SDL to other homebrew platforms.
+-   The Devkitpro team for making all the tools necessary to achieve this.
+
+## Building
+
+To build for the Nintendo GameCube or Wii, make sure you have devkitPPC and cmake installed and run:
+
+```bash
+cmake -S. -Bbuild -DCMAKE_TOOLCHAIN_FILE="$DEVKITPRO/cmake/Wii.cmake" -DCMAKE_BUILD_TYPE=Release
+cmake --build build
+cmake --install build
+```
+
+## Notes
+
+-   Currently only software rendering is supported.
diff --git a/include/SDL_config.h.cmake b/include/SDL_config.h.cmake
index 35923d0207..13f9a6022f 100644
--- a/include/SDL_config.h.cmake
+++ b/include/SDL_config.h.cmake
@@ -329,6 +329,7 @@
 #cmakedefine SDL_AUDIO_DRIVER_PSP @SDL_AUDIO_DRIVER_PSP@
 #cmakedefine SDL_AUDIO_DRIVER_PS2 @SDL_AUDIO_DRIVER_PS2@
 #cmakedefine SDL_AUDIO_DRIVER_N3DS @SDL_AUDIO_DRIVER_N3DS@
+#cmakedefine SDL_AUDIO_DRIVER_OGC @SDL_AUDIO_DRIVER_OGC@
 
 /* Enable various input drivers */
 #cmakedefine SDL_INPUT_LINUXEV @SDL_INPUT_LINUXEV@
@@ -355,6 +356,7 @@
 #cmakedefine SDL_JOYSTICK_PSP @SDL_JOYSTICK_PSP@
 #cmakedefine SDL_JOYSTICK_PS2 @SDL_JOYSTICK_PS2@
 #cmakedefine SDL_JOYSTICK_N3DS @SDL_JOYSTICK_N3DS@
+#cmakedefine SDL_JOYSTICK_OGC @SDL_JOYSTICK_OGC@
 #cmakedefine SDL_HAPTIC_DUMMY @SDL_HAPTIC_DUMMY@
 #cmakedefine SDL_HAPTIC_LINUX @SDL_HAPTIC_LINUX@
 #cmakedefine SDL_HAPTIC_IOKIT @SDL_HAPTIC_IOKIT@
@@ -390,6 +392,7 @@
 #cmakedefine SDL_THREAD_PSP @SDL_THREAD_PSP@
 #cmakedefine SDL_THREAD_PS2 @SDL_THREAD_PS2@
 #cmakedefine SDL_THREAD_N3DS @SDL_THREAD_N3DS@
+#cmakedefine SDL_THREAD_OGC @SDL_THREAD_OGC@
 
 /* Enable various timer systems */
 #cmakedefine SDL_TIMER_HAIKU @SDL_TIMER_HAIKU@
@@ -401,6 +404,7 @@
 #cmakedefine SDL_TIMER_PSP @SDL_TIMER_PSP@
 #cmakedefine SDL_TIMER_PS2 @SDL_TIMER_PS2@
 #cmakedefine SDL_TIMER_N3DS @SDL_TIMER_N3DS@
+#cmakedefine SDL_TIMER_OGC @SDL_TIMER_OGC@
 
 /* Enable various video drivers */
 #cmakedefine SDL_VIDEO_DRIVER_ANDROID @SDL_VIDEO_DRIVER_ANDROID@
@@ -455,6 +459,7 @@
 #cmakedefine SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM @SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM@
 #cmakedefine SDL_VIDEO_DRIVER_VITA @SDL_VIDEO_DRIVER_VITA@
 #cmakedefine SDL_VIDEO_DRIVER_N3DS @SDL_VIDEO_DRIVER_N3DS@
+#cmakedefine SDL_VIDEO_DRIVER_OGC @SDL_VIDEO_DRIVER_OGC@
 
 #cmakedefine SDL_VIDEO_RENDER_D3D @SDL_VIDEO_RENDER_D3D@
 #cmakedefine SDL_VIDEO_RENDER_D3D11 @SDL_VIDEO_RENDER_D3D11@
@@ -467,6 +472,7 @@
 #cmakedefine SDL_VIDEO_RENDER_VITA_GXM @SDL_VIDEO_RENDER_VITA_GXM@
 #cmakedefine SDL_VIDEO_RENDER_PS2 @SDL_VIDEO_RENDER_PS2@
 #cmakedefine SDL_VIDEO_RENDER_PSP @SDL_VIDEO_RENDER_PSP@
+#cmakedefine SDL_VIDEO_RENDER_OGC @SDL_VIDEO_RENDER_OGC@
 
 /* Enable OpenGL support */
 #cmakedefine SDL_VIDEO_OPENGL @SDL_VIDEO_OPENGL@
@@ -514,6 +520,7 @@
 #cmakedefine SDL_FILESYSTEM_PSP @SDL_FILESYSTEM_PSP@
 #cmakedefine SDL_FILESYSTEM_PS2 @SDL_FILESYSTEM_PS2@
 #cmakedefine SDL_FILESYSTEM_N3DS @SDL_FILESYSTEM_N3DS@
+#cmakedefine SDL_FILESYSTEM_OGC @SDL_FILESYSTEM_OGC@
 
 /* Enable misc subsystem */
 #cmakedefine SDL_MISC_DUMMY @SDL_MISC_DUMMY@
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index d6460b783e..026c63bad9 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -355,6 +355,7 @@
 
 /* Enable various threading systems */
 #undef SDL_THREAD_GENERIC_COND_SUFFIX
+#undef SDL_THREAD_OGC
 #undef SDL_THREAD_PTHREAD
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
diff --git a/include/SDL_main.h b/include/SDL_main.h
index 5cc8e5913a..8416fb2df7 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -117,6 +117,14 @@
 */
 #define SDL_MAIN_AVAILABLE
 
+#elif defined(__wii__) || defined(__gamecube__)
+/*
+  On Wii and GameCube, SDL provides a main function that sets up the system.
+
+  If you provide this yourself, you may define SDL_MAIN_HANDLED
+*/
+#define SDL_MAIN_AVAILABLE
+
 #endif
 #endif /* SDL_MAIN_HANDLED */
 
diff --git a/src/SDL.c b/src/SDL.c
index 56049adf0b..6d164b2485 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -610,6 +610,10 @@ const char *SDL_GetPlatform(void)
     return "Nokia N-Gage";
 #elif __3DS__
     return "Nintendo 3DS";
+#elif defined(__gamecube__)
+    return "Nintendo GameCube";
+#elif defined(__wii__)
+    return "Nintendo Wii";
 #else
     return "Unknown (see SDL_platform.h)";
 #endif
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 60242e60a0..0dd55916d4 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -108,6 +108,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_N3DS
     &N3DSAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_OGC
+    &OGCAUDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_EMSCRIPTEN
     &EMSCRIPTENAUDIO_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index c755d43415..9da933290b 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -207,6 +207,7 @@ extern AudioBootStrap PS2AUDIO_bootstrap;
 extern AudioBootStrap PSPAUDIO_bootstrap;
 extern AudioBootStrap VITAAUD_bootstrap;
 extern AudioBootStrap N3DSAUDIO_bootstrap;
+extern AudioBootStrap OGCAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
 extern AudioBootStrap OS2AUDIO_bootstrap;
 
diff --git a/src/audio/ogc/SDL_ogcaudio.c b/src/audio/ogc/SDL_ogcaudio.c
new file mode 100644
index 0000000000..7a770f1abc
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcaudio.c
@@ -0,0 +1,270 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_AUDIO_DRIVER_OGC
+
+#include "SDL_audio.h"
+
+/* OGC Audio driver */
+
+#include "../SDL_sysaudio.h"
+#include "SDL_ogcaudio.h"
+#include "SDL_timer.h"
+
+#include <malloc.h>
+
+#define OGCAUDIO_DRIVER_NAME "ogc"
+
+/**
+ * Cleans up all allocated memory, safe to call with null pointers
+ */
+static void FreePrivateData(_THIS)
+{
+    if (!this->hidden) {
+        return;
+    }
+
+    SDL_free(this->hidden);
+    this->hidden = NULL;
+}
+
+static int FindAudioFormat(_THIS)
+{
+    SDL_bool found_valid_format = SDL_FALSE;
+    Uint16 test_format = SDL_FirstAudioFormat(this->spec.format);
+
+    while (!found_valid_format && test_format) {
+        this->spec.format = test_format;
+        SDL_LogDebug(SDL_LOG_CATEGORY_AUDIO, "Trying format %x", test_format);
+        switch (test_format) {
+        case AUDIO_S8:
+            this->hidden->format = VOICE_MONO8;
+            this->hidden->bytes_per_sample = this->spec.channels;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_U8:
+            this->hidden->format = VOICE_MONO8_UNSIGNED;
+            this->hidden->bytes_per_sample = this->spec.channels;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_S16LSB:
+        case AUDIO_S16MSB:
+            this->hidden->format = VOICE_MONO16;
+            this->hidden->bytes_per_sample = this->spec.channels * 2;
+            this->spec.format = AUDIO_S16MSB;
+            found_valid_format = SDL_TRUE;
+            break;
+        case AUDIO_U16LSB:
+        case AUDIO_U16MSB:
+            this->hidden->format = VOICE_MONO16_UNSIGNED;
+            this->hidden->bytes_per_sample = this->spec.channels * 2;
+            this->spec.format = AUDIO_U16MSB;
+            found_valid_format = SDL_TRUE;
+            break;
+        default:
+            test_format = SDL_NextAudioFormat();
+            break;
+        }
+    }
+
+    if (found_valid_format && this->spec.channels == 2) {
+        this->hidden->format++;
+    }
+
+    return found_valid_format ? 0 : -1;
+}
+
+/* fully local functions related to the wavebufs / DSP, not the same as the SDL-wide mixer lock */
+static SDL_INLINE void contextLock(_THIS)
+{
+    LWP_MutexLock(this->hidden->lock);
+}
+
+static SDL_INLINE void contextUnlock(_THIS)
+{
+    LWP_MutexUnlock(this->hidden->lock);
+}
+
+static void audio_frame_finished(AESNDPB *pb, u32 state, void *arg)
+{
+    SDL_AudioDevice *this = (SDL_AudioDevice *)arg;
+
+    if (state == VOICE_STATE_STREAM) {
+        const size_t buffer_size = DMA_BUFFER_SIZE;
+        s8 playing_buffer;
+        void *buffer;
+
+        /* Immediately send the next buffer to the DSP. It's important that
+         * AESND_SetVoiceBuffer() gets called before this callback returns, or
+         * some audio gaps might be audible. */
+        contextLock(this);
+        playing_buffer = (this->hidden->playing_buffer + 1) % NUM_BUFFERS;
+        buffer = this->hidden->dma_buffers[playing_buffer];
+        AESND_SetVoiceBuffer(pb, buffer, buffer_size);
+        this->hidden->playing_buffer = playing_buffer;
+        contextUnlock(this);
+
+        /* If a frame has finished playing, it means that the corresponding
+         * buffer is no longer in use and can be filled up again. We signal
+         * this event to the audio thread via a semaphore. */
+        LWP_SemPost(this->hidden->available_buffers);
+    } if (state == VOICE_STATE_STOPPED) {
+        contextLock(this);
+        this->hidden->playing_buffer = -1;
+        contextUnlock(this);
+    }
+}
+
+static int OGCAUDIO_OpenDevice(_THIS, const char *devname)
+{
+    struct SDL_PrivateAudioData *hidden =
+        memalign(32, sizeof(struct SDL_PrivateAudioData));
+    if (!hidden) {
+        return SDL_OutOfMemory();
+    }
+
+    SDL_LogDebug(SDL_LOG_CATEGORY_AUDIO,
+                 "OGCAUDIO_OpenDevice, name=%s, freq=%d, channels=%d\n",
+                 devname, this->spec.freq, this->spec.channels);
+
+    memset(hidden, 0, sizeof(*hidden));
+    hidden->playing_buffer = -1;
+    this->hidden = hidden;
+
+    AESND_Init();
+    AESND_Pause(1);
+
+    /* Initialise internal state */
+    LWP_MutexInit(&hidden->lock, false);
+    /* We set the initial number of available buffers to NUM_BUFFERS - 1, since
+     * SDL first calls GetDeviceBuf() and starts filling it without first
+     * calling WaitDevice(). So we consider the first buffer to be busy already
+     * at start. */
+    LWP_SemInit(&hidden->available_buffers, NUM_BUFFERS - 1, NUM_BUFFERS);
+
+    if (this->spec.freq <= 0 || this->spec.freq > 144000)
+        this->spec.freq = DSP_DEFAULT_FREQ;
+
+    if (this->spec.channels > 2) {
+        this->spec.channels = 2;
+    }
+
+    /* Should not happen but better be safe. */
+    if (FindAudioFormat(this) < 0) {
+        return SDL_SetError("No supported audio format found.");
+    }
+
+    this->spec.samples = DMA_BUFFER_SIZE / this->hidden->bytes_per_sample;
+
+    /* Update the fragment size as size in bytes */
+    SDL_CalculateAudioSpec(&this->spec);
+
+    hidden->voice = AESND_AllocateVoiceWithArg(audio_frame_finished, this);
+    if (hidden->voice == NULL)
+        return -1;
+
+    // start audio
+    AESND_SetVoiceFormat(hidden->voice, hidden->format);
+    AESND_SetVoiceFrequency(hidden->voice, this->spec.freq);
+    AESND_SetVoiceBuffer(hidden->voice, hidden->dma_buffers[0], DMA_BUFFER_SIZE);
+    AESND_SetVoiceStream(hidden->voice, true);
+    AESND_SetVoiceStop(hidden->voice, 0);
+    AESND_Pause(0);
+
+    return 0;
+}
+
+static void OGCAUDIO_PlayDevice(_THIS)
+{
+    void *buffer;
+
+    /* This only sends the first audio buffer. The following ones will always
+     * be send from the audio_frame_finished() callback, without having to
+     * switch between threads. */
+    contextLock(this);
+    if (this->hidden->playing_buffer < 0) {
+        buffer = this->hidden->dma_buffers[++this->hidden->playing_buffer];
+        AESND_SetVoiceBuffer(this->hidden->voice, buffer, DMA_BUFFER_SIZE);
+    }
+    contextUnlock(this);
+}
+
+static void OGCAUDIO_WaitDevice(_THIS)
+{
+    s8 nextbuf;
+
+    /* This will block until at least one buffer is available for writing. */
+    LWP_SemWait(this->hidden->available_buffers);
+
+    nextbuf = this->hidden->nextbuf;
+    this->hidden->nextbuf = (nextbuf + 1) % NUM_BUFFERS;
+}
+
+static Uint8 *OGCAUDIO_GetDeviceBuf(_THIS)
+{
+    return this->hidden->dma_buffers[this->hidden->nextbuf];
+}
+
+static void OGCAUDIO_CloseDevice(_THIS)
+{
+    struct SDL_PrivateAudioData *hidden = this->hidden;
+
+    LWP_SemDestroy(hidden->available_buffers);
+    if (hidden->voice) {
+        AESND_SetVoiceStop(hidden->voice, true);
+        AESND_FreeVoice(hidden->voice);
+        hidden->voice = NULL;
+    }
+
+    AESND_Pause(1);
+    FreePrivateData(this);
+}
+
+static void OGCAUDIO_ThreadInit(_THIS)
+{
+    LWP_SetThreadPriority(LWP_THREAD_NULL, 80);
+}
+
+static SDL_bool OGCAUDIO_Init(SDL_AudioDriverImpl *impl)
+{
+    /* Set the function pointers */
+    impl->OpenDevice = OGCAUDIO_OpenDevice;
+    impl->PlayDevice = OGCAUDIO_PlayDevice;
+    impl->WaitDevice = OGCAUDIO_WaitDevice;
+    impl->GetDeviceBuf = OGCAUDIO_GetDeviceBuf;
+    impl->CloseDevice = OGCAUDIO_CloseDevice;
+    impl->ThreadInit = OGCAUDIO_ThreadInit;
+    impl->OnlyHasDefaultOutputDevice = SDL_TRUE;
+
+    return SDL_TRUE; /* this audio target is available. */
+}
+
+AudioBootStrap OGCAUDIO_bootstrap = {
+    OGCAUDIO_DRIVER_NAME,
+    "SDL OGC audio driver",
+    OGCAUDIO_Init,
+    0
+};
+
+#endif /* SDL_AUDIO_DRIVER_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/audio/ogc/SDL_ogcaudio.h b/src/audio/ogc/SDL_ogcaudio.h
new file mode 100644
index 0000000000..a575ac5aaa
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcaudio.h
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_ogcaudio_h_
+#define _SDL_ogcaudio_h_
+
+#include <aesndlib.h>
+#include <ogcsys.h>
+
+#include <ogc/mutex.h>
+#include <ogc/semaphore.h>
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS SDL_AudioDevice *this
+
+#define NUM_BUFFERS            4 /* -- Minimum 2! */
+#define SAMPLES_PER_DMA_BUFFER (DSP_STREAMBUFFER_SIZE)
+#define DMA_BUFFER_SIZE        (SAMPLES_PER_DMA_BUFFER * 2 * sizeof(short))
+
+struct SDL_PrivateAudioData
+{
+    /* these go first so they will be aligned */
+    Uint8 dma_buffers[NUM_BUFFERS][DMA_BUFFER_SIZE];
+    AESNDPB *voice;
+
+    /* Speaker data */
+    Uint32 format;
+    Uint8 bytes_per_sample;
+    s8 nextbuf;
+    s8 playing_buffer;
+    mutex_t lock;
+    sem_t available_buffers;
+};
+
+#endif /* _SDL_ogcaudio_h_ */
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 99ca08008f..d261a33f07 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -67,6 +67,8 @@
 #define SDL_DYNAMIC_API 0 /* The N-Gage doesn't support dynamic linking either */
 #elif defined(__3DS__)
 #define SDL_DYNAMIC_API 0 /* devkitARM doesn't support dynamic linking */
+#elif defined(__wii__) || defined(__gamecube__)
+#define SDL_DYNAMIC_API 0 /* devkitPPC doesn't support dynamic linking */
 #elif defined(DYNAPI_NEEDS_DLOPEN) && !defined(HAVE_DLOPEN)
 #define SDL_DYNAMIC_API 0 /* we need dlopen(), but don't have it.... */
 #endif
diff --git a/src/filesystem/ogc/SDL_sysfilesystem.c b/src/filesystem/ogc/SDL_sysfilesystem.c
new file mode 100644
index 0000000000..cf42b99f1e
--- /dev/null
+++ b/src/filesystem/ogc/SDL_sysfilesystem.c
@@ -0,0 +1,86 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_FILESYSTEM_OGC
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent filesystem routines                                */
+
+#include <dirent.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "SDL_error.h"
+#include "SDL_filesystem.h"
+
+static inline int create_dir(const char *dirname)
+{
+    int result = mkdir(dirname, 0666);
+
+    if (result == -1 && errno != EEXIST) {
+        return SDL_SetError("Failed to create '%s' (%s)", dirname, strerror(errno));
+    }
+    return 0;
+}
+
+char *SDL_GetBasePath(void)
+{
+    char buffer[256];
+    size_t len;
+
+    if (!getcwd(buffer, sizeof(buffer) - 1)) {
+        return "/";
+    }
+
+    len = strlen(buffer);
+    if (len > 0 && buffer[len - 1] != '/') {
+        buffer[len] = '/';
+        buffer[len + 1] = '\0';
+    }
+
+    return SDL_strdup(buffer);
+}
+
+char *SDL_GetPrefPath(const char *org, const char *app)
+{
+    char *pref_path = NULL;
+    if (!app) {
+        SDL_InvalidParamError("app");
+        return NULL;
+    }
+
+    SDL_asprintf(&pref_path, "/apps/%s/", app);
+    if (!pref_path) {
+        return NULL;
+    }
+
+    if (create_dir(pref_path) < 0) {
+        SDL_free(pref_path);
+        return NULL;
+    }
+
+    return pref_path;
+}
+
+#endif /* SDL_FILESYSTEM_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 834e83d99e..65dc3ce685 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -105,6 +105,9 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_N3DS
     &SDL_N3DS_JoystickDriver
 #endif
+#ifdef SDL_JOYSTICK_OGC
+    &SDL_OGC_JoystickDriver
+#endif
 #if defined(SDL_JOYSTICK_DUMMY) || defined(SDL_JOYSTICK_DISABLED)
         &SDL_DUMMY_JoystickDriver
 #endif
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index a93fa662ca..3d3329ae5a 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -249,6 +249,7 @@ extern SDL_JoystickDriver SDL_PS2_JoystickDriver;
 extern SDL_JoystickDriver SDL_PSP_JoystickDriver;
 extern SDL_JoystickDriver SDL_VITA_JoystickDriver;
 extern SDL_JoystickDriver SDL_N3DS_JoystickDriver;
+extern SDL_JoystickDriver SDL_OGC_JoystickDriver;
 
 /* Ends C function definitions when using C++ */
 #ifdef __cplusplus
diff --git a/src/joystick/ogc/SDL_sysjoystick.c b/src/joystick/ogc/SDL_sysjoystick.c
new file mode 100644
index 0000000000..56d5beccc4
--- /dev/null
+++ b/src/joystick/ogc/SDL_sysjoystick.c
@@ -0,0 +1,1328 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_JOYSTICK_OGC
+
+#include "../SDL_joystick_c.h"
+#include "../SDL_sysjoystick.h"
+#include "../usb_ids.h"
+#include "SDL_events.h"
+#include "SDL_hints.h"
+#include "../../SDL_hints_c.h"
+#include "SDL_joystick.h"
+
+#include <gccore.h>
+#include <math.h>
+#include <unistd.h>
+#include <wiiuse/wpad.h>
+
+#define PI 3.14159265f
+
+#define MAX_GC_JOYSTICKS  4
+#define MAX_WII_JOYSTICKS 4
+
+#define GC_JOYSTICKS_START  0
+#define GC_JOYSTICKS_END    MAX_GC_JOYSTICKS
+#define WII_JOYSTICKS_START GC_JOYSTICKS_END
+#define WII_WIIMOTES_START  WII_JOYSTICKS_START
+#define WII_WIIMOTES_END    (WII_WIIMOTES_START + MAX_WII_JOYSTICKS)
+#define WII_EXP_START       WII_WIIMOTES_END
+#define WII_EXP_END         (WII_EXP_START + MAX_WII_JOYSTICKS)
+#define WII_JOYSTICKS_END   WII_EXP_END
+
+#define MAX_JOYSTICKS WII_EXP_END
+
+#define MAX_GC_AXES    6
+#define MAX_GC_BUTTONS 8
+#define MAX_GC_HATS    1
+
+#define MAX_WII_AXES    9
+#define MAX_WII_BUTTONS 15
+#define MAX_WII_HATS    1
+
+#define JOYNAMELEN 10
+
+#define AXIS_MIN -32767 /* minimum value for axis coordinate */
+#define AXIS_MAX 32767  /* maximum value for axis coordinate */
+
+#define MAX_RUMBLE 8
+
+typedef struct joystick_paddata_t
+{
+    u16 prev_buttons;
+    s8 stickX;
+    s8 stickY;
+    s8 substickX;
+    s8 substickY;
+    u8 triggerL;
+    u8 triggerR;
+} joystick_paddata;
+
+typedef struct joystick_wpaddata_t
+{
+    u32 prev_buttons;
+    u32 exp;
+    s16 nunchuk_stickX;
+    s16 nunchuk_stickY;
+    s16 classicL_stickX;
+    s16 classicL_stickY;
+    s16 classicR_stickX;
+    s16 classicR_stickY;
+    u8 classic_triggerL;
+    u8 classic_triggerR;
+    u8 classic_calibrated;
+    s8 wiimote_pitch;
+    s8 wiimote_roll;
+    s8 wiimote_yaw;
+    s16 classic_cal[4][3]; // 4x axes, min/center/max
+} joystick_wpaddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata
+{
+    int index;
+    char sensors_disabled;
+    /*  This must be big enough for MAX_RUMBLE */
+    char rumble_intensity;
+    u16 rumble_loop;
+    union
+    {
+        joystick_paddata gamecube;
+        joystick_wpaddata wiimote;
+    };
+} joystick_hwdata;
+
+#ifdef __wii__
+static const u32 sdl_buttons_wii[] = {
+    WPAD_BUTTON_A | WPAD_CLASSIC_BUTTON_A,
+    WPAD_BUTTON_B | WPAD_CLASSIC_BUTTON_B,
+    WPAD_BUTTON_1,
+    WPAD_BUTTON_2,
+    WPAD_BUTTON_MINUS | WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_BUTTON_PLUS | WPAD_CLASSIC_BUTTON_PLUS,
+    WPAD_BUTTON_HOME | WPAD_CLASSIC_BUTTON_HOME,
+    WPAD_NUNCHUK_BUTTON_Z, /* 7 */
+    WPAD_NUNCHUK_BUTTON_C, /* 8 */
+    WPAD_CLASSIC_BUTTON_X, /* 9 */
+    WPAD_CLASSIC_BUTTON_Y,
+    WPAD_CLASSIC_BUTTON_FULL_L,
+    WPAD_CLASSIC_BUTTON_FULL_R,
+    WPAD_CLASSIC_BUTTON_ZL,
+    WPAD_CLASSIC_BUTTON_ZR
+};
+#define SDL_WII_NUM_BUTTONS_WII \
+    (sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0]))
+
+static const u32 sdl_buttons_wiimote[] = {
+    WPAD_BUTTON_A,
+    WPAD_BUTTON_B,
+    WPAD_BUTTON_1,
+    WPAD_BUTTON_2,
+    WPAD_BUTTON_MINUS,
+    WPAD_BUTTON_PLUS,
+    WPAD_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_WIIMOTE \
+    (sizeof(sdl_buttons_wiimote) / sizeof(sdl_buttons_wiimote[0]))
+
+static const u32 sdl_buttons_nunchuck[] = {
+    WPAD_NUNCHUK_BUTTON_Z,
+    WPAD_NUNCHUK_BUTTON_C,
+};
+#define SDL_WII_NUM_BUTTONS_NUNCHUCK \
+    (sizeof(sdl_buttons_nunchuck) / sizeof(sdl_buttons_nunchuck[0]))
+
+static const u32 sdl_buttons_classic[] = {
+    WPAD_CLASSIC_BUTTON_A,
+    WPAD_CLASSIC_BUTTON_B,
+    WPAD_CLASSIC_BUTTON_X,
+    WPAD_CLASSIC_BUTTON_Y,
+    WPAD_CLASSIC_BUTTON_FULL_L,
+    WPAD_CLASSIC_BUTTON_FULL_R,
+    WPAD_CLASSIC_BUTTON_ZL,
+    WPAD_CLASSIC_BUTTON_ZR,
+    WPAD_CLASSIC_BUTTON_MINUS,
+    WPAD_CLASSIC_BUTTON_PLUS,
+    WPAD_CLASSIC_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_CLASSIC \
+    (sizeof(sdl_buttons_classic) / sizeof(sdl_buttons_classic[0]))
+#endif /* __wii__ */
+
+static const u16 sdl_buttons_gc[] = {
+    PAD_BUTTON_A,
+    PAD_BUTTON_B,
+    PAD_BUTTON_X,
+    PAD_BUTTON_Y,
+    PAD_TRIGGER_L,
+    PAD_TRIGGER_R,
+    PAD_TRIGGER_Z,
+    PAD_BUTTON_START,
+};
+
+static int split_joysticks = 0;
+
+static SDL_JoystickID s_connected_instances[MAX_JOYSTICKS];
+/* Value is 0 if controller is not present, otherwise 1 + extension enum */
+static char s_detected_devices[MAX_JOYSTICKS];
+static char s_gc_failed_reads = 0;
+static u32 s_gc_last_scanpads = 0;
+static bool s_hardware_queried = false;
+
+
+#ifdef __wii__
+static bool s_wii_has_new_data[MAX_WII_JOYSTICKS];
+static bool s_accelerometers_as_axes = false;
+static bool s_wiimote_sideways = false;
+
+static void SDLCALL
+on_hint_accel_as_joystick_cb(void *userdata, const char *name,
+                             const char *oldValue, const char *hint)
+{
+    s_accelerometers_as_axes = SDL_GetStringBoolean(hint, SDL_FALSE);
+}
+
+#endif
+
+/* Joypad index is 0-11: 4 GC, 4 Wiimotes and (if split_joysticks) 4 expansions
+ */
+static int device_index_to_joypad_index(int device_index)
+{
+    int count = 0;
+
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        if (s_connected_instances[i] >= 0) {
+            if (count == device_index)
+                return i;
+            count++;
+        }
+    }
+
+    SDL_LogError(SDL_LOG_CATEGORY_INPUT,
+                 "Cannot find device index %d", device_index);
+    return -1;
+}
+
+static int device_index_to_instance(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    if (index < 0)
+        return -1;
+    return s_connected_instances[index];
+}
+
+static void scan_hardware(void)
+{
+    /* Scan the GameCube and Wii controllers, but only if this was not done
+     * before during this update cycle.
+     * The Detect() callback, resets the s_hardware_queried variable. */
+    if (!s_hardware_queried) {
+        s_gc_last_scanpads = PAD_ScanPads();
+#ifdef __wii__
+        for (int i = 0; i < MAX_WII_JOYSTICKS; i++) {
+            s_wii_has_new_data[i] = WPAD_ReadPending(i, NULL);
+        }
+#endif
+        s_hardware_queried = true;
+    }
+}
+
+static void report_joystick(int index, int connected)
+{
+    printf("Controller %d was %s (%d)\n",
+           index, connected ? "connected" : "removed", connected);
+
+    /* First, if the joystick was connected with a different expansion, remove
+     * it */
+    if (s_connected_instances[index] >= 0) {
+        SDL_PrivateJoystickRemoved(s_connected_instances[index]);
+        s_connected_instances[index] = -1;
+    }
+
+    if (connected) {
+        s_connected_instances[index] = SDL_GetNextJoystickInstanceID();
+        SDL_PrivateJoystickAdded(s_connected_instances[index]);
+    }
+}
+
+static inline bool enable_rumble(int index, bool enable)
+{
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        PAD_ControlMotor(index - GC_JOYSTICKS_START,
+                         enable ? PAD_MOTOR_RUMBLE : PAD_MOTOR_STOP);
+        return true;
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_JOYSTICKS_END) {
+        WPAD_Rumble(index - WII_WIIMOTES_START, enable);
+        return true;
+#endif
+    } else {
+        return false;
+    }
+}
+
+static void update_rumble(SDL_Joystick *joystick)
+{
+    char intensity = joystick->hwdata->rumble_intensity;
+    s16 loop;
+    int rest_frames;
+    bool rumble;
+    if (intensity == 0 || intensity == MAX_RUMBLE - 1) return;
+
+    loop = ++joystick->hwdata->rumble_loop;
+
+    /* The rest_frames constant should probably be set according to the current
+     * framerate; or we should rework the logic to be completely time-based.
+     * It may also be that we need different values depending on the controller
+     * type. */
+    rest_frames = 2;
+    if (loop == 1) {
+        rumble = false;
+    } else if (loop > (MAX_RUMBLE - 1 - intensity) * rest_frames) {
+        rumble = true;
+        joystick->hwdata->rumble_loop = 0;
+    } else {
+        /* Keep the engine stopped until our time comes again */
+        return;
+    }
+
+    enable_rumble(joystick->hwdata->index, rumble);
+}
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+static int OGC_JoystickInit(void)
+{
+    const char *split_joystick_env = getenv("SDL_WII_JOYSTICK_SPLIT");
+    split_joysticks = split_joystick_env && strcmp(split_joystick_env, "1") == 0;
+
+    PAD_Init();
+    /* We don't call WPAD_Init() here, since it's already been called by
+     * SDL_main for the Wii */
+
+#ifdef __wii__
+    SDL_AddHintCallback(SDL_HINT_ACCELEROMETER_AS_JOYSTICK,
+                        on_hint_accel_as_joystick_cb, NULL);
+    /* If this is set, the Wiimote directional keys will be translated. */
+    {
+        const char *sideways_joystick_env = getenv("SDL_WII_JOYSTICK_SIDEWAYS");
+        s_wiimote_sideways =
+            sideways_joystick_env && strcmp(sideways_joystick_env, "1") == 0;
+    }
+#endif
+
+    /* Initialize the needed variables */
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        s_connected_instances[i] = -1;
+    }
+    return 0;
+}
+
+static int OGC_JoystickGetCount(void)
+{
+    int count = 0;
+
+    for (int i = 0; i < MAX_JOYSTICKS; i++) {
+        if (s_connected_instances[i] >= 0)
+            count++;
+    }
+    return count;
+}
+
+static void OGC_JoystickDetect(void)
+{
+    scan_hardware();
+
+    /* Ignore individual disconnected statuses, since they might just
+     * happen because the controller is not ready. */
+    if (s_gc_last_scanpads == 0 && s_gc_failed_reads < 4) {
+        s_gc_failed_reads++;
+        s_hardware_queried = false;
+    } else {
+        s_gc_failed_reads = 0;
+        for (int i = 0; i < MAX_GC_JOYSTICKS; i++) {
+            bool connected = s_gc_last_scanpads & (1 << i);
+            bool was_connected = s_detected_devices[i];
+            if (connected == was_connected)
+                continue;
+
+            report_joystick(i, connected);
+            s_detected_devices[i] = connected;
+        }
+    }
+
+#ifdef __wii__
+    for (int i = 0; i < MAX_WII_JOYSTICKS; i++) {
+        int connected, was_connected, index;
+        WPADData *data;
+
+        if (!s_wii_has_new_data[i])
+            continue;
+
+        data = WPAD_Data(i);
+        index = WII_JOYSTICKS_START + i;
+        connected = data->err != WPAD_ERR_NO_CONTROLLER &&
+                    data->data_present != 0;
+        if (split_joysticks) {
+            int exp_index = WII_EXP_START + i;
+            int exp_connected =
+                (connected && data->exp.type != WPAD_EXP_NONE) ? (1 + data->exp.type) : 0;
+            int exp_was_connected = s_detected_devices[exp_index];
+            if (exp_connected != exp_was_connected) {
+                s_detected_devices[exp_index] = exp_connected;
+                report_joystick(exp_index, exp_connected);
+            }
+        } else if (connected) {
+            connected += data->exp.type;
+        }
+
+        was_connected = s_detected_devices[index];
+        if (connected != was_connected) {
+            s_detected_devices[index] = connected;
+            report_joystick(index, connected);
+        }
+    }
+#endif
+
+    /* This is to force a refresh, the next time that Update() or Detect() are
+     * called. This relies on the fact that SDL calls Detect() after Update().
+     */
+    s_hardware_queried = false;
+}
+
+static char joy_name[128];
+
+/* Function to get the device-dependent name of a joystick */
+static const char *OGC_JoystickGetDeviceName(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    if (index < 0)
+        return NULL;
+
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        sprintf(joy_name, "Gamecube %d", index);
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        char *name_ptr = joy_name;
+        int expansion = s_detected_devices[index] - 1;
+        name_ptr += sprintf(name_ptr, "Wiimote %d", index - WII_WIIMOTES_START);
+        if (!split_joysticks) {
+            // Add expansion information
+            switch (expansion) {
+            case WPAD_EXP_NUNCHUK:
+                strcpy(name_ptr, " + Nunchuk");
+                break;
+            case WPAD_EXP_CLASSIC:
+                strcpy(name_ptr, " + Classic");
+                break;
+            case WPAD_EXP_GUITARHERO3:
+                strcpy(name_ptr, " + Guitar Hero 3");
+                break;
+            case WPAD_EXP_WIIBOARD:
+                strcpy(name_ptr, " + Balance board");
+                break;
+            }
+        }
+    } else if (split_joysticks) {
+        /* This is an expansion and we are using the split controllers
+         * option: show only the expansion name, then. */
+        int expansion = s_detected_devices[index] - 1;
+        int idx = index - WII_EXP_START;
+        switch (expansion) {
+        case WPAD_EXP_NUNCHUK:
+            sprintf(joy_name, "Nunchuk %d", idx);
+            break;
+        case WPAD_EXP_CLASSIC:
+            sprintf(joy_name, "Classic %d", idx);
+            break;
+        case WPAD_EXP_GUITARHERO3:
+            sprintf(joy_name, "Guitar Hero 3 %d", idx);
+            break;
+        case WPAD_EXP_WIIBOARD:
+            sprintf(joy_name, "Balance board %d", idx);
+            break;
+        case WPAD_EXP_NONE:
+            strcpy(joy_name, "Disconnected");
+            break;
+        default:
+            sprintf(joy_name, "Unknown %d", idx);
+            break;
+        }
+#endif
+    } else {
+        sprintf(joy_name, "Invalid device index: %d", device_index);
+    }
+    return joy_name;
+}
+
+static const char *OGC_JoystickGetDevicePath(int index)
+{
+    return NULL;
+}
+
+static int OGC_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return -1;
+}
+
+static void OGC_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+static SDL_JoystickGUID OGC_JoystickGetDeviceGUID(int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+    Uint16 bus, product, version;
+    Uint8 driver_signature, driver_data;
+    const char *name;
+
+    /* We invent our own product IDs, to tell our joysticks apart.
+     * Since we want the gamepads to appear with the numeric ID in their
+     * name, we make them unique by assigning a different product depending on
+     * the port. */
+    product = (index + 1) << 8;
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        bus = SDL_HARDWARE_BUS_UNKNOWN;
+    } else {
+        bus = SDL_HARDWARE_BUS_BLUETOOTH;
+        product += s_detected_devices[index];
+    }
+    version = 1;
+    driver_signature = 0;
+    driver_data = 0;
+
+    name = OGC_JoystickGetDeviceName(device_index);
+    return SDL_CreateJoystickGUID(bus, USB_VENDOR_NINTENDO, product, version,
+                                  name, driver_signature, driver_data);
+}
+
+static SDL_JoystickID OGC_JoystickGetDeviceInstanceID(int device_index)
+{
+    return device_index_to_instance(device_index);
+}
+
+static int OGC_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+    int index = device_index_to_joypad_index(device_index);
+
+    printf("Open joystick %d (our index: %d)\n", device_index, index);
+
+    if (index < 0)
+        return -1;
+
+    /* allocate memory for system specific hardware data */
+    joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+    if (joystick->hwdata == NULL) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    joystick->instance_id = s_connected_instances[index];
+
+    SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+    joystick->hwdata->index = index;
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        joystick->nbuttons = MAX_GC_BUTTONS;
+        joystick->naxes = MAX_GC_AXES;
+        joystick->nhats = MAX_GC_HATS;
+#ifdef __wii__
+    } else {
+        if (split_joysticks) {
+            if (index < WII_WIIMOTES_END) {
+                // wiimote
+                joystick->nbuttons = SDL_WII_NUM_BUTTONS_WIIMOTE;
+                joystick->naxes = 3;
+                joystick->nhats = 1;
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+            } else {
+                // expansion
+                joystick->nbuttons = SDL_max(SDL_WII_NUM_BUTTONS_NUNCHUCK,
+                                             SDL_WII_NUM_BUTTONS_CLASSIC);
+                joystick->naxes = 6;
+                joystick->nhats = 1;
+                if (s_detected_devices[index] == 1 + WPAD_EXP_NUNCHUK) {
+                    SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL_L, 100.0f);
+                }
+            }
+        } else {
+            joystick->nbuttons = MAX_WII_BUTTONS;
+            joystick->naxes = MAX_WII_AXES;
+            joystick->nhats = MAX_WII_HATS;
+            /* Add the accelerometer only if there is no expansion connected */
+            if (s_detected_devices[index] == 1) {
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+            } else if (s_detected_devices[index] == 1 + WPAD_EXP_NUNCHUK) {
+                /* Or, if the nunchuck is connected, add the wiimote, and the
+                 * nunchuk on the left */
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL, 100.0f);
+                SDL_PrivateJoystickAddSensor(joystick, SDL_SENSOR_ACCEL_L, 100.0f);
+            }
+        }
+#endif
+    }
+    return 0;
+}
+
+static int OGC_JoystickRumble(SDL_Joystick *joystick,
+                              Uint16 low_frequency_rumble,
+                              Uint16 high_frequency_rumble)
+{
+    int index = joystick->hwdata->index;
+    /* The Wii and GameCube controllers do not support setting the frequency of
+     * the rumble, so we use a hack where we periodically stop and start the
+     * motors during Update(). */
+    char intensity = MAX_RUMBLE *
+        ((low_frequency_rumble + high_frequency_rumble) / 2) /
+        0xffff;
+    /* We don't accept MAX_RUMBLE itself */
+    if (intensity >= MAX_RUMBLE)
+        intensity = MAX_RUMBLE - 1;
+
+    /* If it's the same as the current value, do nothing */
+    if (intensity == joystick->hwdata->rumble_intensity) {
+        return 0;
+    }
+
+    if (!enable_rumble(index, intensity > 0)) {
+        return SDL_Unsupported();
+    }
+
+    /* Save the current rumble status, we need it in update_rumble() */
+    joystick->hwdata->rumble_intensity = intensity;
+    joystick->hwdata->rumble_loop = 0;
+
+    return 0;
+}
+
+static int OGC_JoystickRumbleTriggers(SDL_Joystick *joystick,
+                                      Uint16 left_rumble, Uint16 right_rumble)
+{
+    return SDL_Unsupported();
+}
+
+static Uint32 OGC_JoystickGetCapabilities(SDL_Joystick *joystick)
+{
+    Uint32 capabilities = 0;
+
+    int index = joystick->hwdata->index;
+    if ((index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) ||
+        /* Rumble is supported on the wiimotes, but it makes sense only if no
+         * expansion is attached, of if we are in split mode. */
+        (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END &&
+         (s_detected_devices[index] == 1 || split_joysticks))) {
+        capabilities |= SDL_JOYCAP_RUMBLE;
+    }
+    return capabilities;
+}
+
+static int OGC_JoystickSetLED(SDL_Joystick *joystick,
+                              Uint8 red, Uint8 green, Uint8 blue)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_JoystickSendEffect(SDL_Joystick *joystick,
+                                  const void *data, int size)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_JoystickSetSensorsEnabled(SDL_Joystick *joystick, SDL_bool enabled)
+{
+    int index = joystick->hwdata->index;
+    if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        joystick->hwdata->sensors_disabled = !enabled;
+        return 0;
+    }
+    return SDL_Unsupported();
+}
+
+#ifdef __wii__
+
+static s16 WPAD_Orient(WPADData *data, int motion)
+{
+    float out;
+
+    if (motion == 0)
+        out = data->orient.pitch;
+    else if (motion == 1)
+        out = data->orient.roll;
+    else
+        out = data->orient.yaw;
+
+    return (s16)((out / 180.0) * 128.0);
+}
+
+static s16 WPAD_Pitch(WPADData *data)
+{
+    return WPAD_Orient(data, 0);
+}
+
+static s16 WPAD_Roll(WPADData *data)
+{
+    return WPAD_Orient(data, 1);
+}
+
+static s16 WPAD_Yaw(WPADData *data)
+{
+    return WPAD_Orient(data, 2);
+}
+
+static s16 WPAD_Stick(s16 x, s16 min, s16 center, s16 max, int flip)
+{
+    s16 d;
+    int ret;
+
+    x -= center;
+
+    if (x < 0)
+        d = center - min;
+    else
+        d = max - center;
+
+    if (center - min < 5)
+        return 0;
+    if (max - center < 5)
+        return 0;
+
+    if (d)
+        ret = (x << 15) / d;
+    else
+        return 0;
+
+    if (flip)
+        ret = -ret;
+
+    if (ret < AXIS_MIN)
+        ret = AXIS_MIN;
+    else if (ret > AXIS_MAX)
+        ret = AXIS_MAX;
+
+    return ret;
+}
+
+static const u32 _buttons[8] = {
+    // wiimote
+    WPAD_BUTTON_UP,
+    WPAD_BUTTON_DOWN,
+    WPAD_BUTTON_LEFT,
+    WPAD_BUTTON_RIGHT,
+    // classic
+    WPAD_CLASSIC_BUTTON_UP,
+    WPAD_CLASSIC_BUTTON_DOWN,
+    WPAD_CLASSIC_BUTTON_LEFT,
+    WPAD_CLASSIC_BUTTON_RIGHT
+};
+
+static void HandleWiiHats(SDL_Joystick *joystick,
+                          const u32 changed, const u32 pressed,
+                          const u32 *buttons)
+{
+    if (changed & (buttons[0] | buttons[1] | buttons[2] | buttons[3])) {
+        int hat = SDL_HAT_CENTERED;
+
+        if (pressed & buttons[0])
+            hat |= s_wiimote_sideways ? SDL_HAT_LEFT : SDL_HAT_UP;
+        if (pressed & buttons[1])
+            hat |= s_wiimote_sideways ? SDL_HAT_RIGHT : SDL_HAT_DOWN;
+        if (pressed & buttons[2])
+            hat |= s_wiimote_sideways ? SDL_HAT_DOWN : SDL_HAT_LEFT;
+        if (pressed & buttons[3])
+            hat |= s_wiimote_sideways ? SDL_HAT_UP : SDL_HAT_RIGHT;
+        SDL_PrivateJoystickHat(joystick, 0, hat);
+    }
+}
+
+/* Helpers to separate nunchuk vs classic buttons which share the
+ * same scan codes. In particular, up on the classic controller is
+ * the same as Z on the nunchuk. The numbers refer to the sdl_buttons_wii
+ * list above. */
+static int wii_button_is_nunchuk(int idx)
+{
+    return idx == 7 || idx == 8;
+}
+
+static int wii_button_is_classic(int idx)
+{
+    return idx >= 9;
+}
+
+static void HandleWiiButtons(SDL_Joystick *joystick,
+                             const u32 changed,
+                             const WPADData *data,
+                             const u32 *buttons,
+                             size_t num_buttons)
+{
+    for (int i = 0; i < num_buttons; i++) {
+        if (changed & buttons[i]) {
+            if (!split_joysticks &&
+                ((data->exp.type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+                 (data->exp.type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i))))
+                continue;
+
+            SDL_PrivateJoystickButton(joystick, i,
+                                      (data->btns_d & buttons[i]) ? SDL_PRESSED : SDL_RELEASED);
+        }
+    }
+}
+
+static void HandleWiiMotion(SDL_Joystick *joystick,
+                            joystick_hwdata *prev_state,
+                            WPADData *data,
+                            int start_index)
+{
+    int axis = WPAD_Pitch(data);
+    if (prev_state->wiimote.wiimote_pitch != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index, -(axis << 8));
+        prev_state->wiimote.wiimote_pitch = axis;
+    }
+    axis = WPAD_Roll(data);
+    if (prev_state->wiimote.wiimote_roll != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index + 1, axis << 8);
+        prev_state->wiimote.wiimote_roll = axis;
+    }
+    axis = WPAD_Yaw(data);
+    if (prev_state->wiimote.wiimote_yaw != axis) {
+        SDL_PrivateJoystickAxis(joystick, start_index + 2, axis << 8);
+        prev_state->wiimote.wiimote_yaw = axis;
+    }
+}
+
+static void HandleNunchuckSensors(SDL_Joystick *joystick,
+                                  const nunchuk_t *data)
+{
+    float values[3];
+    SDL_SensorType type;
+
+    if (joystick->hwdata->sensors_disabled) return;
+
+    type = split_joysticks ? SDL_SENSOR_ACCEL : SDL_SENSOR_ACCEL_L;
+    values[0] = data->gforce.x * SDL_STANDARD_GRAVITY;
+    values[1] = data->gforce.z * SDL_STANDARD_GRAVITY;
+    values[2] = -data->gforce.y * SDL_STANDARD_GRAVITY;
+    SDL_PrivateJoystickSensor(joystick, type, 0, values, 3);
+}
+
+static void HandleWiimoteSensors(SDL_Joystick *joystick,
+                                 WPADData *data)
+{
+    float values[3];
+
+    if (joystick->hwdata->sensors_disabled) return;
+
+    values[0] = data->gforce.x * SDL_STANDARD_GRAVITY;
+    values[1] = data->gforce.z * SDL_STANDARD_GRAVITY;
+    values[2] = -data->gforce.y * SDL_STANDARD_GRAVITY;
+    SDL_PrivateJoystickSensor(joystick, SDL_SENSOR_ACCEL, 0, values, 3);
+}
+
+static void _HandleWiiJoystickUpdate(SDL_Joystick *joystick)
+{
+    u32 changed, pressed;
+    int axis, wpad_index;
+    joystick_hwdata *prev_state;
+    WPADData *data;
+    bool update_wiimote, update_expansion;
+
+    prev_state = joystick->hwdata;
+    if (split_joysticks) {
+        if (joystick->hwdata->index >= WII_EXP_START) {
+            wpad_index = joystick->hwdata->index - WII_EXP_START;
+            update_wiimote = false;
+            update_expansion = true;
+        } else {
+            wpad_index = joystick->hwdata->index - WII_WIIMOTES_START;
+            update_wiimote = true;
+            update_expansion = false;
+        }
+    } else {
+        wpad_index = joystick->hwdata->index - WII_WIIMOTES_START;
+        update_wiimote = true;
+        update_expansion = true;
+    }
+
+    if (update_wiimote) {
+        update_rumble(joystick);
+    }
+
+    if (!s_wii_has_new_data[wpad_index])
+        return;
+
+    data = WPAD_Data(wpad_index);
+    changed = data->btns_d | data->btns_u;
+    pressed = data->btns_d | data->btns_h;
+
+    if (update_wiimote) {
+        HandleWiiHats(joystick, changed, pressed, _buttons);
+    }
+    if (update_expansion) {
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            HandleWiiHats(joystick, changed, pressed, _buttons + 4);
+        }
+    }
+
+    if (split_joysticks) {
+        if (update_wiimote) {
+            HandleWiiButtons(joystick, changed, data,
+                             sdl_buttons_wiimote, SDL_WII_NUM_BUTTONS_WIIMOTE);
+        }
+        if (update_expansion) {
+            if (data->exp.type == WPAD_EXP_CLASSIC) {
+                HandleWiiButtons(joystick, changed, data,
+                                 sdl_buttons_classic, SDL_WII_NUM_BUTTONS_CLASSIC);
+            } else if (data->exp.type == WPAD_EXP_NUNCHUK) {
+                HandleWiiButtons(joystick, changed, data,
+                                 sdl_buttons_nunchuck, SDL_WII_NUM_BUTTONS_NUNCHUCK);
+            }
+        }
+    } else {
+        HandleWiiButtons(joystick, changed, data,
+                         sdl_buttons_wii, SDL_WII_NUM_BUTTONS_WII);
+    }
+
+    if (update_expansion) {
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            if (prev_state->wiimote.exp != WPAD_EXP_CLASSIC) {
+                prev_state->wiimote.classic_calibrated = 0;
+                prev_state->wiimote.classic_cal[0][0] = 5;  // left x min
+                prev_state->wiimote.classic_cal[0][2] = 59; // left x max
+                prev_state->wiimote.classic_cal[1][0] = 5;  // left y min
+                prev_state->wiimote.classic_cal[1][2] = 59; // left y max
+                prev_state->wiimote.classic_cal[2][0] = 5;  // right x min
+                prev_state->wiimote.classic_cal[2][2] = 27; // right x max
+                prev_state->wiimote.classic_cal[3][0] = 5;  // right y min
+                prev_state->wiimote.classic_cal[3][2] = 27; // right y max
+            }
+
+            // max/min checking
+            // left stick x
+            if (data->exp.classic.ljs.pos.x < prev_state->wiimote.classic_cal[0][0])
+                prev_state->wiimote.classic_cal[0][0] = data->exp.classic.ljs.pos.x;
+            else if (data->exp.classic.ljs.pos.x > prev_state->wiimote.classic_cal[0][2])
+                prev_state->wiimote.classic_cal[0][2] = data->exp.classic.ljs.pos.x;
+            // left stick y
+            if (data->exp.classic.ljs.pos.y < prev_state->wiimote.classic_cal[1][0])
+                prev_state->wiimote.classic_cal[1][0] = data->exp.classic.ljs.pos.y;
+            else if (data->exp.classic.ljs.pos.y > prev_state->wiimote.classic_cal[1][2])
+                prev_state->wiimote.classic_cal[1][2] = data->exp.classic.ljs.pos.y;
+            // right stick x
+            if (data->exp.classic.rjs.pos.x < prev_state->wiimote.classic_cal[2][0])
+                prev_state->wiimote.classic_cal[2][0] = data->exp.classic.rjs.pos.x;
+            else if (data->exp.classic.rjs.pos.x > prev_state->wiimote.classic_cal[2][2])
+                prev_state->wiimote.classic_cal[2][2] = data->exp.classic.rjs.pos.x;
+            // right stick y
+            if (data->exp.classic.rjs.pos.y < prev_state->wiimote.classic_cal[3][0])
+                prev_state->wiimote.classic_cal[3][0] = data->exp.classic.rjs.pos.y;
+            else if (data->exp.classic.rjs.pos.y > prev_state->wiimote.classic_cal[3][2])
+                prev_state->wiimote.classic_cal[3][2] = data->exp.classic.rjs.pos.y;
+
+            // calibrate center positions
+            if (prev_state->wiimote.classic_calibrated < 5) {
+                prev_state->wiimote.classic_cal[0][1] = data->exp.classic.ljs.pos.x;
+                prev_state->wiimote.classic_cal[1][1] = data->exp.classic.ljs.pos.y;
+                prev_state->wiimote.classic_cal[2][1] = data->exp.classic.rjs.pos.x;
+                prev_state->wiimote.classic_cal[3][1] = data->exp.classic.rjs.pos.y;
+                // this is zero if the expansion hasn't finished initializing
+                if (data->exp.classic.ljs.max.x)
+                    prev_state->wiimote.classic_calibrated++;
+            }
+        }
+
+        if (data->exp.type != prev_state->wiimote.exp) {
+            // Reset the expansion axes
+            for (int i = 0; i < 6; i++)
+                SDL_PrivateJoystickAxis(joystick, i, 0);
+        }
+
+        if (data->exp.type == WPAD_EXP_CLASSIC) {
+            axis = WPAD_Stick(data->exp.classic.ljs.pos.x, prev_state->wiimote.classic_cal[0][0],
+                              prev_state->wiimote.classic_cal[0][1], prev_state->wiimote.classic_cal[0][2], 0);
+            if (prev_state->wiimote.classicL_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 0, axis);
+                prev_state->wiimote.classicL_stickX = axis;
+            }
+            // y axes are reversed
+            axis = WPAD_Stick(data->exp.classic.ljs.pos.y, prev_state->wiimote.classic_cal[1][0],
+                              prev_state->wiimote.classic_cal[1][1], prev_state->wiimote.classic_cal[1][2], 1);
+            if (prev_state->wiimote.classicL_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 1, axis);
+                prev_state->wiimote.classicL_stickY = axis;
+            }
+            axis = WPAD_Stick(data->exp.classic.rjs.pos.x, prev_state->wiimote.classic_cal[2][0],
+                              prev_state->wiimote.classic_cal[2][1], prev_state->wiimote.classic_cal[2][2], 0);
+            if (prev_state->wiimote.classicR_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 2, axis);
+                prev_state->wiimote.classicR_stickX = axis;
+            }
+            axis = WPAD_Stick(data->exp.classic.rjs.pos.y, prev_state->wiimote.classic_cal[3][0],
+                              prev_state->wiimote.classic_cal[3][1], prev_state->wiimote.classic_cal[3][2], 1);
+            if (prev_state->wiimote.classicR_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 3, axis);
+                prev_state->wiimote.classicR_stickY = axis;
+            }
+            axis = data->exp.classic.r_shoulder;
+            if (prev_state->wiimote.classic_triggerR != axis) {
+                SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
+                prev_state->wiimote.classic_triggerR = axis;
+            }
+            axis = data->exp.classic.l_shoulder;
+            if (prev_state->wiimote.classic_triggerL != axis) {
+                SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
+                prev_state->wiimote.classic_triggerL = axis;
+            }
+        } else if (data->exp.type == WPAD_EXP_NUNCHUK) {
+            axis = WPAD_Stick(data->exp.nunchuk.js.pos.x, data->exp.nunchuk.js.min.x,
+                              data->exp.nunchuk.js.center.x, data->exp.nunchuk.js.max.x, 0);
+            if (prev_state->wiimote.nunchuk_stickX != axis) {
+                SDL_PrivateJoystickAxis(joystick, 0, axis);
+                prev_state->wiimote.nunchuk_stickX = axis;
+            }
+            axis = WPAD_Stick(data->exp.nunchuk.js.pos.y, data->exp.nunchuk.js.min.y,
+                              data->exp.nunchuk.js.center.y, data->exp.nunchuk.js.max.y, 1);
+            if (prev_state->wiimote.nunchuk_stickY != axis) {
+                SDL_PrivateJoystickAxis(joystick, 1, axis);
+                prev_state->wiimote.nunchuk_stickY = axis;
+            }
+
+            HandleNunchuckSensors(joystick, &data->exp.nunchuk);
+        }
+    }
+
+    prev_state->wiimote.exp = data->exp.type;
+
+    if (update_wiimote) {
+        if (s_accelerometers_as_axes) {
+            int start_index = split_joysticks ? 0 : 6;
+            HandleWiiMotion(joystick, prev_state, data, start_index);
+        }
+        HandleWiimoteSensors(joystick, data);
+    }
+}
+#endif /* __wii__ */
+
+static void _HandleGCJoystickUpdate(SDL_Joystick *joystick)
+{
+    u16 buttons, prev_buttons, changed;
+    int i;
+    int axis;
+    joystick_hwdata *prev_state;
+    int index = joystick->hwdata->index - GC_JOYSTICKS_START;
+
+    update_rumble(joystick);
+
+    buttons = PAD_ButtonsHeld(index);
+    prev_state = joystick->hwdata;
+    prev_buttons = prev_state->gamecube.prev_buttons;
+    changed = buttons ^ prev_buttons;
+
+    if (changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP)) {
+        int hat = SDL_HAT_CENTERED;
+        if (buttons & PAD_BUTTON_UP)
+            hat |= SDL_HAT_UP;
+        if (buttons & PAD_BUTTON_DOWN)
+            hat |= SDL_HAT_DOWN;
+        if (buttons & PAD_BUTTON_LEFT)
+            hat |= SDL_HAT_LEFT;
+        if (buttons & PAD_BUTTON_RIGHT)
+            hat |= SDL_HAT_RIGHT;
+        SDL_PrivateJoystickHat(joystick, 0, hat);
+    }
+
+    for (i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++) {
+        if (changed & sdl_buttons_gc[i])
+            SDL_PrivateJoystickButton(joystick, i,
+                                      (buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+    }
+    prev_state->gamecube.prev_buttons = buttons;
+    axis = PAD_StickX(index);
+    if (prev_state->gamecube.stickX != axis) {
+        SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+        prev_state->gamecube.stickX = axis;
+    }
+
+    axis = PAD_StickY(index);
+    if (prev_state->gamecube.stickY != axis) {
+        SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+        prev_state->gamecube.stickY = axis;
+    }
+
+    axis = PAD_SubStickX(index);
+    if (prev_state->gamecube.substickX != axis) {
+        SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+        prev_state->gamecube.substickX = axis;
+    }
+
+    axis = PAD_SubStickY(index);
+    if (prev_state->gamecube.substickY != axis) {
+        SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+        prev_state->gamecube.substickY = axis;
+    }
+
+    axis = PAD_TriggerL(index);
+    if (prev_state->gamecube.triggerL != axis) {
+        SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+        prev_state->gamecube.triggerL = axis;
+    }
+
+    axis = PAD_TriggerR(index);
+    if (prev_state->gamecube.triggerR != axis) {
+        SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+        prev_state->gamecube.triggerR = axis;
+    }
+}
+
+static void OGC_JoystickUpdate(SDL_Joystick *joystick)
+{
+    if (!joystick || !joystick->hwdata)
+        return;
+
+    scan_hardware();
+
+    if (joystick->hwdata->index >= GC_JOYSTICKS_START &&
+        joystick->hwdata->index < GC_JOYSTICKS_END) {
+        _HandleGCJoystickUpdate(joystick);
+#ifdef __wii__
+    } else {
+        _HandleWiiJoystickUpdate(joystick);
+#endif
+    }
+}
+
+static void OGC_JoystickClose(SDL_Joystick *joystick)
+{
+    if (!joystick || !joystick->hwdata) // joystick already closed
+        return;
+
+    SDL_free(joystick->hwdata);
+    joystick->hwdata = NULL;
+}
+
+void OGC_JoystickQuit(void)
+{
+#ifdef __wii__
+    SDL_DelHintCallback(SDL_HINT_ACCELEROMETER_AS_JOYSTICK,
+                        on_hint_accel_as_joystick_cb, NULL);
+#endif
+}
+
+static SDL_bool OGC_JoystickGetGamepadMapping(int device_index,
+                                              SDL_GamepadMapping *out)
+{
+    int index = device_index_to_joypad_index(device_index);
+    SDL_bool is_gamepad = SDL_FALSE;
+
+    if (index >= GC_JOYSTICKS_START && index < GC_JOYSTICKS_END) {
+        *out = (SDL_GamepadMapping){
+            .a = { EMappingKind_Button, 0 },
+            .b = { EMappingKind_Button, 2 },
+            .x = { EMappingKind_Button, 1 },
+            .y = { EMappingKind_Button, 3 },
+            .back = { EMappingKind_Button, 6 },
+            .guide = { EMappingKind_None, 255 },
+            .start = { EMappingKind_Button, 7 },
+            .leftstick = { EMappingKind_None, 255 },
+            .rightstick = { EMappingKind_None, 255 },
+            .leftshoulder = { EMappingKind_Button, 4 },
+            .rightshoulder = { EMappingKind_Button, 5 },
+            .dpup = { EMappingKind_Hat, 0x01 },
+            .dpdown = { EMappingKind_Hat, 0x04 },
+            .dpleft = { EMappingKind_Hat, 0x08 },
+            .dpright = { EMappingKind_Hat, 0x02 },
+            .misc1 = { EMappingKind_None, 255 },
+            .paddle1 = { EMappingKind_None, 255 },
+            .paddle2 = { EMappingKind_None, 255 },
+            .paddle3 = { EMappingKind_None, 255 },
+            .paddle4 = { EMappingKind_None, 255 },
+            .leftx = { EMappingKind_Axis, 0 },
+            .lefty = { EMappingKind_Axis, 1 },
+            .rightx = { EMappingKind_Axis, 2 },
+            .righty = { EMappingKind_Axis, 3 },
+            .lefttrigger = { EMappingKind_Axis, 4 },
+            .righttrigger = { EMappingKind_Axis, 5 },
+        };
+        is_gamepad = SDL_TRUE;
+#ifdef __wii__
+    } else if (index >= WII_WIIMOTES_START && index < WII_WIIMOTES_END) {
+        int expansion = s_detected_devices[index] - 1;
+        if (split_joysticks || expansion == 0) {
+            /* Wiimote alone; assume it's being held sideways */
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 2 },
+                .b = { EMappingKind_Button, 3 },
+                .x = { EMappingKind_Button, 0 },
+                .y = { EMappingKind_Button, 1 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_None, 255 },
+                .rightshoulder = { EMappingKind_None, 255 },
+                .dpup = { EMappingKind_Hat, 0x02 },
+                .dpdown = { EMappingKind_Hat, 0x08 },
+                .dpleft = { EMappingKind_Hat, 0x01 },
+                .dpright = { EMappingKind_Hat, 0x04 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_None, 255 },
+                .righty = { EMappingKind_None, 255 },
+                .lefttrigger = { EMappingKind_None, 255 },
+                .righttrigger = { EMappingKind_None, 255 },
+            };
+            is_gamepad = SDL_TRUE;
+        } else if (expansion == WPAD_EXP_NUNCHUK) {
+            /* Wiimote with nunchuck; assume nunchuck on left hand, wiimote
+             * pointed at screen */
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 0 },
+                .b = { EMappingKind_Button, 1 },
+                .x = { EMappingKind_Button, 7 },
+                .y = { EMappingKind_Button, 8 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_None, 255 },
+                .rightshoulder = { EMappingKind_None, 255 },
+                .dpup = { EMappingKind_Hat, 0x01 },
+                .dpdown = { EMappingKind_Hat, 0x04 },
+                .dpleft = { EMappingKind_Hat, 0x08 },
+                .dpright = { EMappingKind_Hat, 0x02 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_Axis, 2 },
+                .righty = { EMappingKind_Axis, 3 },
+                .lefttrigger = { EMappingKind_None, 255 },
+                .righttrigger = { EMappingKind_None, 255 },
+            };
+            is_gamepad = SDL_TRUE;
+        } else if (expansion == WPAD_EXP_CLASSIC) {
+            *out = (SDL_GamepadMapping){
+                .a = { EMappingKind_Button, 1 },
+                .b = { EMappingKind_Button, 0 },
+                .x = { EMappingKind_Button, 10 },
+                .y = { EMappingKind_Button, 9 },
+                .back = { EMappingKind_Button, 6 },
+                .guide = { EMappingKind_Button, 4 },
+                .start = { EMappingKind_Button, 5 },
+                .leftstick = { EMappingKind_None, 255 },
+                .rightstick = { EMappingKind_None, 255 },
+                .leftshoulder = { EMappingKind_Button, 11 },
+                .rightshoulder = { EMappingKind_Button, 12 },
+                .dpup = { EMappingKind_Hat, 0x01 },
+                .dpdown = { EMappingKind_Hat, 0x04 },
+                .dpleft = { EMappingKind_Hat, 0x08 },
+                .dpright = { EMappingKind_Hat, 0x02 },
+                .misc1 = { EMappingKind_None, 255 },
+                .paddle1 = { EMappingKind_None, 255 },
+                .paddle2 = { EMappingKind_None, 255 },
+                .paddle3 = { EMappingKind_None, 255 },
+                .paddle4 = { EMappingKind_None, 255 },
+                .leftx = { EMappingKind_Axis, 0 },
+                .lefty = { EMappingKind_Axis, 1 },
+                .rightx = { EMappingKind_Axis, 2 },
+                .righty = { EMappingKind_Axis, 3 },
+                .lefttrigger = { EMappingKind_Button, 13 },
+                .righttrigger = { EMappingKind_Button, 14 },
+            };
+            is_gamepad = SDL_TRUE;
+        }
+    } else if (index >= WII_EXP_START && index < WII_EXP_END) {
+        /* Wiimote + Extension: only support the classic controller, any other
+         * device is useless as a gamepad. */
+        int expansion = s_detected_devices[index] - 1;
+        if (expansion != WPAD_EXP_CLASSIC)
+            return SDL_FALSE;
+        *out = (SDL_GamepadMapping){
+            .a = { EMappingKind_Button, 1 },
+            .b = { EMappingKind_Button, 0 },
+            .x = { EMappingKind_Button, 3 },
+            .y = { EMappingKind_Button, 2 },
+            .back = { EMappingKind_Button, 10 },
+            .guide = { EMappingKind_Button, 8 },
+            .start = { EMappingKind_Button, 9 },
+            .leftstick = { EMappingKind_None, 255 },
+            .rightstick = { EMappingKind_None, 255 },
+            .leftshoulder = { EMappingKind_Button, 4 },
+            .rightshoulder = { EMappingKind_Button, 5 },
+            .dpup = { EMappingKind_Hat, 0x01 },
+            .dpdown = { EMappingKind_Hat, 0x04 },
+            .dpleft = { EMappingKind_Hat, 0x08 },
+            .dpright = { EMappingKind_Hat, 0x02 },
+            .misc1 = { EMappingKind_None, 255 },
+            .paddle1 = { EMappingKind_None, 255 },
+            .paddle2 = { EMappingKind_None, 255 },
+            .paddle3 = { EMappingKind_None, 255 },
+            .paddle4 = { EMappingKind_None, 255 },
+            .leftx = { EMappingKind_Axis, 0 },
+            .lefty = { EMappingKind_Axis, 1 },
+            .rightx = { EMappingKind_Axis, 2 },
+            .righty = { EMappingKind_Axis, 3 },
+            .lefttrigger = { EMappingKind_Button, 6 },
+            .righttrigger = { EMappingKind_Button, 7 },
+        };
+        is_gamepad = SDL_TRUE;
+#endif /* __wii__ */
+    }
+    return is_gamepad;
+}
+
+SDL_JoystickDriver SDL_OGC_JoystickDriver = {
+    .Init = OGC_JoystickInit,
+    .GetCount = OGC_JoystickGetCount,
+    .Detect = OGC_JoystickDetect,
+    .GetDeviceName = OGC_JoystickGetDeviceName,
+    .GetDevicePath = OGC_JoystickGetDevicePath,
+    .GetDevicePlayerIndex = OGC_JoystickGetDevicePlayerIndex,
+    .SetDevicePlayerIndex = OGC_JoystickSetDevicePlayerIndex,
+    .GetDeviceGUID = OGC_JoystickGetDeviceGUID,
+    .GetDeviceInstanceID = OGC_JoystickGetDeviceInstanceID,
+    .Open = OGC_JoystickOpen,
+    .Rumble = OGC_JoystickRumble,
+    .RumbleTriggers = OGC_JoystickRumbleTriggers,
+    .GetCapabilities = OGC_JoystickGetCapabilities,
+    .SetLED = OGC_JoystickSetLED,
+    .SendEffect = OGC_JoystickSendEffect,
+    .SetSensorsEnabled = OGC_JoystickSetSensorsEnabled,
+    .Update = OGC_JoystickUpdate,
+    .Close = OGC_JoystickClose,
+    .Quit = OGC_JoystickQuit,
+    .GetGamepadMapping = OGC_JoystickGetGamepadMapping
+};
+
+#endif /* SDL_JOYSTICK_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
new file mode 100644
index 0000000000..f0d42bed96
--- /dev/null
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -0,0 +1,54 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef __gamecube__
+
+#include "SDL_main.h"
+
+#ifdef main
+#undef main
+#endif
+
+/* Standard includes */
+#include <stdio.h>
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+    //	SYS_SetPowerCallback(ShutdownCB);
+    //	SYS_SetResetCallback(ResetCB);
+    fatInitDefault();
+    /* Temporarily while developing SDL */
+    SDL_LogSetAllPriority(SDL_LOG_PRIORITY_DEBUG);
+    /* Call the user's main function */
+    return (SDL_main(argc, argv));
+}
+
+#endif /* __gamecube__ */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
new file mode 100644
index 0000000000..47b8b207fe
--- /dev/null
+++ b/src/main/wii/SDL_wii_main.c
@@ -0,0 +1,91 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef __wii__
+
+#include "SDL_main.h"
+
+#include "../../video/ogc/SDL_ogcevents_c.h"
+
+#ifdef main
+#undef main
+#endif
+
+/* Standard includes */
+#include <stdio.h>
+
+/* OGC includes */
+#include <fat.h>
+#include <ogc/usbmouse.h>
+#include <ogcsys.h>
+#include <wiikeyboard/keyboard.h>
+#include <wiiuse/wpad.h>
+
+static void ShutdownCB()
+{
+    OGC_PowerOffRequested = true;
+}
+
+static void ResetCB()
+{
+    OGC_ResetRequested = true;
+}
+
+int main(int argc, char *argv[])
+{
+    u32 version;
+    s32 preferred;
+
+    L2Enhance();
+    version = IOS_GetVersion();
+    preferred = IOS_GetPreferredVersion();
+
+    if (preferred > 0 && version != (u32)preferred)
+        IOS_ReloadIOS(preferred);
+
+    // Wii Power/Reset buttons
+    WPAD_Init();
+    WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
+    SYS_SetPowerCallback(ShutdownCB);
+    SYS_SetResetCallback(ResetCB);
+    // TODO OGC_InitVideoSystem();
+    WPAD_SetDataFormat(WPAD_CHAN_ALL, WPAD_FMT_BTNS_ACC_IR);
+    WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
+
+    MOUSE_Init();
+    KEYBOARD_Init(NULL);
+    fatInitDefault();
+
+    /* Call the user's main function. Make sure that argv contains at least one
+     * element. */
+    if (!argv || argv[0] == NULL) {
+        static const char *dummy_argv[2] = { "app", NULL };
+        argc = 1;
+        argv = (char**)dummy_argv;
+    }
+    return SDL_main(argc, argv);
+}
+
+#endif /* __wii__ */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/render/SDL_render.c b/src/render/SDL_render.c
index b650c6ac40..dc7a5b0b26 100644
--- a/src/render/SDL_render.c
+++ b/src/render/SDL_render.c
@@ -124,6 +124,9 @@ static const SDL_RenderDriver *render_drivers[] = {
 #if SDL_VIDEO_RENDER_VITA_GXM
     &VITA_GXM_RenderDriver,
 #endif
+#ifdef SDL_VIDEO_RENDER_OGC
+    &OGC_RenderDriver,
+#endif
 #if SDL_VIDEO_RENDER_SW
     &SW_RenderDriver
 #endif
diff --git a/src/render/SDL_sysrender.h b/src/render/SDL_sysrender.h
index 36e9555bb1..d3db2b3879 100644
--- a/src/render/SDL_sysrender.h
+++ b/src/render/SDL_sysrender.h
@@ -307,6 +307,7 @@ extern SDL_RenderDriver PS2_RenderDriver;
 extern SDL_RenderDriver PSP_RenderDriver;
 extern SDL_RenderDriver SW_RenderDriver;
 extern SDL_RenderDriver VITA_GXM_RenderDriver;
+extern SDL_RenderDriver OGC_RenderDriver;
 
 /* Blend mode functions */
 extern SDL_BlendFactor SDL_GetBlendModeSrcColorFactor(SDL_BlendMode blendMode);
diff --git a/src/render/ogc/SDL_render_ogc.c b/src/render/ogc/SDL_render_ogc.c
new file mode 100644
index 0000000000..39996c8aec
--- /dev/null
+++ b/src/render/ogc/SDL_render_ogc.c
@@ -0,0 +1,786 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_RENDER_OGC
+
+#include "../SDL_sysrender.h"
+#include "SDL_hints.h"
+
+#include "../../video/ogc/SDL_ogcgxcommon.h"
+#include "../../video/ogc/SDL_ogcpixels.h"
+#include "../../video/ogc/SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/video.h>
+
+#define MAX_EFB_WIDTH 640
+#define MAX_EFB_HEIGHT 528
+
+typedef struct
+{
+    SDL_BlendMode current_blend_mode;
+    int ops_after_present;
+    bool vsync;
+    u8 efb_pixel_format;
+    SDL_Texture *render_target;
+    SDL_Texture *saved_efb_texture;
+} OGC_RenderData;
+
+typedef struct
+{
+    void *texels;
+    void *pixels;
+    SDL_Rect pixels_rect;
+    u16 pitch;
+    u16 pixels_pitch;
+    u8 format;
+    u8 needed_stages; // Normally 1, set to 2 for palettized formats
+} OGC_TextureData;
+
+static void OGC_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture);
+
+static void OGC_WindowEvent(SDL_Renderer *renderer, const SDL_WindowEvent *event)
+{
+}
+
+static void set_blend_mode_real(SDL_Renderer *renderer, SDL_BlendMode blend_mode)
+{
+    switch (blend_mode) {
+    case SDL_BLENDMODE_NONE:
+        GX_SetBlendMode(GX_BM_NONE, GX_BL_ONE, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_BLEND:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_ADD:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_ONE, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_MOD:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_DSTCLR, GX_BL_ZERO, GX_LO_CLEAR);
+        break;
+    case SDL_BLENDMODE_MUL:
+        GX_SetBlendMode(GX_BM_BLEND, GX_BL_DSTCLR, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+        break;
+    default:
+        return;
+    }
+}
+
+static inline void OGC_SetBlendMode(SDL_Renderer *renderer, SDL_BlendMode blend_mode)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    if (blend_mode == data->current_blend_mode) {
+        /* Nothing to do */
+        return;
+    }
+
+    set_blend_mode_real(renderer, blend_mode);
+    data->current_blend_mode = blend_mode;
+}
+
+static void load_efb_from_texture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    OGC_load_texture(ogc_tex->texels, texture->w, texture->h,
+                     ogc_tex->format, SDL_ScaleModeNearest);
+    OGC_SetBlendMode(renderer, SDL_BLENDMODE_NONE);
+
+    /* The viewport is reset when OGC_SetRenderTarget() returns. */
+    OGC_set_viewport(0, 0, texture->w, texture->h);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_S16, 0);
+
+    GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_U8, 0);
+    GX_SetNumTexGens(1);
+    GX_SetNumChans(0);
+
+    GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+    GX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
+    GX_SetTevOp(GX_TEVSTAGE0, GX_REPLACE);
+    GX_SetNumTevStages(1);
+
+    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+    GX_Position2s16(0, 0);
+    GX_TexCoord2u8(0, 0);
+    GX_Position2s16(texture->w, 0);
+    GX_TexCoord2u8(1, 0);
+    GX_Position2s16(texture->w, texture->h);
+    GX_TexCoord2u8(1, 1);
+    GX_Position2s16(0, texture->h);
+    GX_TexCoord2u8(0, 1);
+    GX_End();
+}
+
+static void save_efb_to_texture(SDL_Texture *texture, bool must_clear)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+    u32 texture_size;
+
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    DCInvalidateRange(ogc_tex->texels, texture_size);
+
+    GX_SetTexCopySrc(0, 0, texture->w, texture->h);
+    GX_SetTexCopyDst(texture->w, texture->h, ogc_tex->format, GX_FALSE);
+    GX_CopyTex(ogc_tex->texels, must_clear ? GX_TRUE : GX_FALSE);
+    GX_PixModeSync();
+}
+
+static void update_texture(SDL_Texture *texture, const SDL_Rect *rect,
+                           const void *pixels, int pitch)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+    u32 texture_size;
+
+    OGC_pixels_to_texture((void*)pixels, texture->format, rect,
+                          pitch, ogc_tex->texels, texture->w);
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    /* It would be more effective if we updated only the changed range here,
+     * but the complexity is probably not worth the effort. */
+    DCStoreRange(ogc_tex->texels, texture_size);
+    GX_InvalidateTexAll();
+}
+
+static int OGC_CreateTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    u32 texture_size;
+    OGC_TextureData *ogc_tex;
+
+    ogc_tex = SDL_calloc(1, sizeof(OGC_TextureData));
+    if (!ogc_tex) {
+        return SDL_OutOfMemory();
+    }
+
+    ogc_tex->format = OGC_texture_format_from_SDL(texture->format);
+    ogc_tex->needed_stages = (ogc_tex->format == GX_TF_CI8) ? 2 : 1;
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    ogc_tex->texels = memalign(32, texture_size);
+    if (!ogc_tex->texels) {
+        SDL_free(ogc_tex);
+        return SDL_OutOfMemory();
+    }
+
+    texture->driverdata = ogc_tex;
+    return 0;
+}
+
+static int OGC_LockTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+                           const SDL_Rect *rect, void **pixels, int *pitch)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    ogc_tex->pixels = SDL_malloc(rect->w * rect->h * SDL_BYTESPERPIXEL(texture->format));
+    ogc_tex->pixels_pitch = rect->w * SDL_BYTESPERPIXEL(texture->format);
+    ogc_tex->pixels_rect = *rect;
+    *pixels = ogc_tex->pixels;
+    *pitch = ogc_tex->pixels_pitch;
+    return 0;
+}
+
+static void OGC_UnlockTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    update_texture(texture, &ogc_tex->pixels_rect,
+                   ogc_tex->pixels, ogc_tex->pixels_pitch);
+
+    if (ogc_tex->pixels) {
+        SDL_free(ogc_tex->pixels);
+        ogc_tex->pixels = NULL;
+    }
+}
+
+static int OGC_UpdateTexture(SDL_Renderer *renderer, SDL_Texture *texture,
+                             const SDL_Rect *rect, const void *pixels, int pitch)
+{
+    update_texture(texture, rect, pixels, pitch);
+    return 0;
+}
+
+static void OGC_SetTextureScaleMode(SDL_Renderer *renderer,
+                                    SDL_Texture *texture,
+                                    SDL_ScaleMode scaleMode)
+{
+    /* Nothing to do here: the scale mode is applied to the texture when
+     * loading it in OGC_load_texture(). */
+}
+
+static SDL_Texture *create_efb_texture(OGC_RenderData *data, SDL_Window *window)
+{
+    /* Note: we do return a SDL_Texture, but not via SDL's API, since that does
+     * a bunch of other stuffs we don't care about. We create this texture for
+     * our internal use, so we initialize only those fields we care about. */
+    SDL_Texture *texture;
+    OGC_TextureData *ogc_tex;
+    u32 texture_size;
+
+    texture = SDL_calloc(1, sizeof(*texture));
+    if (!texture) goto fail_texture_alloc;
+
+    ogc_tex = SDL_calloc(1, sizeof(OGC_TextureData));
+    if (!ogc_tex) goto fail_ogc_tex_alloc;
+
+    ogc_tex->format = data->efb_pixel_format == GX_PF_RGBA6_Z24 ?
+        GX_TF_RGBA8 : GX_TF_RGB565;
+    texture->w = window->w;
+    texture->h = window->h;
+    texture_size = GX_GetTexBufferSize(texture->w, texture->h, ogc_tex->format,
+                                       GX_FALSE, 0);
+    ogc_tex->texels = memalign(32, texture_size);
+    if (!ogc_tex->texels) goto fail_texels_alloc;
+
+    texture->driverdata = ogc_tex;
+    return texture;
+
+fail_texels_alloc:
+    SDL_free(ogc_tex->texels);
+fail_ogc_tex_alloc:
+    SDL_free(texture);
+fail_texture_alloc:
+    SDL_OutOfMemory();
+    return NULL;
+}
+
+static int OGC_SetRenderTarget(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_RenderData *data = renderer->driverdata;
+    u8 desired_efb_pixel_format = GX_PF_RGB8_Z24;
+
+    if (data->render_target) {
+        save_efb_to_texture(data->render_target, false);
+    } else if (data->ops_after_present > 0) {
+        /* Save the current EFB contents if we already drew something onto
+         * it. We'll restore it later, when the rendering target is reset
+         * to NULL (the screen). */
+        if (!data->saved_efb_texture)
+            data->saved_efb_texture = create_efb_texture(data, renderer->window);
+        save_efb_to_texture(data->saved_efb_texture, false);
+    }
+
+    if (texture) {
+        if (texture->w > MAX_EFB_WIDTH || texture->h > MAX_EFB_HEIGHT) {
+            return SDL_SetError("Render target (%dx%d) bigger than EFB", texture->w, texture->h);
+        }
+
+        if (SDL_ISPIXELFORMAT_ALPHA(texture->format)) {
+            desired_efb_pixel_format = GX_PF_RGBA6_Z24;
+        }
+    }
+
+    data->render_target = texture;
+
+    if (desired_efb_pixel_format != data->efb_pixel_format) {
+        data->efb_pixel_format = desired_efb_pixel_format;
+        GX_SetPixelFmt(data->efb_pixel_format, GX_ZC_LINEAR);
+    }
+
+    if (texture) {
+        load_efb_from_texture(renderer, texture);
+    } else if (data->saved_efb_texture) {
+        /* Restore the EFB to how it was before the we started to render to a
+         * texture. */
+        load_efb_from_texture(renderer, data->saved_efb_texture);
+        /* We don't free data->saved_efb_texture, it will be reused */
+    }
+
+    return 0;
+}
+
+static int OGC_QueueSetViewport(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    return 0; /* nothing to do in this backend. */
+}
+
+static int OGC_QueueDrawPoints(SDL_Renderer *renderer, SDL_RenderCommand *cmd,
+                               const SDL_FPoint *points, int count)
+{
+    size_t size = count * sizeof(SDL_FPoint);
+    SDL_FPoint *vertices = SDL_AllocateRenderVertices(renderer, size,
+                                                      4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+    SDL_memcpy(vertices, points, size);
+    return 0;
+}
+
+static int OGC_QueueFillRects(SDL_Renderer *renderer, SDL_RenderCommand *cmd,
+                               const SDL_FRect *rects, int count)
+{
+    size_t size = count * sizeof(SDL_FPoint) * 4;
+    SDL_FPoint *vertices = SDL_AllocateRenderVertices(renderer, size,
+                                                      4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    cmd->data.draw.count = count;
+    for (int i = 0; i < count; i++) {
+        vertices[i].x = rects[i].x;
+        vertices[i].y = rects[i].y;
+        vertices[i+1].x = rects[i].x + rects[i].w;
+        vertices[i+1].y = rects[i].y;
+        vertices[i+2].x = rects[i].x + rects[i].w;
+        vertices[i+2].y = rects[i].y + rects[i].h;
+        vertices[i+3].x = rects[i].x;
+        vertices[i+3].y = rects[i].y + rects[i].h;
+    }
+    return 0;
+}
+
+static int OGC_QueueGeometry(SDL_Renderer *renderer, SDL_RenderCommand *cmd, SDL_Texture *texture,
+                             const float *xy, int xy_stride, const SDL_Color *color, int color_stride,
+                             const float *uv, int uv_stride,
+                             int num_vertices, const void *indices, int num_indices, int size_indices,
+                             float scale_x, float scale_y)
+{
+    int i;
+    int count = indices ? num_indices : num_vertices;
+    size_t size_per_element;
+    char *vertices;
+
+    cmd->data.draw.count = count;
+    size_indices = indices ? size_indices : 0;
+
+    size_per_element = sizeof(SDL_FPoint) + sizeof(SDL_Color);
+    if (texture) {
+        size_per_element += sizeof(SDL_FPoint);
+    }
+
+    vertices = SDL_AllocateRenderVertices(renderer, count * size_per_element,
+                                          4, &cmd->data.draw.first);
+    if (!vertices) {
+        return -1;
+    }
+
+    for (i = 0; i < count; i++) {
+        int j;
+        float *xy_;
+        float *uv_;
+        SDL_Color col;
+        char *vertex;
+        SDL_FPoint *vertex_xy;
+        if (size_indices == 4) {
+            j = ((const Uint32 *)indices)[i];
+        } else if (size_indices == 2) {
+            j = ((const Uint16 *)indices)[i];
+        } else if (size_indices == 1) {
+            j = ((const Uint8 *)indices)[i];
+        } else {
+            j = i;
+        }
+
+        xy_ = (float *)((char *)xy + j * xy_stride);
+        col = *(SDL_Color *)((char *)color + j * color_stride);
+        uv_ = (float *)((char *)uv + j * uv_stride);
+
+        vertex = vertices + size_per_element * i;
+
+        vertex_xy = (SDL_FPoint *)vertex;
+        vertex_xy->x = xy_[0] * scale_x;
+        vertex_xy->y = xy_[1] * scale_x;
+
+        *(SDL_Color *)(vertex + sizeof(SDL_FPoint)) = col;
+
+        if (texture) {
+            SDL_FPoint *vertex_uv = (SDL_FPoint *)(vertex + sizeof(SDL_FPoint) + sizeof(SDL_Color));
+            vertex_uv->x = uv_[0];
+            vertex_uv->y = uv_[1];
+        }
+    }
+
+    return 0;
+}
+
+static int OGC_RenderSetViewPort(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    const SDL_Rect *viewport = &cmd->data.viewport.rect;
+
+    OGC_set_viewport(viewport->x, viewport->y, viewport->w, viewport->h);
+    return 0;
+}
+
+static int OGC_RenderSetClipRect(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    const SDL_Rect *rect = &cmd->data.cliprect.rect;
+
+    if (cmd->data.cliprect.enabled) {
+        GX_SetScissor(renderer->viewport.x + rect->x,
+                      renderer->viewport.y + rect->y,
+                      rect->w, rect->h);
+    } else {
+        GX_SetScissor(renderer->viewport.x,
+                      renderer->viewport.y,
+                      renderer->viewport.w,
+                      renderer->viewport.h);
+    }
+
+    return 0;
+}
+
+static int OGC_RenderClear(SDL_Renderer *renderer, SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    GXColor c = {
+        cmd->data.color.r,
+        cmd->data.color.g,
+        cmd->data.color.b,
+        cmd->data.color.a
+    };
+    int16_t x1 = 0;
+    int16_t y1 = 0;
+    int16_t x2 = renderer->window->w;
+    int16_t y2 = renderer->window->h;
+    OGC_set_viewport(0, 0, renderer->window->w, renderer->window->h);
+    OGC_SetBlendMode(renderer, SDL_BLENDMODE_NONE);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_S16, 0);
+    GX_SetTevColor(GX_TEVREG0, c);
+    GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
+    GX_SetTevAlphaIn(GX_TEVSTAGE0, GX_CA_A0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
+    GX_SetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+    GX_SetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+    GX_SetNumTevStages(1);
+    GX_SetNumChans(0);
+
+    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+    GX_Position2s16(x1, y1);
+    GX_Position2s16(x2, y1);
+    GX_Position2s16(x2, y2);
+    GX_Position2s16(x1, y2);
+    GX_End();
+    data->ops_after_present++;
+
+    /* Restore the viewport */
+    OGC_set_viewport(renderer->viewport.x, renderer->viewport.y,
+                     renderer->viewport.w, renderer->viewport.h);
+    return 0;
+}
+
+static int OGC_RenderGeometry(SDL_Renderer *renderer, void *vertices,
+                              SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+    const size_t count = cmd->data.draw.count;
+    SDL_Texture *texture = cmd->data.draw.texture;
+    size_t size_per_element;
+
+    data->ops_after_present++;
+    OGC_SetBlendMode(renderer, cmd->data.draw.blend);
+
+    size_per_element = sizeof(SDL_FPoint) + sizeof(SDL_Color);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxDesc(GX_VA_CLR0, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_F32, 0);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
+    if (texture) {
+        OGC_TextureData *ogc_tex = texture->driverdata;
+        u8 stage;
+
+        size_per_element += sizeof(SDL_FPoint);
+        OGC_load_texture(ogc_tex->texels, texture->w, texture->h,
+                         ogc_tex->format, texture->scaleMode);
+        stage = GX_TEVSTAGE0 + ogc_tex->needed_stages - 1;
+
+        GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);
+        GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+        GX_SetNumTexGens(1);
+
+        GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+        GX_SetTevOrder(stage, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);
+        GX_SetTevOp(stage, GX_MODULATE);
+        GX_SetNumTevStages(stage - GX_TEVSTAGE0 + 1);
+    } else {
+        GX_SetTevOp(GX_TEVSTAGE0, GX_PASSCLR);
+        GX_SetNumTevStages(1);
+    }
+    GX_SetNumChans(1);
+
+    GX_Begin(GX_TRIANGLES, GX_VTXFMT0, count);
+    for (int i = 0; i < count; i++) {
+        void *vertex = vertices + cmd->data.draw.first + size_per_element * i;
+        SDL_FPoint *vertex_xy = vertex;
+        SDL_Color *c = (SDL_Color*)(vertex + sizeof(SDL_FPoint));
+
+        GX_Position2f32(vertex_xy->x, vertex_xy->y);
+        GX_Color4u8(c->r, c->g, c->b, c->a);
+        if (texture) {
+            SDL_FPoint *vertex_uv = (SDL_FPoint *)(vertex + sizeof(SDL_FPoint) + sizeof(SDL_Color));
+            GX_TexCoord2f32(vertex_uv->x, vertex_uv->y);
+        }
+    }
+    GX_End();
+    return 0;
+}
+
+int OGC_RenderPrimitive(SDL_Renderer *renderer, u8 primitive,
+                        void *vertices, SDL_RenderCommand *cmd)
+{
+    OGC_RenderData *data = renderer->driverdata;
+    size_t count = cmd->data.draw.count;
+    const SDL_FPoint *verts = (SDL_FPoint *)(vertices + cmd->data.draw.first);
+    Mtx mv;
+    bool did_change_matrix = false;
+    GXColor c = {
+        cmd->data.draw.r,
+        cmd->data.draw.g,
+        cmd->data.draw.b,
+        cmd->data.draw.a
+    };
+
+    data->ops_after_present++;
+    OGC_SetBlendMode(renderer, cmd->data.draw.blend);
+
+    if (primitive == GX_LINESTRIP || primitive == GX_POINTS) {
+        float adjustment = 0.5;
+        guMtxIdentity(mv);
+        guMtxTransApply(mv, mv, adjustment, adjustment, 0);
+        GX_LoadPosMtxImm(mv, GX_PNMTX0);
+        did_change_matrix = true;
+    }
+
+    /* TODO: optimize state changes. */
+    GX_SetTevColor(GX_TEVREG0, c);
+    GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_C0, GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO);
+    GX_SetTevAlphaIn(GX_TEVSTAGE0, GX_CA_A0, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO);
+    GX_SetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+    GX_SetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_F32, 0);
+
+    if (primitive == GX_QUADS) count *= 4;
+
+    GX_Begin(primitive, GX_VTXFMT0, count);
+    for (int i = 0; i < count; i++) {
+        GX_Position2f32(verts[i].x, verts[i].y);
+    }
+    GX_End();
+
+    /* The last point is not drawn */
+    if (primitive == GX_LINESTRIP) {
+        GX_Begin(GX_POINTS, GX_VTXFMT0, count);
+        for (int i = 0; i < count; i++) {
+            GX_Position2f32(verts[i].x, verts[i].y);
+        }
+        GX_End();
+    }
+
+    if (did_change_matrix) {
+        guMtxIdentity(mv);
+        GX_LoadPosMtxImm(mv, GX_PNMTX0);
+    }
+
+    return 0;
+}
+
+static int OGC_RunCommandQueue(SDL_Renderer *renderer, SDL_RenderCommand *cmd, void *vertices, size_t vertsize)
+{
+    while (cmd) {
+        switch (cmd->command) {
+        case SDL_RENDERCMD_SETVIEWPORT:
+            OGC_RenderSetViewPort(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_SETCLIPRECT:
+            OGC_RenderSetClipRect(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_SETDRAWCOLOR:
+            /* This is a no-op, since every command carries the color, and
+             * setting it on the FIFO is not expensive. */
+            break;
+        case SDL_RENDERCMD_CLEAR:
+            OGC_RenderClear(renderer, cmd);
+            break;
+        case SDL_RENDERCMD_DRAW_POINTS:
+            OGC_RenderPrimitive(renderer, GX_POINTS, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_DRAW_LINES:
+            OGC_RenderPrimitive(renderer, GX_LINESTRIP, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_FILL_RECTS:
+            OGC_RenderPrimitive(renderer, GX_QUADS, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_COPY: /* unused */
+            break;
+        case SDL_RENDERCMD_COPY_EX: /* unused */
+            break;
+        case SDL_RENDERCMD_GEOMETRY:
+            OGC_RenderGeometry(renderer, vertices, cmd);
+            break;
+        case SDL_RENDERCMD_NO_OP:
+            break;
+        }
+        cmd = cmd->next;
+    }
+
+    GX_DrawDone();
+    return 0;
+}
+
+static int OGC_RenderReadPixels(SDL_Renderer *renderer, const SDL_Rect *rect,
+                                Uint32 format, void *pixels, int pitch)
+{
+    return SDL_Unsupported();
+}
+
+static int OGC_RenderPresent(SDL_Renderer *renderer)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    GX_DrawDone();
+
+    OGC_video_flip(SDL_GetVideoDevice(), data->vsync);
+
+    /* Mouse cursor and OSK can change the blending mode; restore it. */
+    set_blend_mode_real(renderer, data->current_blend_mode);
+
+    data->ops_after_present = 0;
+    return 0;
+}
+
+static void OGC_DestroyTexture(SDL_Renderer *renderer, SDL_Texture *texture)
+{
+    OGC_TextureData *ogc_tex = texture->driverdata;
+
+    if (ogc_tex) {
+        free(ogc_tex->texels);
+        SDL_free(ogc_tex);
+        texture->driverdata = NULL;
+    }
+}
+
+static void OGC_DestroyRenderer(SDL_Renderer *renderer)
+{
+    OGC_RenderData *data = renderer->driverdata;
+
+    if (data) {
+        GX_DrawDone();
+        if (data->saved_efb_texture) {
+            OGC_DestroyTexture(renderer, data->saved_efb_texture);
+            SDL_free(data->saved_efb_texture);
+        }
+
+        SDL_free(data);
+    }
+
+    SDL_free(renderer);
+}
+
+static int OGC_SetVSync(SDL_Renderer *renderer, const int vsync)
+{
+    OGC_RenderData *data = (OGC_RenderData *)renderer->driverdata;
+    data->vsync = vsync ? 1 : 0;
+    return 0;
+}
+
+static SDL_Renderer *OGC_CreateRenderer(SDL_Window *window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    OGC_RenderData *data;
+
+    renderer = (SDL_Renderer *)SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (OGC_RenderData *)SDL_calloc(1, sizeof(*data));
+    if (!data) {
+        OGC_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data->efb_pixel_format = GX_PF_RGB8_Z24;
+    data->current_blend_mode = SDL_BLENDMODE_INVALID;
+    data->vsync = true;
+
+    renderer->WindowEvent = OGC_WindowEvent;
+    renderer->CreateTexture = OGC_CreateTexture;
+    renderer->UpdateTexture = OGC_UpdateTexture;
+    renderer->LockTexture = OGC_LockTexture;
+    renderer->UnlockTexture = OGC_UnlockTexture;
+    renderer->SetTextureScaleMode = OGC_SetTextureScaleMode;
+    renderer->SetRenderTarget = OGC_SetRenderTarget;
+    renderer->QueueSetViewport = OGC_QueueSetViewport;
+    renderer->QueueSetDrawColor = OGC_QueueSetViewport;
+    renderer->QueueDrawPoints = OGC_QueueDrawPoints;
+    renderer->QueueDrawLines = OGC_QueueDrawPoints;
+    renderer->QueueFillRects = OGC_QueueFillRects;
+    renderer->QueueGeometry = OGC_QueueGeometry;
+    renderer->RunCommandQueue = OGC_RunCommandQueue;
+    renderer->RenderReadPixels = OGC_RenderReadPixels;
+    renderer->RenderPresent = OGC_RenderPresent;
+    renderer->DestroyTexture = OGC_DestroyTexture;
+    renderer->DestroyRenderer = OGC_DestroyRenderer;
+    renderer->SetVSync = OGC_SetVSync;
+    renderer->info = OGC_RenderDriver.info;
+    renderer->driverdata = data;
+    renderer->window = window;
+
+    if (!SDL_GetHint(SDL_HINT_RENDER_LINE_METHOD)) {
+        /* SDL sets the default one to point drawing, but we prefer lines */
+        SDL_SetHint(SDL_HINT_RENDER_LINE_METHOD, "2");
+    }
+
+    return renderer;
+}
+
+SDL_RenderDriver OGC_RenderDriver = {
+    .CreateRenderer = OGC_CreateRenderer,
+    .info = {
+        .name = "ogc",
+        .flags = SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC | SDL_RENDERER_TARGETTEXTURE,
+        .num_texture_formats = 5,
+        .texture_formats = {
+            [0] = SDL_PIXELFORMAT_RGB565,
+            [1] = SDL_PIXELFORMAT_RGBA8888,
+            [2] = SDL_PIXELFORMAT_ARGB8888,
+            [3] = SDL_PIXELFORMAT_RGB24,
+            [4] = SDL_PIXELFORMAT_XRGB8888,
+            // TODO: add more
+        },
+        .max_texture_width = 1024,
+        .max_texture_height = 1024,
+    }
+};
+
+#endif /* SDL_VIDEO_RENDER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 278a680268..f2791f1ffa 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -32,7 +32,9 @@
 #include "pthread/SDL_systhread_c.h"
 #elif SDL_THREAD_WINDOWS
 #include "windows/SDL_systhread_c.h"
-#elif SDL_THREAD_PS2
+#elif defined(SDL_THREAD_OGC)
+#include "ogc/SDL_systhread_c.h"
+#elif defined(SDL_THREAD_PS2)
 #include "ps2/SDL_systhread_c.h"
 #elif SDL_THREAD_PSP
 #include "psp/SDL_systhread_c.h"
diff --git a/src/thread/ogc/SDL_syscond.c b/src/thread/ogc/SDL_syscond.c
new file mode 100644
index 0000000000..352fd7bf66
--- /dev/null
+++ b/src/thread/ogc/SDL_syscond.c
@@ -0,0 +1,131 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+#include "SDL_sysmutex_c.h"
+
+#include <ogcsys.h>
+#include <ogc/cond.h>
+
+struct SDL_cond
+{
+    cond_t cond;
+};
+
+/* Create a condition variable */
+SDL_cond * SDL_CreateCond(void)
+{
+    SDL_cond *cond;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        if (LWP_CondInit(&(cond->cond)) < 0) {
+            SDL_DestroyCond(cond);
+            cond = NULL;
+        }
+    } else {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        LWP_CondDestroy(cond->cond);
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    return LWP_CondSignal(cond->cond) == 0 ? 0 : -1;
+
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+
+    return LWP_CondBroadcast(cond->cond) == 0 ? 0 : -1;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+ The mutex must be locked before entering this function!
+ The mutex is unlocked during the wait, and locked again after the wait.
+
+ Typical use:
+
+ Thread A:
+ SDL_LockMutex(lock);
+ while ( ! condition ) {
+ SDL_CondWait(cond);
+ }
+ SDL_UnlockMutex(lock);
+
+ Thread B:
+ SDL_LockMutex(lock);
+ ...
+ condition = true;
+ ...
+ SDL_UnlockMutex(lock);
+ */
+
+
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    struct timespec time;
+
+    if (!cond) {
+        SDL_SetError("Passed a NULL condition variable");
+        return -1;
+    }
+    //LWP_CondTimedWait expects relative timeout
+    time.tv_sec = (ms / 1000);
+    time.tv_nsec = (ms % 1000) * 1000000;
+
+    return LWP_CondTimedWait(cond->cond, mutex->id, &time);
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    return LWP_CondWait(cond->cond, mutex->id);
+}
diff --git a/src/thread/ogc/SDL_sysmutex.c b/src/thread/ogc/SDL_sysmutex.c
new file mode 100644
index 0000000000..210fef09b7
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex.c
@@ -0,0 +1,81 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <ogcsys.h>
+
+struct SDL_mutex
+{
+    u32 id;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex = NULL;
+
+    /* Allocate mutex memory */
+    mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        LWP_MutexInit(&mutex->id, 0);
+    } else {
+        SDL_OutOfMemory();
+    }
+    return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+    if (mutex) {
+        LWP_MutexDestroy(mutex->id);
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        SDL_SetError("Passed a NULL mutex");
+        return -1;
+    }
+
+    return LWP_MutexLock(mutex->id);
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        SDL_SetError("Passed a NULL mutex");
+        return -1;
+    }
+
+    return LWP_MutexUnlock(mutex->id);
+
+}
diff --git a/src/thread/ogc/SDL_sysmutex_c.h b/src/thread/ogc/SDL_sysmutex_c.h
new file mode 100644
index 0000000000..fe692acc05
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+struct SDL_mutex {
+    Uint32 id;
+};
diff --git a/src/thread/ogc/SDL_syssem.c b/src/thread/ogc/SDL_syssem.c
new file mode 100644
index 0000000000..825de911fb
--- /dev/null
+++ b/src/thread/ogc/SDL_syssem.c
@@ -0,0 +1,162 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_semaphore
+{
+    Uint32 count;
+    Uint32 waiters_count;
+    SDL_mutex *count_lock;
+    SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    sem->count = initial_value;
+    sem->waiters_count = 0;
+
+    sem->count_lock = SDL_CreateMutex();
+    sem->count_nonzero = SDL_CreateCond();
+    if (!sem->count_lock || !sem->count_nonzero) {
+        SDL_DestroySemaphore(sem);
+        return NULL;
+    }
+
+    return sem;
+}
+
+/* WARNING:
+ You cannot call this function when another thread is using the semaphore.
+ */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+    if (sem) {
+        sem->count = 0xFFFFFFFF;
+        while (sem->waiters_count > 0) {
+            SDL_CondSignal(sem->count_nonzero);
+            SDL_Delay(10);
+        }
+        SDL_DestroyCond(sem->count_nonzero);
+        if (sem->count_lock) {
+            SDL_mutexP(sem->count_lock);
+            SDL_mutexV(sem->count_lock);
+            SDL_DestroyMutex(sem->count_lock);
+        }
+        SDL_free(sem);
+    }
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    retval = SDL_MUTEX_TIMEDOUT;
+    SDL_LockMutex(sem->count_lock);
+    if (sem->count > 0) {
+        --sem->count;
+        retval = 0;
+    }
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    /* A timeout of 0 is an easy case */
+    if (timeout == 0) {
+        return SDL_SemTryWait(sem);
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    ++sem->waiters_count;
+    retval = 0;
+    while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT)) {
+        retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock,
+                timeout);
+    }
+    --sem->waiters_count;
+    --sem->count;
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+    Uint32 value;
+
+    value = 0;
+    if (sem) {
+        SDL_LockMutex(sem->count_lock);
+        value = sem->count;
+        SDL_UnlockMutex(sem->count_lock);
+    }
+    return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    if (sem->waiters_count > 0) {
+        SDL_CondSignal(sem->count_nonzero);
+    }
+    ++sem->count;
+    SDL_UnlockMutex(sem->count_lock);
+
+    return 0;
+}
diff --git a/src/thread/ogc/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
new file mode 100644
index 0000000000..558cce7e9f
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread.c
@@ -0,0 +1,92 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+
+#include <ogcsys.h>
+
+void *run_thread(void *data)
+{
+    SDL_RunThread(data);
+    return (void *) 0; /* Prevent compiler warning */
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread)
+{
+    if (LWP_CreateThread(&thread->handle, run_thread,
+                         thread, 0, 0, 64) != 0 ) {
+        SDL_SetError("Not enough resources to create thread");
+        return -1;
+    }
+
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    u8 value;
+
+    /* Range is 0 (lowest) to 127 (highest) */
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 0;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = 80;
+    } else if (priority == SDL_THREAD_PRIORITY_TIME_CRITICAL) {
+        value = 127;
+    } else {
+        value = 64;
+    }
+    LWP_SetThreadPriority(LWP_THREAD_NULL, value);
+    return 0;
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID)LWP_GetSelf();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    void *v;
+    LWP_JoinThread(thread->handle, &v);
+    return;
+}
+
+void SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+    /* Do nothing. */
+    thread->handle = LWP_THREAD_NULL;
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+    return;
+}
diff --git a/src/thread/ogc/SDL_systhread_c.h b/src/thread/ogc/SDL_systhread_c.h
new file mode 100644
index 0000000000..43caca7ebc
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread_c.h
@@ -0,0 +1,24 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+typedef Uint32 SYS_ThreadHandle;
diff --git a/src/timer/ogc/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
new file mode 100644
index 0000000000..664e495c5f
--- /dev/null
+++ b/src/timer/ogc/SDL_systimer.c
@@ -0,0 +1,76 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMER_OGC
+
+#include <ogc/lwp_watchdog.h>
+#include <ogcsys.h>
+
+static SDL_bool ticks_started = SDL_FALSE;
+static u64 start;
+
+void SDL_TicksInit(void)
+{
+    if (ticks_started) {
+        return;
+    }
+    ticks_started = SDL_TRUE;
+
+    start = gettime();
+}
+
+void SDL_TicksQuit(void)
+{
+    ticks_started = SDL_FALSE;
+}
+
+Uint64 SDL_GetTicks64(void)
+{
+    const u64 ticks = gettime() - start;
+    const u64 ms = ticks / TB_TIMER_CLOCK;
+    return ms;
+}
+
+Uint64 SDL_GetPerformanceCounter(void)
+{
+    return gettime();
+}
+
+Uint64 SDL_GetPerformanceFrequency(void)
+{
+    return secs_to_ticks(1);
+}
+
+void SDL_Delay(Uint32 ms)
+{
+    struct timespec elapsed, tv;
+    elapsed.tv_sec = ms / 1000;
+    elapsed.tv_nsec = (ms % 1000) * 1000000;
+    tv.tv_sec = elapsed.tv_sec;
+    tv.tv_nsec = elapsed.tv_nsec;
+    nanosleep(&tv, &elapsed);
+}
+
+#endif /* SDL_TIMER_OGC */
+
+/* vi: set sts=4 ts=4 sw=4 expandtab: */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index d7a42cc64d..db2cb54c85 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -468,6 +468,7 @@ extern VideoBootStrap PSP_bootstrap;
 extern VideoBootStrap VITA_bootstrap;
 extern VideoBootStrap RISCOS_bootstrap;
 extern VideoBootStrap N3DS_bootstrap;
+extern VideoBootStrap OGC_bootstrap;
 extern VideoBootStrap RPI_bootstrap;
 extern VideoBootStrap KMSDRM_bootstrap;
 extern VideoBootStrap KMSDRM_LEGACY_bootstrap;
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 8065a0b8cf..e5412450c7 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -110,6 +110,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_N3DS
     &N3DS_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+    &OGC_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_KMSDRM
     &KMSDRM_bootstrap,
 #endif
diff --git a/src/video/ogc/SDL_ogccursors.h b/src/video/ogc/SDL_ogccursors.h
new file mode 100644
index 0000000000..24d0608c37
--- /dev/null
+++ b/src/video/ogc/SDL_ogccursors.h
@@ -0,0 +1,480 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+typedef struct _OGC_Cursor {
+    uint16_t width;
+    uint16_t height;
+    uint8_t hot_x;
+    uint8_t hot_y;
+    uint8_t bytes_per_pixel;
+    uint8_t pixel_data[];
+} OGC_Cursor;
+
+static const OGC_Cursor OGC_cursor_hand = {
+  37, 52, 11, 0, 4,
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Q\000"
+  "\000\000\262\000\000\000\337\000\000\000\345\000\000\000\313\000\000\000\203\000\000\000\032\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005"
+  "\000\000\000\224\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000"
+  "\000\000\330\000\000\000\062\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\177\000\000\000\377\000\000\000\377\026\026\026\377bbb\377ttt\377"
+  "<<<\377\000\000\000\377\000\000\000\377\000\000\000\334\000\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000%\000\000\000\364\000\000\000\377...\377\327\327"
+  "\327\377\377\377\377\377\377\377\377\377\373\373\373\377\177\177\177\377"
+  "\000\000\000\377\000\000\000\377\000\000\000\206\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000n\000\000\000\377\005\005\005\377\277\277\277\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377BBB\377\000"
+  "\000\000\377\000\000\000\323\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\225\000\000\000\377###\377\366\366\366\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\206\206\206\377\000\000"
+  "\000\377\000\000\000\356\000\000\000\033\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\231\000\000\000\377+++\377\370\370\370\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\217\217\217\377\000\000\000\377"
+  "\000\000\000\361\000\000\000\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\230\000\000\000\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000"
+  "\000\000\360\000\000\000\037\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230"
+  "\000\000\000\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000"
+  "\360\000\000\000\037\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000"
+  "\000\000\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\360"
+  "\000\000\000\037\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000"
+  "\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\360\000\000"
+  "\000\037\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377"
+  "***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\360\000\000\000\037"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377***\377"
+  "\367\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\360\000\000\000\037\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377***\377\367"
+  "\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\357\000\000\000\026\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377***\377\367\367"
+  "\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\370\000\000\000\244\000\000\000\223"
+  "\000\000\000e\000\000\000\032\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377***\377\367\367"
+  "\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\215\215\215\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377"
+  "\000\000\000\377\000\000\000\340\000\000\000Z\000\000\000\000\000\000\000\003\000\000\000\022\000\000\000\006\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000\377***\377\367"
+  "\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\215\215\215\377\000\000\000\377\001\001\001\377%%%\377\036\036\036"
+  "\377\000\000\000\377\000\000\000\377\000\000\000\373\000\000\000\244\000\000\000\310\000\000\000\341\000\000\000\320"
+  "\000\000\000\220\000\000\000*\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\230\000\000\000"
+  "\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\210\210\210\377\022\022\022\377\270\270\270"
+  "\377\356\356\356\377\351\351\351\377\236\236\236\377\022\022\022\377\000\000\000\377"
+  "\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\357\000\000\000[\000\000\000"
+  "\030\000\000\000<\000\000\000B\000\000\000(\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\227\000\000\000\377***\377\367\367\367\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\202\202\202\377\065\065\065\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\246\246\246\377\001\001\001\377\003\003\003\377@@@\377iii\377DD"
+  "D\377\002\002\002\377\000\000\000\377\000\000\000\372\000\000\000\342\000\000\000\375\000\000\000\377\000\000\000\360"
+  "\000\000\000\264\000\000\000:\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\233\000\000\000\377***\377\367\367\367\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\203\203\203\377\061\061\061"
+  "\377\375\375\375\377\377\377\377\377\377\377\377\377\377\377\377\377\372"
+  "\372\372\377\036\036\036\377kkk\377\375\375\375\377\377\377\377\377\377\377"
+  "\377\377\253\253\253\377\015\015\015\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000"
+  "\377\000\000\000\377\000\000\000\377\000\000\000\366\000\000\000U\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016"
+  "\000\000\000n\000\000\000\272\000\000\000\360\000\000\000\377***\377\367\367\367\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\203"
+  "\203\203\377\061\061\061\377\375\375\375\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\376\376\376\377\063\063\063\377\211\211\211\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\177\177\177\377\000\000"
+  "\000\377AAA\377\236\236\236\377\256\256\256\377lll\377\011\011\011\377\000\000\000\377"
+  "\000\000\000\360\000\000\000)\000\000\000\000\000\000\000!\000\000\000\304\000\000\000\377\000\000\000\377\000\000\000\377"
+  "\000\000\000\377***\377\367\367\367\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\203\203\203\377\061\061\061\377\375"
+  "\375\375\377\377\377\377\377\377\377\377\377\377\377\377\377\375\375\375"
+  "\377\061\061\061\377\203\203\203\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\304\304\304\377\011\011\011\377\327\327\327\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\247\247\247\377\006\006\006\377\000"
+  "\000\000\377\000\000\000\225\000\000\000\016\000\000\000\312\000\000\000\377\000\000\000\377(((\377aaa\377\067"
+  "\067\067\377'''\377\366\366\366\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\203\203\203\377\061\061\061\377\375"
+  "\375\375\377\377\377\377\377\377\377\377\377\377\377\377\377\375\375\375"
+  "\377\061\061\061\377\203\203\203\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\313\313\313\377\015\015\015\377\323\323\323\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377NNN\377\000\000\000"
+  "\377\000\000\000\324\000\000\000s\000\000\000\377\000\000\000\377fff\377\357\357\357\377\377\377"
+  "\377\377\244\244\244\377###\377\365\365\365\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377|||\377&&&\377\375\375"
+  "\375\377\377\377\377\377\377\377\377\377\377\377\377\377\375\375\375\377"
+  "&&&\377|||\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\306\306\306\377\001\001\001\377\317\317\317\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\200\200\200\377\000\000\000\377\000\000\000\345"
+  "\000\000\000\305\000\000\000\377\062\062\062\377\371\371\371\377\377\377\377\377\377\377"
+  "\377\377\235\235\235\377###\377\365\365\365\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\274\274\274\377\221"
+  "\221\221\377\376\376\376\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\376\376\376\377\221\221\221\377\274\274\274\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\342\342\340\377\200\200\200"
+  "\377\347\347\347\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\202\202\202\377\000\000\000\377\000\000\000\345\000\000\000\342\000\000\000\377www\377"
+  "\377\377\377\377\376\376\376\377\377\377\377\377\235\235\235\377!##\377\365"
+  "\365\365\377\377\377\377\377\374\376\376\377\374\376\376\377\374\376\376"
+  "\377\374\376\376\377\377\377\377\377\377\377\377\377\374\376\376\377\374"
+  "\376\376\377\374\376\376\377\374\376\376\377\374\376\376\377\377\377\377"
+  "\377\377\377\377\377\374\376\376\377\374\376\376\377\374\376\376\377\374"
+  "\376\376\377\377\377\377\377\377\377\377\377\377\377\377\377\374\376\376"
+  "\377\374\376\376\377\374\376\376\377\377\377\377\377\201\201\201\377\000\000"
+  "\000\377\000\000\000\345\000\000\000\346\000\000\000\377\203\203\203\377\377\377\377\377\375"
+  "\373\375\377\377\377\377\377\233\233\235\377!!#\377\363\363\365\377\377\377"
+  "\377\377\373\373\376\377\373\373\376\377\373\373\376\377\373\373\376\377"
+  "\373\373\376\377\373\373\376\377\373\373\376\377\373\373\375\377\373\373"
+  "\376\377\373\373\376\377\373\373\376\377\373\373\375\377\373\373\376\377"
+  "\373\373\376\377\373\373\376\377\373\373\376\377\373\373\376\377\373\373"
+  "\376\377\373\373\375\377\373\373\375\377\373\373\375\377\373\373\376\377"
+  "\373\374\376\377\377\377\377\377\201\201\201\377\000\000\000\377\000\000\000\345\000\000"
+  "\000\345\000\000\000\377\177\201\201\377\377\377\377\377\371\373\376\377\377\377"
+  "\377\377\233\233\235\377\"\"\"\377\361\363\366\377\375\377\377\377\371\373"
+  "\376\377\371\373\376\377\371\373\376\377\367\372\376\377\367\372\376\377"
+  "\371\371\376\377\371\371\376\377\371\373\376\377\371\373\376\377\371\373"
+  "\376\377\371\373\376\377\367\372\376\377\367\372\376\377\371\373\376\377"
+  "\367\372\376\377\367\372\376\377\371\373\376\377\367\372\376\377\371\373"
+  "\376\377\371\373\376\377\367\372\376\377\367\372\376\377\371\373\376\377"
+  "\377\377\377\377\177\201\201\377\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377"
+  "\177\177\201\377\377\377\377\377\365\370\377\377\377\377\377\377\234\234"
+  "\234\377\"\"\"\377\356\361\365\377\372\375\377\377\365\370\375\377\365\370"
+  "\375\377\365\370\375\377\365\370\375\377\365\370\375\377\365\370\375\377"
+  "\365\370\375\377\365\370\375\377\365\370\375\377\365\370\375\377\365\370"
+  "\375\377\365\370\375\377\365\370\375\377\365\370\375\377\365\370\375\377"
+  "\365\370\375\377\365\370\375\377\365\370\375\377\365\370\375\377\365\370"
+  "\375\377\365\370\375\377\365\370\375\377\366\371\376\377\377\377\377\377"
+  "\177\177\201\377\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377}\200\202\377\377"
+  "\377\377\377\363\366\375\377\377\377\377\377\232\234\234\377\"\"\"\377\355"
+  "\357\364\377\370\372\377\377\363\366\375\377\363\366\375\377\363\366\375"
+  "\377\363\366\375\377\363\366\375\377\363\366\375\377\363\366\375\377\363"
+  "\366\375\377\363\366\375\377\363\366\375\377\363\366\375\377\363\366\375"
+  "\377\363\366\375\377\363\366\375\377\363\366\375\377\363\366\375\377\363"
+  "\366\375\377\363\366\375\377\363\366\375\377\363\366\375\377\363\366\375"
+  "\377\363\366\375\377\364\367\376\377\377\377\377\377~\177\201\377\000\000\000\377"
+  "\000\000\000\345\000\000\000\345\000\000\000\377|~\201\377\377\377\377\377\357\362\374\377"
+  "\377\377\377\377\231\232\234\377\"\"\"\377\352\355\364\377\364\370\377\377"
+  "\357\362\374\377\357\364\374\377\357\364\374\377\357\364\374\377\357\362"
+  "\374\377\357\364\374\377\357\364\374\377\357\364\374\377\357\364\374\377"
+  "\357\362\374\377\357\364\374\377\357\364\374\377\357\364\374\377\357\364"
+  "\374\377\357\364\374\377\357\364\374\377\357\364\374\377\357\364\374\377"
+  "\357\364\374\377\357\364\374\377\357\362\374\377\357\364\374\377\360\363"
+  "\375\377\377\377\377\377|~\201\377\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377"
+  "z|\201\377\377\377\377\377\353\360\374\377\375\377\377\377\230\232\235\377"
+  "\"\"\"\377\347\352\364\377\360\364\377\377\353\360\374\377\355\360\374\377"
+  "\355\360\374\377\355\360\374\377\353\360\374\377\355\360\374\377\353\360"
+  "\374\377\353\360\374\377\353\360\374\377\355\360\374\377\355\360\374\377"
+  "\355\360\374\377\355\362\374\377\355\360\374\377\353\360\374\377\353\360"
+  "\374\377\355\360\374\377\353\360\374\377\355\360\374\377\355\360\374\377"
+  "\355\360\374\377\353\360\374\377\355\362\374\377\377\377\377\377z|\201\377"
+  "\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377y{\201\377\377\377\377\377\351\356"
+  "\372\377\373\377\377\377\220\223\230\377\026\026\026\377\344\351\363\377\353"
+  "\362\377\377\350\357\374\377\350\357\372\377\350\357\372\377\350\357\374"
+  "\377\350\357\374\377\350\357\372\377\350\357\374\377\350\357\372\377\350"
+  "\357\372\377\350\357\374\377\350\357\374\377\350\357\374\377\350\357\372"
+  "\377\350\357\372\377\350\357\372\377\350\357\374\377\350\357\374\377\350"
+  "\357\372\377\350\357\372\377\350\357\372\377\350\357\372\377\350\357\372"
+  "\377\351\360\373\377\377\377\377\377y{\201\377\000\000\000\377\000\000\000\345\000\000\000"
+  "\345\000\000\000\377xz\200\377\375\377\377\377\346\354\373\377\352\362\376\377"
+  "\304\313\325\377\226\233\243\377\343\353\370\377\345\355\374\377\345\355"
+  "\372\377\345\355\372\377\345\353\372\377\345\353\372\377\345\355\372\377"
+  "\345\355\372\377\345\353\372\377\345\353\372\377\345\353\372\377\345\355"
+  "\372\377\345\355\372\377\345\353\372\377\345\353\372\377\345\353\372\377"
+  "\345\353\372\377\345\353\372\377\345\353\372\377\345\353\372\377\345\353"
+  "\372\377\345\353\372\377\345\353\372\377\345\353\372\377\344\354\373\377"
+  "\375\377\377\377xz\200\377\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377ux\201"
+  "\377\373\377\377\377\342\352\373\377\340\350\371\377\350\360\377\377\362"
+  "\370\377\377\341\351\373\377\341\351\372\377\341\351\372\377\341\351\372"
+  "\377\341\351\372\377\341\351\372\377\341\351\372\377\341\351\372\377\341"
+  "\351\372\377\341\351\372\377\341\351\372\377\341\351\372\377\341\351\372"
+  "\377\341\351\372\377\341\351\372\377\341\351\372\377\341\351\372\377\341"
+  "\351\372\377\341\351\372\377\341\351\372\377\341\351\372\377\341\351\372"
+  "\377\341\351\372\377\341\351\372\377\342\352\373\377\373\377\377\377ux\201"
+  "\377\000\000\000\377\000\000\000\345\000\000\000\345\000\000\000\377ty\200\377\367\375\377\377\336"
+  "\346\372\377\334\346\372\377\334\346\372\377\334\346\370\377\335\345\371"
+  "\377\335\345\371\377\335\345\371\377\335\345\371\377\335\345\371\377\335"
+  "\345\371\377\335\345\371\377\335\345\371\377\335\345\371\377\335\345\371"
+  "\377\335\345\371\377\335\345\371\377\335\345\371\377\334\346\372\377\335"
+  "\345\371\377\335\345\371\377\335\345\371\377\335\345\371\377\335\345\371"
+  "\377\335\345\371\377\335\345\371\377\334\346\372\377\335\345\371\377\335"
+  "\345\371\377\335\347\373\377\367\375\377\377ty\200\377\000\000\000\377\000\000\000\345"
+  "\000\000\000\345\000\000\000\377sx\200\377\366\373\377\377\334\344\372\377\331\344\370"
+  "\377\330\343\371\377\331\344\370\377\330\343\371\377\330\343\371\377\331"
+  "\344\370\377\331\344\370\377\331\344\370\377\331\344\370\377\330\343\371"
+  "\377\331\344\370\377\331\344\370\377\331\344\370\377\331\344\370\377\331"
+  "\344\370\377\330\343\371\377\330\343\371\377\330\343\371\377\331\344\370"
+  "\377\331\344\370\377\331\344\370\377\330\343\371\377\330\342\371\377\331"
+  "\344\370\377\331\343\370\377\331\344\370\377\331\343\370\377\334\344\370"
+  "\377\366\373\377\377sx\200\377\000\000\000\377\000\000\000\345\000\000\000\346\000\000\000\377QV"
+  "[\377\365\373\377\377\334\346\372\377\325\341\370\377\325\337\370\377\325"
+  "\341\370\377\325\341\370\377\325\341\370\377\325\341\370\377\325\341\370"
+  "\377\325\341\370\377\325\341\370\377\325\341\370\377\325\341\370\377\325"
+  "\341\370\377\325\341\370\377\325\341\370\377\325\341\370\377\325\341\370"
+  "\377\325\341\370\377\325\341\370\377\325\341\370\377\325\341\370\377\325"
+  "\341\370\377\325\341\370\377\325\341\370\377\325\341\370\377\325\341\370"
+  "\377\324\341\370\377\324\341\370\377\334\346\372\377\365\373\377\377PU\\"
+  "\377\000\000\000\377\000\000\000\346\000\000\000\314\000\000\000\377\012\012\014\377\254\264\301\377"
+  "\362\370\377\377\325\341\370\377\321\335\367\377\320\335\370\377\320\335"
+  "\370\377\320\335\370\377\320\335\370\377\320\335\370\377\320\335\370\377"
+  "\320\335\370\377\320\335\370\377\321\335\367\377\320\335\370\377\320\335"
+  "\370\377\320\335\370\377\320\335\370\377\320\335\370\377\321\335\367\377"
+  "\321\335\367\377\320\335\370\377\320\335\370\377\320\335\370\377\320\335"
+  "\370\377\320\335\370\377\321\335\367\377\320\335\370\377\321\335\367\377"
+  "\326\340\371\377\362\370\377\377\254\264\301\377\012\012\014\377\000\000\000\377\000"
+  "\000\000\314\000\000\000d\000\000\000\377\000\000\000\377\024\025\027\377\262\274\314\377\355\365"
+  "\377\377\323\336\367\377\315\334\366\377\315\334\366\377\314\333\367\377"
+  "\315\334\366\377\314\333\367\377\314\333\367\377\314\333\367\377\314\333"
+  "\367\377\316\333\367\377\314\333\367\377\314\333\367\377\315\334\366\377"
+  "\315\334\366\377\315\334\366\377\316\333\367\377\316\333\367\377\314\333"
+  "\367\377\314\333\367\377\315\334\366\377\315\334\366\377\314\333\367\377"
+  "\314\333\367\377\314\333\367\377\323\340\367\377\356\365\377\377\262\274"
+  "\314\377\024\025\027\377\000\000\000\377\000\000\000\377\000\000\000d\000\000\000\002\000\000\000\220\000\000\000"
+  "\377\000\000\000\377\025\027\032\377\261\273\315\377\352\362\377\377\317\333\367\377"
+  "\311\326\366\377\311\330\366\377\311\330\366\377\311\330\366\377\311\330"
+  "\366\377\311\330\366\377\311\330\366\377\311\330\366\377\311\330\366\377"
+  "\311\330\366\377\311\330\366\377\311\330\366\377\311\330\366\377\311\330"
+  "\366\377\311\330\366\377\311\330\366\377\311\330\366\377\311\330\366\377"
+  "\311\330\366\377\311\330\366\377\311\330\366\377\317\333\367\377\352\362"
+  "\377\377\261\271\315\377\025\027\032\377\000\000\000\377\000\000\000\377\000\000\000\220\000\000\000"
+  "\002\000\000\000\000\000\000\000\002\000\000\000\224\000\000\000\377\000\000\000\377\025\030\032\377\257\272\320"
+  "\377\346\356\377\377\313\330\366\377\305\325\365\377\305\324\365\377\305"
+  "\324\365\377\305\325\365\377\305\324\365\377\305\324\365\377\305\325\365"
+  "\377\305\325\365\377\305\324\365\377\305\325\365\377\305\325\365\377\305"
+  "\324\365\377\305\325\365\377\305\325\365\377\305\325\365\377\305\325\365"
+  "\377\305\325\365\377\305\324\365\377\305\324\365\377\313\332\366\377\346"
+  "\356\377\377\257\272\320\377\025\027\032\377\000\000\000\377\000\000\000\377\000\000\000\224\000"
+  "\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\235\000\000\000\377\000\000\000\377\031\032"
+  "\034\377\267\304\335\377\327\345\377\377\307\326\365\377\302\322\365\377\302"
+  "\322\365\377\302\322\365\377\302\322\365\377\302\322\365\377\302\322\365"
+  "\377\302\322\365\377\302\322\365\377\302\322\365\377\302\322\365\377\302"
+  "\322\365\377\302\322\365\377\302\322\365\377\302\322\365\377\302\322\365"
+  "\377\302\322\365\377\302\322\365\377\305\326\367\377\327\343\377\377\267"
+  "\304\335\377\031\032\034\377\000\000\000\377\000\000\000\377\000\000\000\235\000\000\000\004\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000\000\000\241\000\000\000\377\000\000\000\377GJV\377"
+  "\327\345\377\377\311\330\367\377\275\317\365\377\276\317\365\377\276\320"
+  "\365\377\276\320\365\377\276\320\365\377\276\320\365\377\276\320\365\377"
+  "\276\320\365\377\276\320\365\377\276\320\365\377\276\320\365\377\276\320"
+  "\365\377\276\320\365\377\276\320\365\377\276\320\365\377\276\320\365\377"
+  "\275\317\365\377\311\330\367\377\326\345\377\377GJV\377\000\000\000\377\000\000\000\377"
+  "\000\000\000\241\000\000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\011\000\000\000\313\000\000\000\377\015\015\017\377\270\305\341\377\312\334\374"
+  "\377\271\315\364\377\272\314\364\377\272\316\364\377\272\316\364\377\272"
+  "\316\364\377\272\316\364\377\272\316\364\377\272\316\364\377\272\316\364"
+  "\377\272\316\364\377\272\316\364\377\272\316\364\377\272\316\364\377\272"
+  "\316\364\377\272\316\364\377\272\316\364\377\271\316\364\377\312\334\374"
+  "\377\270\305\341\377\015\015\017\377\000\000\000\377\000\000\000\313\000\000\000\011\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000s\000\000"
+  "\000\377\004\004\006\377\254\270\324\377\311\332\376\377\267\313\364\377\270\312"
+  "\363\377\270\314\363\377\270\314\363\377\270\314\363\377\270\314\363\377"
+  "\270\312\363\377\270\312\363\377\270\314\363\377\270\314\363\377\270\314"
+  "\363\377\270\314\363\377\270\312\363\377\270\314\363\377\270\314\363\377"
+  "\270\314\363\377\267\313\364\377\311\332\376\377\254\270\324\377\004\004\006\377"
+  "\000\000\000\377\000\000\000s\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000a\000\000\000\377\005\005\007\377\253\270\324\377\306\332"
+  "\376\377\263\310\363\377\264\311\363\377\264\311\363\377\264\311\363\377"
+  "\264\311\363\377\264\311\363\377\264\311\364\377\264\311\364\377\264\311"
+  "\363\377\264\311\363\377\264\311\363\377\264\311\363\377\264\311\363\377"
+  "\264\311\363\377\264\311\364\377\264\311\364\377\263\310\363\377\306\332"
+  "\376\377\253\270\324\377\005\005\007\377\000\000\000\377\000\000\000a\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000d\000\000\000\377"
+  "\005\005\007\377\255\274\332\377\306\330\376\377\261\306\363\377\262\307\362\377"
+  "\262\307\362\377\262\307\362\377\262\307\362\377\262\307\362\377\262\307"
+  "\362\377\262\307\362\377\262\307\362\377\262\307\362\377\262\307\362\377"
+  "\262\307\362\377\262\307\362\377\262\307\362\377\262\307\362\377\262\307"
+  "\362\377\261\306\363\377\306\330\376\377\255\274\332\377\005\005\007\377\000\000\000"
+  "\377\000\000\000d\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000W\000\000\000\377\002\002\002\377\205\220\251\377\341\354\377"
+  "\377\313\333\377\377\311\333\377\377\311\333\377\377\311\333\377\377\311"
+  "\333\377\377\311\333\377\377\311\333\377\377\311\333\377\377\311\333\377"
+  "\377\311\333\377\377\310\332\377\377\311\333\377\377\311\333\377\377\311"
+  "\333\377\377\310\332\377\377\310\332\377\377\313\333\377\377\340\354\377"
+  "\377\205\220\251\377\002\002\002\377\000\000\000\377\000\000\000W\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\034\000\000\000\354"
+  "\000\000\000\377\020\022\025\377RZi\377]ev\377Zdt\377Zdt\377[ct\377[ct\377Zdt\377"
+  "Zdt\377Zdt\377[ct\377[ct\377Zds\377[ct\377[ct\377Zdt\377[cr\377Zds\377]e"
+  "v\377RZi\377\020\022\025\377\000\000\000\377\000\000\000\354\000\000\000\034\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000f\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377"
+  "\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000"
+  "\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000\000\377\000\000"
+  "\000\377\000\000\000\377\000\000\000f\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000R\000\000\000\275\000"
+  "\000\000\344\000\000\000\345\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000"
+  "\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000\344\000\000\000"
+  "\344\000\000\000\344\000\000\000\344\000\000\000\345\000\000\000\344\000\000\000\275\000\000\000R\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
+};
+
+static const OGC_Cursor OGC_cursor_arrow = {
+  24, 31, 0, 0, 4,
+  "\002\002\002\337\000\000\000\224\000\000\000\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\000\000\000\377"
+  "\005\005\005\321\000\000\000$\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377ddd\377\037\037\037\373\003\003\003\364"
+  "\000\000\000V\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\361\361\361\377VVV\376\000\000\000\377"
+  "\002\002\002\243\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377\377\377\241"
+  "\241\241\377\007\007\007\375\005\005\005\322\000\000\000%\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\315\315\315\377!!!\373\003\003\003\365\000\000\000Y\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\362\362\362\377"
+  "WWW\376\000\000\000\377\002\002\002\243\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\377\225\225\225\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\241\241\241\377\007\007\007\375\005"
+  "\005\005\331\000\000\000+\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\316\316\316\377!!!\373\003\003\003\365\000\000\000Z"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\362\362\362\377XXX\376\000\000\000\377\002\002\002\243\000\000\000"
+  "\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\375\375\377\377\373\374\376\377\235\236\240\377\007\007\007\374\005"
+  "\005\005\331\000\000\000+\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\375\375\377\377"
+  "\373\374\376\377\371\373\376\377\367\371\376\377\366\370\375\377\305\310"
+  "\314\377\037!\"\373\003\003\003\366\000\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\375\375\377\377\373\374\376\377\371"
+  "\373\376\377\367\371\376\377\366\370\375\377\364\367\375\377\362\365\375"
+  "\377\360\364\374\377\342\347\357\377QSW\376\000\000\000\377\002\002\002\243\000\000\000\012"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\225\225\225\377\377\377"
+  "\377\377\377\377\377\377\375\375\377\377\373\374\376\377\371\373\376\377"
+  "\367\371\376\377\366\370\375\377\364\367\375\377\362\365\375\377\360\364"
+  "\374\377\356\363\374\377\354\362\374\377\353\360\374\377\351\357\373\377"
+  "\222\226\236\377\007\007\007\374\004\005\005\331\000\000\000+\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\377\225\225\225\377\375\375\377\377\373\374\376\377\371\373\376"
+  "\377\367\371\376\377\366\370\375\377\364\367\375\377\362\365\375\377\360"
+  "\364\374\377\356\363\374\377\354\362\374\377\353\360\374\377\351\357\373"
+  "\377\347\356\373\377\345\354\373\377\343\353\372\377\275\303\321\377#%'\373"
+  "\003\003\003\366\000\000\000[\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\223\223\224\377\371\373"
+  "\376\377\367\371\376\377\366\370\375\377\364\367\375\377\362\365\375\377"
+  "\360\364\374\377\356\363\374\377\354\362\374\377\353\360\374\377\351\357"
+  "\373\377\347\356\373\377\345\354\373\377\343\353\372\377\342\352\372\377"
+  "\340\350\372\377\336\347\371\377\321\332\354\377LOW\376\000\000\000\377\002\002\002\243"
+  "\000\000\000\012\000\000\000\000\000\000\000\377\220\221\224\377\366\370\375\377\364\367\375\377"
+  "\362\365\375\377\360\364\374\377\356\363\374\377\354\362\374\377\353\360"
+  "\374\377\351\357\373\377\347\356\373\377\345\354\373\377\343\353\372\377"
+  "\342\352\372\377\340\350\372\377\336\347\371\377\334\346\371\377\332\344"
+  "\371\377\330\343\370\377\327\342\370\377\206\215\235\377\006\006\007\374\004\004\005"
+  "\332\000\000\000,\000\000\000\377\217\220\224\377\362\365\375\377\360\364\374\377\356"
+  "\363\374\377\354\361\374\377\353\360\374\377\351\357\373\377\347\356\373"
+  "\377\345\354\373\377\343\353\372\377\342\352\372\377\340\350\372\377\336"
+  "\347\371\377\334\346\371\377\332\344\371\377\330\343\370\377\327\342\370"
+  "\377\325\340\370\377\323\337\370\377\321\336\367\377pw\206\377\000\000\000\377"
+  "\001\001\001\347\000\000\000\377\214\217\223\377\356\363\374\377\354\361\374\377\353"
+  "\360\374\377\351\357\373\377\347\356\373\377\345\354\373\377\343\353\372"
+  "\377\342\352\372\377\340\350\372\377\336\347\371\377\334\346\371\377\332"
+  "\344\371\377\330\343\370\377\327\342\370\377\325\340\370\377\323\337\370"
+  "\377\321\336\367\377\225\236\261\377,/\065\374\000\000\000\377\004\004\005\316\000\000\000F"
+  "\000\000\000\377\212\215\223\377\353\360\374\377\351\357\373\377\347\356\373\377"
+  "\345\354\373\377\343\353\372\377\342\352\372\377\340\350\372\377\336\347"
+  "\371\377\334\346\371\377\332\344\371\377\330\343\370\377\327\342\370\377"
+  "\325\340\370\377\323\337\370\377\321\336\367\377\236\250\275\377\062\065<\374"
+  "\000\000\000\377\002\004\004\323\000\000\000U\000\000\000\001\000\000\000\000\000\000\000\377\210\214\223\377\347"
+  "\356\373\377\345\354\373\377\343\353\372\377\342\352\372\377\340\350\372"
+  "\377\336\347\371\377\334\346\371\377\332\344\371\377\330\343\370\377\327"
+  "\342\370\377\325\340\370\377\323\337\370\377\321\336\367\377\230\241\265"
+  "\377,/\064\374\000\000\000\377\002\004\004\323\000\000\000U\000\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\377\206\212\223\377\343\353\372\377\341\352\372\377\340\350\372\377"
+  "\336\347\371\377\334\346\371\377\332\344\371\377\330\343\370\377\327\342"
+  "\370\377\325\340\370\377\323\337\370\377\321\336\367\377\317\334\367\377"
+  "DHQ\374\000\000\000\377\004\004\004\314\000\000\000J\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\377\203\211\222\377\340\350\372\377\336\347\371\377\334"
+  "\346\371\377\332\344\371\377\330\343\370\377\327\342\370\377\325\340\370"
+  "\377\323\337\370\377\321\336\367\377\317\334\367\377\315\333\367\377\314"
+  "\332\366\377JOZ\376\002\002\003\362\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\202\207\221\377\334\346\371\377\332\344"
+  "\371\377\330\343\370\377\327\342\370\377\325\340\370\377\323\337\370\377"
+  "\321\336\367\377\316\333\366\377\315\333\367\377\314\332\366\377\312\330"
+  "\366\377\310\327\366\377\250\266\320\377\002\002\002\376\000\000\000r\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\177\205\221\377\330\343"
+  "\370\377\327\342\370\377\325\340\370\377\323\337\370\377\321\336\367\377"
+  "\223\234\257\377),\062\374\036\040$\374\306\324\361\377\310\327\366\377\306"
+  "\326\365\377\304\324\365\377\303\323\365\377FLX\376\003\003\004\354\000\000\000\012\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377~\204\221\377\325"
+  "\340\370\377\323\337\370\377\321\336\367\377\222\233\256\377)-\063\374\000\000"
+  "\000\377\002\004\004\321\000\000\000\376y\203\226\377\304\324\365\377\303\323\365\377\301"
+  "\322\364\377\277\320\364\377\242\261\321\377\001\002\002\376\000\000\000s\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377{\202\221\377\321\336\367\377"
+  "\222\233\256\377),\062\374\000\000\000\377\004\004\005\313\000\000\000I\000\000\000\000\001\001\003\263\026"
+  "\030\034\373\275\316\357\377\277\320\364\377\275\317\364\377\273\316\364\377"
+  "\271\314\363\377CJY\376\003\003\004\354\000\000\000\012\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\377INW\377)+\061\373\000\000\000\377\004\004\004\312\000\000\000H\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\062\000\000\000\376t\177\225\377\273\316\364\377\271\314\363"
+  "\377\270\313\363\377\212\232\271\377(,\066\375\000\000\000\377\000\000\000F\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\377\000\000\000\377\004\004\004\311\000\000\000H\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\003\003\262\025\027\034\373\264\307"
+  "\356\377\212\232\271\377.\063>\374\000\000\000\377\004\004\005\330\000\000\000V\000\000\000\001\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000t\000\000\000G\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\062\000\000\000\376\032\035$\375"
+  "\000\000\000\377\004\004\005\327\000\000\000V\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\003\003\247\004\004\005\325\000\000\000U\000\000\000\002\000\000"
+  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
+};
+
diff --git a/src/video/ogc/SDL_ogcevents.c b/src/video/ogc/SDL_ogcevents.c
new file mode 100644
index 0000000000..4e4440d12d
--- /dev/null
+++ b/src/video/ogc/SDL_ogcevents.c
@@ -0,0 +1,113 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "SDL.h"
+
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_ogcevents_c.h"
+#include "SDL_ogckeyboard.h"
+#include "SDL_ogcmouse.h"
+#include "SDL_ogcvideo.h"
+
+#include <ogc/system.h>
+#include <wiiuse/wpad.h>
+
+/* These variables can be set from the handlers registered in SDL_main() */
+bool OGC_PowerOffRequested = false;
+bool OGC_ResetRequested = false;
+
+#ifdef __wii__
+#define MAX_WII_MOUSE_BUTTONS 2
+static const struct {
+    int wii;
+    int mouse;
+} s_mouse_button_map[MAX_WII_MOUSE_BUTTONS] = {
+    { WPAD_BUTTON_B, SDL_BUTTON_LEFT },
+    { WPAD_BUTTON_A, SDL_BUTTON_RIGHT },
+};
+
+static void pump_ir_events(_THIS)
+{
+    int screen_w, screen_h;
+
+    if (!_this->windows) return;
+
+    if (!SDL_WasInit(SDL_INIT_JOYSTICK)) {
+        /* Get events from WPAD; we don't need to do this if the joystick
+         * system was initialized, because in that case this operation is done
+         * there at every event loop iteration. */
+        WPAD_ReadPending(WPAD_CHAN_ALL, NULL);
+    }
+
+    screen_w = _this->displays[0].current_mode.w;
+    screen_h = _this->displays[0].current_mode.h;
+
+    for (int i = 0; i < 4; i++) {
+        WPADData *data = WPAD_Data(i);
+
+        if (!data->ir.valid) continue;
+
+        SDL_SendMouseMotion(_this->windows, i, 0,
+                            data->ir.x * screen_w / 640,
+                            data->ir.y * screen_h / 480);
+
+        for (int b = 0; b < MAX_WII_MOUSE_BUTTONS; b++) {
+            if (data->btns_d & s_mouse_button_map[b].wii) {
+                SDL_SendMouseButton(_this->windows, i,
+                                    SDL_PRESSED, s_mouse_button_map[b].mouse);
+            }
+            if (data->btns_u & s_mouse_button_map[b].wii) {
+                SDL_SendMouseButton(_this->windows, i,
+                                    SDL_RELEASED, s_mouse_button_map[b].mouse);
+            }
+        }
+    }
+
+    if (OGC_prep_draw_cursor(_this)) {
+        OGC_video_flip(_this, false);
+    }
+}
+#endif
+
+void OGC_PumpEvents(_THIS)
+{
+    if (OGC_ResetRequested || OGC_PowerOffRequested) {
+        SDL_Event ev;
+        ev.type = SDL_QUIT;
+        SDL_PushEvent(&ev);
+        if (OGC_PowerOffRequested) {
+            SYS_ResetSystem(SYS_POWEROFF, 0, 0);
+        }
+    }
+
+#ifdef __wii__
+    pump_ir_events(_this);
+    OGC_PumpKeyboardEvents(_this);
+#endif
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcevents_c.h b/src/video/ogc/SDL_ogcevents_c.h
new file mode 100644
index 0000000000..6bc6b91e68
--- /dev/null
+++ b/src/video/ogc/SDL_ogcevents_c.h
@@ -0,0 +1,36 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_ogcevents_c_h_
+#define SDL_ogcevents_c_h_
+
+#include "../../SDL_internal.h"
+
+#include "SDL_ogcvideo.h"
+
+extern bool OGC_ResetRequested;
+extern bool OGC_PowerOffRequested;
+
+extern void OGC_PumpEvents(_THIS);
+
+#endif /* SDL_ogcevents_c_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcframebuffer.c b/src/video/ogc/SDL_ogcframebuffer.c
new file mode 100644
index 0000000000..21fb7ee0cb
--- /dev/null
+++ b/src/video/ogc/SDL_ogcframebuffer.c
@@ -0,0 +1,129 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "../SDL_sysvideo.h"
+#include "SDL_ogcframebuffer_c.h"
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcpixels.h"
+#include "SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/system.h>
+#include <ogc/video.h>
+
+static void draw_screen_rect(SDL_Window *window)
+{
+    s16 z = 0;
+
+    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+    GX_Position3s16(0, 0, z);
+    GX_TexCoord1x8(0);
+    GX_Position3s16(window->w, 0, z);
+    GX_TexCoord1x8(1);
+    GX_Position3s16(window->w, window->h, z);
+    GX_TexCoord1x8(2);
+    GX_Position3s16(0, window->h, z);
+    GX_TexCoord1x8(3);
+    GX_End();
+}
+
+static void free_window_data(SDL_Window *window)
+{
+    SDL_WindowData *windowdata = (SDL_WindowData *)window->driverdata;
+    if (windowdata) {
+        if (windowdata->pixels) {
+            SDL_free(windowdata->pixels);
+        }
+        if (windowdata->texels) {
+            free(windowdata->texels);
+        }
+        SDL_free(windowdata);
+        window->driverdata = NULL;
+    }
+}
+
+int SDL_OGC_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void **pixels, int *pitch)
+{
+    SDL_WindowData *windowdata;
+    int bytes_per_pixel = 4;
+    size_t texture_size;
+    int w, h;
+
+    free_window_data(window);
+    windowdata = (SDL_WindowData *)SDL_calloc(1, sizeof(SDL_WindowData));
+    if (!windowdata) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+
+    w = window->w;
+    h = window->h;
+    windowdata->pixels = SDL_malloc(w * h * bytes_per_pixel);
+    texture_size = GX_GetTexBufferSize(w, h, GX_TF_RGBA8, GX_FALSE, 0);
+    windowdata->texels = memalign(32, texture_size);
+    windowdata->surface_format = SDL_PIXELFORMAT_RGBA8888;
+    window->driverdata = windowdata;
+
+    *pitch = w * bytes_per_pixel;
+    *format = windowdata->surface_format;
+    *pixels = windowdata->pixels;
+    return 0;
+}
+
+int SDL_OGC_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rects, int numrects)
+{
+    SDL_WindowData *windowdata = (SDL_WindowData *)window->driverdata;
+    u32 texture_size;
+    u8 gx_format;
+
+    gx_format = OGC_texture_format_from_SDL(windowdata->surface_format);
+    for (int i = 0; i < numrects; i++) {
+        OGC_pixels_to_texture(windowdata->pixels, windowdata->surface_format, &rects[i],
+                              window->surface->pitch, windowdata->texels, window->w);
+    }
+    texture_size = GX_GetTexBufferSize(window->w, window->h, gx_format,
+                                       GX_FALSE, 0);
+    DCStoreRange(windowdata->texels, texture_size);
+    GX_InvalidateTexAll();
+    OGC_load_texture(windowdata->texels, window->w, window->h, gx_format,
+                     SDL_ScaleModeNearest);
+    draw_screen_rect(window);
+    GX_DrawDone();
+
+    OGC_video_flip(_this, true);
+
+    return 0;
+}
+
+void SDL_OGC_DestroyWindowFramebuffer(_THIS, SDL_Window *window)
+{
+    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "Destroying window");
+    free_window_data(window);
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcframebuffer_c.h b/src/video/ogc/SDL_ogcframebuffer_c.h
new file mode 100644
index 0000000000..af58bbcc14
--- /dev/null
+++ b/src/video/ogc/SDL_ogcframebuffer_c.h
@@ -0,0 +1,33 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_ogcframebuffer_c_h_
+#define SDL_ogcframebuffer_c_h_
+
+#include "../../SDL_internal.h"
+
+extern int SDL_OGC_CreateWindowFramebuffer(_THIS, SDL_Window *window, Uint32 *format, void **pixels, int *pitch);
+extern int SDL_OGC_UpdateWindowFramebuffer(_THIS, SDL_Window *window, const SDL_Rect *rects, int numrects);
+extern void SDL_OGC_DestroyWindowFramebuffer(_THIS, SDL_Window *window);
+
+#endif /* SDL_ogcframebuffer_c_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcgl.c b/src/video/ogc/SDL_ogcgl.c
new file mode 100644
index 0000000000..fd26d690e9
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgl.c
@@ -0,0 +1,134 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if defined(SDL_VIDEO_DRIVER_OGC) && defined(SDL_VIDEO_OPENGL)
+
+#include "../SDL_sysvideo.h"
+
+#include "SDL_ogcgl.h"
+#include "SDL_ogcvideo.h"
+
+#include <opengx.h>
+
+typedef struct
+{
+    SDL_Window *window;
+    int swap_interval;
+} OGC_GL_Context;
+
+/* Weak symbols for the opengx functions used by SDL, so that the client does
+ * not need to link to opengx, unless it actually uses OpenGL. */
+void __attribute__((weak)) ogx_initialize(void)
+{
+    SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                "%s() called but opengx not used in build!", __func__);
+}
+
+void __attribute__((weak)) ogx_stencil_create(OgxStencilFlags)
+{
+    SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                "%s() called but opengx not used in build!", __func__);
+}
+
+void __attribute__((weak)) *ogx_get_proc_address(const char *)
+{
+    SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                "%s() called but opengx not used in build!", __func__);
+    return NULL;
+}
+
+int __attribute__((weak)) ogx_prepare_swap_buffers()
+{
+    SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                "%s() called but opengx not used in build!", __func__);
+    return 0;
+}
+
+int SDL_OGC_GL_LoadLibrary(_THIS, const char *path)
+{
+    return 0;
+}
+
+void *SDL_OGC_GL_GetProcAddress(_THIS, const char *proc)
+{
+    return ogx_get_proc_address(proc);
+}
+
+void SDL_OGC_GL_UnloadLibrary(_THIS)
+{
+    // nothing to do
+}
+
+SDL_GLContext SDL_OGC_GL_CreateContext(_THIS, SDL_Window * window)
+{
+    OGC_GL_Context *context = SDL_calloc(1, sizeof(*context));
+    context->window = window;
+    context->swap_interval = 1;
+    ogx_initialize();
+    if (_this->gl_config.stencil_size > 0) {
+        OgxStencilFlags flags = 0; /* Don't care if Z gets dirty on discarded fragments */
+        if (_this->gl_config.stencil_size > 4) flags |= OGX_STENCIL_8BIT;
+        ogx_stencil_create(flags);
+    }
+    return context;
+}
+
+int SDL_OGC_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+{
+    return 0;
+}
+
+int SDL_OGC_GL_SetSwapInterval(_THIS, int interval)
+{
+    OGC_GL_Context *context = _this->current_glctx;
+    context->swap_interval = interval;
+    return 0;
+}
+
+int SDL_OGC_GL_GetSwapInterval(_THIS)
+{
+    OGC_GL_Context *context = _this->current_glctx;
+    return context->swap_interval;
+}
+
+int SDL_OGC_GL_SwapWindow(_THIS, SDL_Window * window)
+{
+    OGC_GL_Context *context = _this->current_glctx;
+
+    bool vsync = context->swap_interval == 1;
+    OGC_video_flip(_this, vsync);
+    return 0;
+}
+
+void SDL_OGC_GL_DeleteContext(_THIS, SDL_GLContext context)
+{
+    SDL_free(context);
+}
+
+void SDL_OGC_GL_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor)
+{
+    *mask = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY;
+    *major = 1;
+    *minor = 1;
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
diff --git a/src/video/ogc/SDL_ogcgl.h b/src/video/ogc/SDL_ogcgl.h
new file mode 100644
index 0000000000..dcaee41880
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgl.h
@@ -0,0 +1,44 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_OGC_gl_h_
+#define SDL_OGC_gl_h_
+
+#ifdef SDL_VIDEO_OPENGL
+
+#include "../SDL_sysvideo.h"
+
+int SDL_OGC_GL_LoadLibrary(_THIS, const char *path);
+void *SDL_OGC_GL_GetProcAddress(_THIS, const char *proc);
+void SDL_OGC_GL_UnloadLibrary(_THIS);
+SDL_GLContext SDL_OGC_GL_CreateContext(_THIS, SDL_Window * window);
+int SDL_OGC_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context);
+int SDL_OGC_GL_SetSwapInterval(_THIS, int interval);
+int SDL_OGC_GL_GetSwapInterval(_THIS);
+int SDL_OGC_GL_SwapWindow(_THIS, SDL_Window * window);
+void SDL_OGC_GL_DeleteContext(_THIS, SDL_GLContext context);
+void SDL_OGC_GL_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor);
+
+#endif /* SDL_VIDEO_OPENGL */
+
+#endif /* SDL_OGC_gl_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcgxcommon.c b/src/video/ogc/SDL_ogcgxcommon.c
new file mode 100644
index 0000000000..ed7e096369
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgxcommon.c
@@ -0,0 +1,129 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcpixels.h"
+
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/video.h>
+
+static const f32 tex_pos[] __attribute__((aligned(32))) = {
+    0.0,
+    0.0,
+    1.0,
+    0.0,
+    1.0,
+    1.0,
+    0.0,
+    1.0,
+};
+
+void OGC_set_viewport(int x, int y, int w, int h)
+{
+    Mtx44 proj;
+
+    GX_SetViewport(x, y, w, h, 0, 1);
+    GX_SetScissor(x, y, w, h);
+
+    // matrix, t, b, l, r, n, f
+    guOrtho(proj, 0, h, 0, w, 0, 1);
+    GX_LoadProjectionMtx(proj, GX_ORTHOGRAPHIC);
+}
+
+void OGC_draw_init(int w, int h)
+{
+    SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "OGC_draw_init called with %d, %d", w, h);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxDesc(GX_VA_TEX0, GX_INDEX8);
+
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+    GX_SetArray(GX_VA_TEX0, (void *)tex_pos, 2 * sizeof(f32));
+    GX_SetNumTexGens(1);
+    GX_SetNumChans(1);
+    GX_SetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_VTX, GX_SRC_VTX, 0,
+                   GX_DF_NONE, GX_AF_NONE);
+
+    GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+    GX_SetTevOp(GX_TEVSTAGE0, GX_REPLACE);
+    GX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);
+
+    OGC_set_viewport(0, 0, w, h);
+
+    GX_InvVtxCache(); // update vertex cache
+}
+
+void OGC_load_texture(void *texels, int w, int h, u8 format,
+                      SDL_ScaleMode scale_mode)
+{
+    GXTexObj texobj_a, texobj_b;
+
+    if (format == GX_TF_CI8) {
+        GX_InitTexObjCI(&texobj_a, texels, w, h, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+        GX_InitTexObjCI(&texobj_b, texels, w, h, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+        GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+        // Setup TEV to combine Red+Green and Blue paletted images
+        GX_SetTevColor(GX_TEVREG0, (GXColor){ 255, 255, 0, 0 });
+        GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+        GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+        // first stage = red and green
+        GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+        GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+        // second stage = add blue (and opaque alpha)
+        GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+        GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+        GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+        GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+        GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+        GX_SetNumTevStages(2);
+    } else {
+        GX_InitTexObj(&texobj_a, texels, w, h, format, GX_CLAMP, GX_CLAMP, GX_FALSE);
+    }
+
+    switch (scale_mode) {
+    case SDL_ScaleModeLinear:
+        GX_InitTexObjLOD(&texobj_a, GX_LINEAR, GX_LINEAR,
+                         0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);
+        break;
+    case SDL_ScaleModeBest:
+        GX_InitTexObjLOD(&texobj_a, GX_LIN_MIP_LIN, GX_LINEAR,
+                         0.0f, 10.0f, 0.0f, 0, GX_ENABLE, GX_ANISO_4);
+        break;
+    default:
+        GX_InitTexObjLOD(&texobj_a, GX_NEAR, GX_NEAR,
+                         0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);
+    }
+    GX_LoadTexObj(&texobj_a, GX_TEXMAP0); // load texture object so its ready to use
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcgxcommon.h b/src/video/ogc/SDL_ogcgxcommon.h
new file mode 100644
index 0000000000..1b2ed5b321
--- /dev/null
+++ b/src/video/ogc/SDL_ogcgxcommon.h
@@ -0,0 +1,39 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcgxcommon_h_
+#define SDL_ogcgxcommon_h_
+
+#include "SDL_render.h"
+
+#include <gctypes.h>
+
+#define GX_COLOR_AS_U32(c) *((u32*)&c)
+
+void OGC_draw_init(int w, int h);
+void OGC_set_viewport(int x, int y, int w, int h);
+void OGC_load_texture(void *texels, int w, int h, u8 gx_format,
+                      SDL_ScaleMode scale_mode);
+
+#endif /* SDL_ogcgxcommon_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogckeyboard.c b/src/video/ogc/SDL_ogckeyboard.c
new file mode 100644
index 0000000000..1ebf0f8fc5
--- /dev/null
+++ b/src/video/ogc/SDL_ogckeyboard.c
@@ -0,0 +1,59 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL_ogckeyboard.h"
+#include "../../events/SDL_keyboard_c.h"
+
+#if defined(SDL_VIDEO_DRIVER_OGC) && defined(__wii__)
+#include <gctypes.h>
+#include <wiikeyboard/keyboard.h>
+
+void OGC_PumpKeyboardEvents(_THIS) {
+    keyboard_event ke;
+
+    s32 res = KEYBOARD_GetEvent(&ke);
+    if (res && (ke.type == KEYBOARD_RELEASED || ke.type == KEYBOARD_PRESSED)) {
+        SDL_SendKeyboardKey((ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED : SDL_RELEASED, (SDL_Scancode)ke.keycode);
+
+        if (ke.type == KEYBOARD_PRESSED) {
+            const Uint16 symbol = ke.symbol;
+            char utf8[4] = {'\0'};
+
+            /* ignore private symbols, used by wiikeyboard for special keys */
+            if ((symbol >= 0xE000 && symbol <= 0xF8FF) || symbol == 0xFFFF)
+                return;
+
+            /* convert UCS-2 to UTF-8 */
+            if (symbol < 0x80) {
+                utf8[0] = symbol;
+            } else if (symbol < 0x800) {
+                utf8[0] = 0xC0 | (symbol >> 6);
+                utf8[1] = 0x80 | (symbol & 0x3F);
+            } else {
+                utf8[0] = 0xE0 |  (symbol >> 12);
+                utf8[1] = 0x80 | ((symbol >> 6) & 0x3F);
+                utf8[2] = 0x80 |  (symbol & 0x3F);
+            }
+
+            SDL_SendKeyboardText(utf8);
+        }
+    }
+}
+#endif
diff --git a/src/video/ogc/SDL_ogckeyboard.h b/src/video/ogc/SDL_ogckeyboard.h
new file mode 100644
index 0000000000..ca8c0464df
--- /dev/null
+++ b/src/video/ogc/SDL_ogckeyboard.h
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_OGC_keyboard_h_
+#define SDL_OGC_keyboard_h_
+
+#include "../../SDL_internal.h"
+#include "SDL_ogcvideo.h"
+
+#ifdef __wii__
+void OGC_PumpKeyboardEvents(_THIS);
+#endif
+
+#endif /* SDL_OGC_keyboard_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcmouse.c b/src/video/ogc/SDL_ogcmouse.c
new file mode 100644
index 0000000000..6e3bda2565
--- /dev/null
+++ b/src/video/ogc/SDL_ogcmouse.c
@@ -0,0 +1,416 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if defined(SDL_VIDEO_DRIVER_OGC) && defined(__wii__)
+
+#include "SDL_surface.h"
+#include "SDL_hints.h"
+
+#include "SDL_ogccursors.h"
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcmouse.h"
+#include "SDL_ogcpixels.h"
+
+#include "../SDL_sysvideo.h"
+#include "../../render/SDL_sysrender.h"
+
+#include <limits.h>
+#include <malloc.h>
+#include <ogc/cache.h>
+#include <ogc/gx.h>
+#include <ogc/lwp_watchdog.h>
+#include <opengx.h>
+#include <wiiuse/wpad.h>
+
+typedef struct _OGC_CursorData
+{
+    void *texels;
+    int hot_x, hot_y;
+    int w, h;
+} OGC_CursorData;
+
+typedef struct
+{
+    void *texels;
+    int16_t x, y;
+    uint16_t w, h, maxside;
+} OGC_CursorBackground;
+
+static OGC_CursorBackground s_cursor_background;
+static int s_draw_counter = 0;
+static bool s_extra_draw_enabled = false;
+static bool s_2d_viewport_setup = false;
+
+static void draw_rect(s16 x, s16 y, u16 w, u16 h)
+{
+    GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+    GX_Position2s16(x, y);
+    GX_TexCoord2u8(0, 0);
+    GX_Position2s16(x + w, y);
+    GX_TexCoord2u8(1, 0);
+    GX_Position2s16(x + w, h + y);
+    GX_TexCoord2u8(1, 1);
+    GX_Position2s16(x, h + y);
+    GX_TexCoord2u8(0, 1);
+    GX_End();
+}
+
+static void draw_cursor_rect(OGC_CursorData *curdata)
+{
+    draw_rect(-curdata->hot_x, -curdata->hot_y, curdata->w, curdata->h);
+}
+
+static void setup_2d_viewport(_THIS)
+{
+    int screen_w, screen_h;
+
+    if (s_2d_viewport_setup) return;
+
+    screen_w = _this->displays[0].current_mode.w;
+    screen_h = _this->displays[0].current_mode.h;
+
+    OGC_set_viewport(0, 0, screen_w, screen_h);
+
+    GX_ClearVtxDesc();
+    GX_SetVtxDesc(GX_VA_POS, GX_DIRECT);
+    GX_SetVtxDesc(GX_VA_TEX0, GX_DIRECT);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XY, GX_S16, 0);
+    GX_SetVtxAttrFmt(GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_U8, 0);
+    GX_SetTexCoordGen(GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+    GX_SetTevOp(GX_TEVSTAGE0, GX_REPLACE);
+    GX_SetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);
+    GX_SetNumTevStages(1);
+    GX_SetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+    GX_SetZMode(GX_DISABLE, GX_ALWAYS, GX_FALSE);
+    GX_SetCullMode(GX_CULL_NONE);
+    GX_SetAlphaCompare(GX_ALWAYS, 0, GX_AOP_AND, GX_ALWAYS, 0);
+
+    GX_SetNumTexGens(1);
+    GX_SetCurrentMtx(GX_PNMTX1);
+
+    s_2d_viewport_setup = true;
+}
+
+/* Create a cursor from a surface */
+static SDL_Cursor *OGC_CreateCursor(SDL_Surface *surface, int hot_x, int hot_y)
+{
+    OGC_CursorData *curdata;
+    SDL_Cursor *cursor;
+    u32 texture_size;
+    SDL_Rect rect;
+
+    SDL_assert(surface->pitch == surface->w * 4);
+
+    cursor = SDL_calloc(1, sizeof(*cursor));
+    if (!cursor) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    curdata = SDL_calloc(1, sizeof(*curdata));
+    if (!curdata) {
+        SDL_OutOfMemory();
+        SDL_free(cursor);
+        return NULL;
+    }
+
+    curdata->hot_x = hot_x;
+    curdata->hot_y = hot_y;
+    curdata->w = surface->w;
+    curdata->h = surface->h;
+
+    texture_size = GX_GetTexBufferSize(surface->w, surface->h, GX_TF_RGBA8,
+                                       GX_FALSE, 0);
+    curdata->texels = memalign(32, texture_size);
+    if (!curdata->texels) {
+        SDL_OutOfMemory();
+        SDL_free(curdata);
+        SDL_free(cursor);
+        return NULL;
+    }
+
+    rect.x = rect.y = 0;
+    rect.w = surface->w;
+    rect.h = surface->h;
+    OGC_pixels_to_texture(surface->pixels, surface->format->format, &rect,
+                          surface->pitch, curdata->texels, surface->w);
+    DCStoreRange(curdata->texels, texture_size);
+    GX_InvalidateTexAll();
+
+    cursor->driverdata = curdata;
+
+    return cursor;
+}
+
+SDL_Cursor *OGC_CreateSystemCursor(SDL_SystemCursor id)
+{
+    const OGC_Cursor *cursor;
+    SDL_Surface *surface;
+    SDL_Cursor *c;
+
+    switch (id) {
+    case SDL_SYSTEM_CURSOR_ARROW:
+        cursor = &OGC_cursor_arrow;
+        break;
+    case SDL_SYSTEM_CURSOR_HAND:
+        cursor = &OGC_cursor_hand;
+        break;
+    default:
+        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                    "System cursor %d not implemented", id);
+        return NULL;
+    }
+    surface =
+        SDL_CreateRGBSurfaceWithFormatFrom((void*)cursor->pixel_data,
+                                           cursor->width,
+                                           cursor->height,
+                                           cursor->bytes_per_pixel * 8,
+                                           cursor->width * cursor->bytes_per_pixel,
+                                           SDL_PIXELFORMAT_RGBA8888);
+    c = OGC_CreateCursor(surface, cursor->hot_x, cursor->hot_y);
+    SDL_FreeSurface(surface);
+    return c;
+}
+
+/* Free a window manager cursor */
+static void OGC_FreeCursor(SDL_Cursor *cursor)
+{
+    OGC_CursorData *curdata = cursor->driverdata;
+
+    if (curdata) {
+        if (curdata->texels) {
+            free(curdata->texels);
+        }
+        SDL_free(curdata);
+    }
+
+    SDL_free(cursor);
+}
+
+void OGC_InitMouse(_THIS)
+{
+    SDL_Mouse *mouse = SDL_GetMouse();
+
+    mouse->CreateCursor = OGC_CreateCursor;
+    mouse->CreateSystemCursor = OGC_CreateSystemCursor;
+    mouse->FreeCursor = OGC_FreeCursor;
+
+    SDL_SetDefaultCursor(OGC_CreateSystemCursor(SDL_SYSTEM_CURSOR_HAND));
+}
+
+void OGC_QuitMouse(_THIS)
+{
+}
+
+void OGC_draw_cursor(_THIS)
+{
+    SDL_Mouse *mouse = SDL_GetMouse();
+    OGC_CursorData *curdata;
+    Mtx mv;
+    int screen_w, screen_h;
+    float angle = 0.0f;
+
+    s_draw_counter++;
+
+    /* mark the texture as invalid */
+    s_cursor_background.x = SHRT_MIN;
+
+    if (!mouse || !mouse->cursor_shown ||
+        !mouse->cur_cursor || !mouse->cur_cursor->driverdata) {
+        return;
+    }
+
+    /* If this is the default cursor, rotate it, and if it's not pointed at the
+     * screen, hide it */
+    if (mouse->cur_cursor == mouse->def_cursor) {
+        WPADData *data = WPAD_Data(mouse->mouseID);
+        angle = data->ir.angle;
+        if (!data->ir.valid) return;
+    }
+
+    screen_w = _this->displays[0].current_mode.w;
+    screen_h = _this->displays[0].current_mode.h;
+
+    curdata = mouse->cur_cursor->driverdata;
+
+    if (s_extra_draw_enabled) {
+        /* Save the are behind the cursor. We could use GX_ReadBoundingBox() to
+         * figure out which area to save, but that would require calling the
+         * drawing function once mode. So, let's just take a guess at the area,
+         * taking into account possible cursor rotation. */
+        s16 x, y;
+        u16 w, h, radius, side;
+        u32 texture_size;
+
+        /* +1 is for the rounding of x and y */
+        radius = MAX(curdata->w, curdata->h) + 1;
+        x = mouse->x - radius;
+        y = mouse->y - radius;
+        /* x and y must be multiples of 2 */
+        if (x % 2) x--;
+        if (y % 2) y--;
+        w = h = side = radius * 2;
+        if (x < 0) {
+            w += x;
+            x = 0;
+        } else if (x + w > screen_w) {
+            w = screen_w - x;
+        }
+
+        if (y < 0) {
+            h += y;
+            y = 0;
+        } else if (y + h > screen_h) {
+            h = screen_h - y;
+        }
+
+        /* Make sure all our variables are properly aligned */
+        while (side % 4) side++;
+        while (w % 4) w++;
+        while (h % 4) h++;
+
+        if (w > 0 && h > 0) {
+            texture_size = GX_GetTexBufferSize(side, side, GX_TF_RGBA8,
+                                               GX_FALSE, 0);
+            if (!s_cursor_background.texels || side > s_cursor_background.maxside) {
+                free(s_cursor_background.texels);
+                s_cursor_background.texels = memalign(32, texture_size);
+                s_cursor_background.maxside = side;
+            }
+            DCInvalidateRange(s_cursor_background.texels, texture_size);
+            GX_SetTexCopySrc(x, y, w, h);
+            GX_SetTexCopyDst(w, h, GX_TF_RGBA8, GX_FALSE);
+            GX_CopyTex(s_cursor_background.texels, GX_FALSE);
+            s_cursor_background.x = x;
+            s_cursor_background.y = y;
+            s_cursor_background.w = w;
+            s_cursor_background.h = h;
+        }
+    }
+
+    OGC_load_texture(curdata->texels, curdata->w, curdata->h, GX_TF_RGBA8,
+                     SDL_ScaleModeNearest);
+
+    guMtxIdentity(mv);
+    guMtxScaleApply(mv, mv, screen_w / 640.0f, screen_h / 480.0f, 1.0f);
+    if (angle != 0.0f) {
+        Mtx rot;
+        guMtxRotDeg(rot, 'z', angle);
+        guMtxConcat(mv, rot, mv);
+    }
+    guMtxTransApply(mv, mv, mouse->x, mouse->y, 0);
+    GX_LoadPosMtxImm(mv, GX_PNMTX1);
+
+    setup_2d_viewport(_this);
+
+    draw_cursor_rect(curdata);
+    GX_DrawDone();
+}
+
+void OGC_restore_viewport(_THIS)
+{
+    /* Restore default state for SDL (opengx restores it at every frame, so we
+     * don't care about it) */
+    s_2d_viewport_setup = false;
+    GX_SetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);
+    GX_SetCurrentMtx(GX_PNMTX0);
+    if (_this->windows) {
+        /* Restore previous viewport for the renderer */
+        SDL_Renderer *renderer = SDL_GetRenderer(_this->windows);
+        if (renderer) {
+            OGC_set_viewport(renderer->viewport.x, renderer->viewport.y,
+                             renderer->viewport.w, renderer->viewport.h);
+        }
+    }
+}
+
+bool OGC_prep_draw_cursor(_THIS)
+{
+    GXTexObj background;
+    Mtx mv;
+    static u32 last_draw_ms = 0;
+    u32 current_time_ms, elapsed_ms;
+    static int call_counter = 0;
+    static int last_draw_counter = 0;
+
+    /* Ignore calls when a render target is set or OpenGL is not ready to swap
+     * the framebuffer */
+    SDL_Renderer *renderer = SDL_GetRenderer(_this->windows);
+    if (renderer && renderer->target) return false;
+
+    if (_this->gl_config.driver_loaded &&
+        ogx_prepare_swap_buffers() < 0) return false;
+
+    /* If this function is called repeatedly during the same frame, we assume
+     * that this is one of those applications that call SDL_OGC_GL_SwapWindow,
+     * SDL_UpdateWindowSurface or SDL_RenderPresent only if the video contents
+     * have actually changed.
+     * If that's the case, we toggle a flag that makes us redraw the screen
+     * when the mouse position has changed.
+     */
+    if (!s_extra_draw_enabled) {
+        if (last_draw_counter != s_draw_counter) {
+            call_counter = 1;
+            last_draw_counter = s_draw_counter;
+            return false;
+        }
+
+        if (call_counter++ > 10) {
+            s_extra_draw_enabled = true;
+        } else {
+            return false;
+        }
+    }
+
+    /* Avoid drawing too often. 30 FPS should be enough */
+    current_time_ms = gettime() / TB_TIMER_CLOCK;
+    elapsed_ms = current_time_ms - last_draw_ms;
+    if (elapsed_ms < 33) return false;
+
+    /* If we have a texture for the cursor background, restore it; otherwise,
+     * we shouldn't draw the cursor. */
+    if (!s_cursor_background.texels) return false;
+
+    if (s_cursor_background.x != SHRT_MIN) {
+        setup_2d_viewport(_this);
+
+        GX_PixModeSync();
+        GX_InitTexObj(&background, s_cursor_background.texels,
+                      s_cursor_background.w, s_cursor_background.h,
+                      GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+        GX_InitTexObjLOD(&background, GX_NEAR, GX_NEAR,
+                         0.0f, 0.0f, 0.0f, 0, 0, GX_ANISO_1);
+        GX_LoadTexObj(&background, GX_TEXMAP0);
+        GX_InvalidateTexAll();
+
+        guMtxIdentity(mv);
+        GX_LoadPosMtxImm(mv, GX_PNMTX1);
+        draw_rect(s_cursor_background.x, s_cursor_background.y,
+                  s_cursor_background.w, s_cursor_background.h);
+        last_draw_ms = current_time_ms;
+    }
+    return true;
+}
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcmouse.h b/src/video/ogc/SDL_ogcmouse.h
new file mode 100644
index 0000000000..aa9ff173fe
--- /dev/null
+++ b/src/video/ogc/SDL_ogcmouse.h
@@ -0,0 +1,37 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_OGC_mouse_h_
+#define SDL_OGC_mouse_h_
+
+#include "../SDL_sysvideo.h"
+#include "../../events/SDL_mouse_c.h"
+
+void OGC_InitMouse(_THIS);
+void OGC_QuitMouse(_THIS);
+void OGC_draw_cursor(_THIS);
+void OGC_restore_viewport(_THIS);
+bool OGC_prep_draw_cursor(_THIS);
+SDL_Cursor *OGC_CreateSystemCursor(SDL_SystemCursor id);
+
+#endif /* SDL_OGC_mouse_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcpixels.c b/src/video/ogc/SDL_ogcpixels.c
new file mode 100644
index 0000000000..2d87b40d95
--- /dev/null
+++ b/src/video/ogc/SDL_ogcpixels.c
@@ -0,0 +1,355 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#include "SDL_ogcpixels.h"
+
+#include <ogc/gx.h>
+
+#define PIXELS_TO_TEXTURE_32(format_func) \
+    static void pixels_to_texture_ ## format_func( \
+        void *pixels, const SDL_Rect *rect, int16_t pitch, void *texture, int16_t tex_width) \
+    { \
+        int16_t tex_pitch = (tex_width + 3) / 4 * 4; \
+        for (int row = 0; row < rect->h; row++) { \
+            int y = rect->y + row; \
+            u32 *src = (u32 *)((u8 *)pixels + pitch * row); \
+            for (int col = 0; col < rect->w; col++) { \
+                int x = rect->x + col; \
+                u32 offset = (((y >> 2) << 4) * tex_pitch) + \
+                    ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1); \
+                set_pixel_to_texture_ ## format_func(texture, offset, *src++); \
+            } \
+        } \
+    }
+
+#define PIXELS_FROM_TEXTURE_32(format_func) \
+    static void pixels_from_texture_ ## format_func( \
+        void *pixels, int16_t w, int16_t h, int16_t pitch, void *texture) \
+    { \
+        int tex_width = (w + 3) / 4 * 4; \
+        for (int y = 0; y < h; y++) { \
+            u32 *dst = (u32 *)((u8 *)pixels + pitch * y); \
+            for (int x = 0; x < w; x++) { \
+                u32 offset = (((y >> 2) << 4) * tex_width) + \
+                    ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1); \
+                *dst++ = get_pixel_from_texture_ ## format_func(texture, offset); \
+            } \
+        } \
+    }
+
+static u8 texture_format_from_SDL(const SDL_PixelFormatEnum format)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        return GX_TF_CI8;
+    case SDL_PIXELFORMAT_RGB565:
+        return GX_TF_RGB565;
+    case SDL_PIXELFORMAT_RGB24:
+    case SDL_PIXELFORMAT_RGBA8888:
+    case SDL_PIXELFORMAT_ARGB8888:
+    case SDL_PIXELFORMAT_XRGB8888:
+        return GX_TF_RGBA8;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "(texture_format_from_SDL) Unsupported SDL pixel format %d",
+                     format);
+    }
+    return 0xff; // invalid
+}
+
+static inline void set_pixel_to_texture_ARGB(void *texture, u32 offset, u32 color)
+{
+    *(u16*)(texture + offset) = color >> 16;
+    *(u16*)(texture + offset + 32) = color;
+}
+
+static inline u32 get_pixel_from_texture_ARGB(void *texture, u32 offset)
+{
+    return *(u16*)(texture + offset) << 16 |
+           *(u16*)(texture + offset + 32);
+}
+
+static inline void set_pixel_to_texture_RGBA(void *texture, u32 offset, u32 color)
+{
+    set_pixel_to_texture_ARGB(texture, offset, (color << 24) | (color >> 8));
+}
+
+static inline u32 get_pixel_from_texture_32(int x, int y, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = (((y >> 2) << 4) * tex_width) + ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+
+    return *(tex + offset) |
+           *(tex + offset + 1) << 24 |
+           *(tex + offset + 32) << 16 |
+           *(tex + offset + 33) << 8;
+}
+
+PIXELS_TO_TEXTURE_32(RGBA)
+
+static void pixels_RGBA_from_texture(void *pixels, int16_t w, int16_t h,
+                                     int16_t pitch, void *texture)
+{
+    u32 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u32 *)((u8 *)pixels + pitch * y);
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_from_texture_32(x, y, texture, tex_width);
+        }
+    }
+}
+
+PIXELS_TO_TEXTURE_32(ARGB)
+PIXELS_FROM_TEXTURE_32(ARGB)
+
+static inline void set_pixel_to_texture_XRGB(void *texture, u32 offset, u32 color)
+{
+    set_pixel_to_texture_ARGB(texture, offset, 0xff000000 | color);
+}
+
+PIXELS_TO_TEXTURE_32(XRGB)
+
+static void pixels_XRGB_from_texture(void *pixels, int16_t w, int16_t h,
+                                     int16_t pitch, void *texture)
+{
+    u32 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u32 *)((u8 *)pixels + pitch * y);
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_from_texture_32(x, y, texture, tex_width) >> 8;
+        }
+    }
+}
+
+static void pixels_RGB_to_texture(void *pixels, const SDL_Rect *rect,
+                                  int16_t pitch, void *texture, int16_t tex_width)
+{
+    u8 *src = pixels;
+
+    int tex_pitch = (tex_width + 3) / 4 * 4;
+    for (int row = 0; row < rect->h; row++) {
+        int y = rect->y + row;
+        src = (u8 *)pixels + pitch * row;
+        for (int col = 0; col < rect->w; col++) {
+            int x = rect->x + col;
+            u32 offset = (((y >> 2) << 4) * tex_pitch) +
+                ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+            u8 r = *src++;
+            u8 g = *src++;
+            u8 b = *src++;
+            set_pixel_to_texture_ARGB(texture, offset, 0xff000000 | r << 16 | g << 8 | b);
+        }
+    }
+}
+
+static void pixels_RGB_from_texture(void *pixels, int16_t w, int16_t h,
+                                    int16_t pitch, void *texture)
+{
+    u8 *dst = pixels;
+
+    int tex_width = (w + 3) / 4 * 4;
+    for (int y = 0; y < h; y++) {
+        dst = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            u32 color = get_pixel_from_texture_32(x, y, texture, tex_width);
+            *dst++ = color >> 24;
+            *dst++ = color >> 16;
+            *dst++ = color >> 8;
+        }
+    }
+}
+
+static void pixels_16_to_texture(void *pixels, const SDL_Rect *rect, int16_t pitch,
+                                 void *texture, int16_t tex_width)
+{
+    /* We only support coordinates multiple of 4. While we don't add support
+     * for arbitrary coordinates (TODO), let's restrict the paint area to the
+     * full 4x4 cells covered by the rect. In the future we can add code to
+     * fill up the remaining borders. */
+    int x0 = (rect->x + 3) & ~0x3;
+    int x1 = (rect->x + rect->w) & ~0x3;
+    int y0 = (rect->y + 3) & ~0x3;
+    int y1 = (rect->y + rect->h) & ~0x3;
+    int skipped_bytes_left = (x0 - rect->x) * 2;
+    int tex_pitch = tex_width * 2;
+
+
+    for (int row = 0; row < y1 - y0; row += 4) {
+        u64 *src1 = pixels + (skipped_bytes_left + row * pitch);
+        u64 *src2 = (void*)src1 + (pitch * 1);
+        u64 *src3 = (void*)src1 + (pitch * 2);
+        u64 *src4 = (void*)src1 + (pitch * 3);
+        u64 *dst = texture + (x0 * 8 + (y0 + row) * tex_pitch);
+        for (int col = x0; col < x1; col += 4) {
+            *dst++ = *src1++;
+            *dst++ = *src2++;
+            *dst++ = *src3++;
+            *dst++ = *src4++;
+        }
+    }
+}
+
+static void pixels_16_from_texture(void *pixels, int16_t pitch, int16_t h,
+                                   void *texture)
+{
+    long long int *src = texture;
+    long long int *dst1 = pixels;
+    long long int *dst2 = (long long int *)((char *)pixels + (pitch * 1));
+    long long int *dst3 = (long long int *)((char *)pixels + (pitch * 2));
+    long long int *dst4 = (long long int *)((char *)pixels + (pitch * 3));
+    int rowpitch = (pitch >> 3) * 3;
+
+    for (int y = 0; y < h; y += 4) {
+        for (int x = 0; x < pitch; x += 8) {
+            *dst1++ = *src++;
+            *dst2++ = *src++;
+            *dst3++ = *src++;
+            *dst4++ = *src++;
+        }
+
+        dst1 = dst4;
+        dst2 += rowpitch;
+        dst3 += rowpitch;
+        dst4 += rowpitch;
+    }
+}
+
+static inline void set_pixel_8_to_texture(int x, int y, u8 color, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = ((y & ~3) * tex_width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+    tex[offset] = color;
+}
+
+static inline u8 get_pixel_8_from_texture(int x, int y, void *texture, int tex_width)
+{
+    u8 *tex = texture;
+    u32 offset;
+
+    offset = ((y & ~3) * tex_width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+    return tex[offset];
+}
+
+static void pixels_8_to_texture(void *pixels, int16_t w, int16_t h,
+                                int16_t pitch, void *texture)
+{
+    u8 *src = pixels;
+    int tex_width = (w + 7) / 8 * 8;
+
+    for (int y = 0; y < h; y++) {
+        src = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            set_pixel_8_to_texture(x, y, *src++, texture, tex_width);
+        }
+    }
+}
+
+static void pixels_8_from_texture(void *pixels, int16_t w, int16_t h,
+                                  int16_t pitch, void *texture)
+{
+    u8 *dst = pixels;
+    int tex_width = (w + 7) / 8 * 8;
+
+    for (int y = 0; y < h; y++) {
+        dst = (u8 *)pixels + pitch * y;
+        for (int x = 0; x < w; x++) {
+            *dst++ = get_pixel_8_from_texture(x, y, texture, tex_width);
+        }
+    }
+}
+
+void OGC_pixels_to_texture(void *pixels, const SDL_PixelFormatEnum format,
+                           const SDL_Rect *rect, int16_t pitch,
+                           void *texture, int16_t tex_width)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        pixels_8_to_texture(pixels, rect->w, rect->h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB565:
+        pixels_16_to_texture(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_RGB24:
+        pixels_RGB_to_texture(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_RGBA8888:
+        pixels_to_texture_RGBA(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_ARGB8888:
+        pixels_to_texture_ARGB(pixels, rect, pitch, texture, tex_width);
+        break;
+    case SDL_PIXELFORMAT_XRGB8888:
+        pixels_to_texture_XRGB(pixels, rect, pitch, texture, tex_width);
+        break;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "ptt: unsupported SDL pixel format %d", format);
+        // TODO support more formats
+    }
+}
+
+void OGC_pixels_from_texture(void *pixels, const SDL_PixelFormatEnum format,
+                             int16_t w, int16_t h, int16_t pitch,
+                             void *texture)
+{
+    switch (format) {
+    case SDL_PIXELFORMAT_INDEX8:
+        pixels_8_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB565:
+        pixels_16_from_texture(pixels, pitch, h, texture);
+        break;
+    case SDL_PIXELFORMAT_RGB24:
+        pixels_RGB_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_RGBA8888:
+        pixels_RGBA_from_texture(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_ARGB8888:
+        pixels_from_texture_ARGB(pixels, w, h, pitch, texture);
+        break;
+    case SDL_PIXELFORMAT_XRGB8888:
+        pixels_XRGB_from_texture(pixels, w, h, pitch, texture);
+        break;
+    default:
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO,
+                     "pft: unsupported SDL pixel format %d", format);
+        // TODO support more formats
+    }
+}
+
+u8 OGC_texture_format_from_SDL(const SDL_PixelFormatEnum format)
+{
+    return texture_format_from_SDL(format);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcpixels.h b/src/video/ogc/SDL_ogcpixels.h
new file mode 100644
index 0000000000..c92d032aa4
--- /dev/null
+++ b/src/video/ogc/SDL_ogcpixels.h
@@ -0,0 +1,42 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcpixels_h_
+#define SDL_ogcpixels_h_
+
+#include "SDL_pixels.h"
+#include "SDL_rect.h"
+
+#include <gctypes.h>
+
+void OGC_pixels_to_texture(void *pixels, SDL_PixelFormatEnum format,
+                           const SDL_Rect *rect, int16_t pitch,
+                           void *texels, int16_t tex_width);
+void OGC_pixels_from_texture(void *pixels, SDL_PixelFormatEnum format,
+                             int16_t w, int16_t h, int16_t pitch,
+                             void *texels);
+
+u8 OGC_texture_format_from_SDL(const SDL_PixelFormatEnum format);
+
+#endif /* SDL_ogcpixels_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcvideo.c b/src/video/ogc/SDL_ogcvideo.c
new file mode 100644
index 0000000000..5653700f73
--- /dev/null
+++ b/src/video/ogc/SDL_ogcvideo.c
@@ -0,0 +1,380 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_VIDEO_DRIVER_OGC
+
+#include "../../events/SDL_events_c.h"
+#include "../SDL_pixels_c.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_mouse.h"
+#include "SDL_video.h"
+
+#include "SDL_hints.h"
+#include "SDL_ogcevents_c.h"
+#include "SDL_ogcframebuffer_c.h"
+#include "SDL_ogcgl.h"
+#include "SDL_ogcgxcommon.h"
+#include "SDL_ogcmouse.h"
+#include "SDL_ogcvideo.h"
+
+#include <malloc.h>
+#include <ogc/color.h>
+#include <ogc/gx.h>
+#include <ogc/system.h>
+#include <ogc/video.h>
+
+#include <opengx.h>
+
+#define DEFAULT_FIFO_SIZE 256 * 1024
+
+// Inverse of the VI_TVMODE macro
+#define VI_FORMAT_FROM_MODE(tvmode) (tvmode >> 2)
+
+/* A video mode with a 320 width; we'll build it programmatically. */
+static GXRModeObj s_mode320;
+
+static const GXRModeObj *s_ntsc_modes[] = {
+    &TVNtsc240Ds,
+    &TVNtsc480Prog,
+    NULL,
+};
+
+static const GXRModeObj *s_mpal_modes[] = {
+    &TVMpal240Ds,
+    &TVMpal480Prog,
+    NULL,
+};
+
+static const GXRModeObj *s_eurgb60_modes[] = {
+    &TVEurgb60Hz240Ds,
+    &TVEurgb60Hz480Prog,
+    // Also add some PAL modes, since EURGB60 supports them too
+    &TVPal264Ds,
+    &TVPal528Prog,
+    &TVPal576ProgScale,
+    NULL,
+};
+
+static const GXRModeObj *s_pal_modes[] = {
+    &TVPal264Ds,
+    &TVPal528Prog,
+    &TVPal576ProgScale,
+    NULL,
+};
+
+/* Initialization/Query functions */
+static int OGC_VideoInit(_THIS);
+static void OGC_VideoQuit(_THIS);
+
+static void init_display_mode(SDL_DisplayMode *mode, const GXRModeObj *vmode)
+{
+    u32 format = VI_FORMAT_FROM_MODE(vmode->viTVMode);
+
+    /* Use a fake 32-bpp desktop mode */
+    SDL_zero(*mode);
+    mode->format = SDL_PIXELFORMAT_ARGB8888;
+    mode->w = vmode->fbWidth;
+    mode->h = vmode->efbHeight;
+    switch (format) {
+    case VI_DEBUG:
+    case VI_NTSC:
+    case VI_EURGB60:
+    case VI_MPAL:
+        mode->refresh_rate = 60;
+        break;
+    case VI_PAL:
+    case VI_DEBUG_PAL:
+        mode->refresh_rate = 50;
+        break;
+    }
+    mode->driverdata = (GXRModeObj*)vmode;
+}
+
+static void add_supported_modes(SDL_VideoDisplay *display, u32 tv_format)
+{
+    const GXRModeObj **gx_modes;
+    SDL_DisplayMode mode;
+
+    switch (tv_format) {
+    case VI_DEBUG:
+    case VI_NTSC:
+        gx_modes = s_ntsc_modes;
+        break;
+    case VI_MPAL:
+        gx_modes = s_mpal_modes;
+        break;
+    case VI_EURGB60:
+        gx_modes = s_eurgb60_modes;
+        break;
+    case VI_PAL:
+    case VI_DEBUG_PAL:
+        gx_modes = s_pal_modes;
+        break;
+    default:
+        return;
+    }
+
+    /* All libogc video modes are 640 pixel wide, even the 240p ones. While
+     * this can be useful for some applications, others might prefer a video
+     * mode with less elongated pixels, such as 320x240. Therefore, let's
+     * create one: we take the first video mode in the array (which has always
+     * a height of approximately 240p) and we use it as template to build the
+     * "mode320": we just set the fbWidth field to 320: the VI interface will
+     * take care of the horizontal scale for us. */
+    memcpy(&s_mode320, gx_modes[0], sizeof(s_mode320));
+    s_mode320.fbWidth = 320;
+    init_display_mode(&mode, &s_mode320);
+    SDL_AddDisplayMode(display, &mode);
+
+    /* Now add all the "standard" modes from libogc */
+    while (*gx_modes) {
+        init_display_mode(&mode, *gx_modes);
+        SDL_AddDisplayMode(display, &mode);
+        gx_modes++;
+    }
+}
+
+static void setup_video_mode(_THIS, GXRModeObj *vmode)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+
+    VIDEO_SetBlack(true);
+    VIDEO_Configure(vmode);
+
+    /* Allocate the XFB */
+    videodata->xfb[0] = MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+    videodata->xfb[1] = MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+
+    VIDEO_ClearFrameBuffer(vmode, videodata->xfb[0], COLOR_BLACK);
+    VIDEO_SetNextFramebuffer(videodata->xfb[0]);
+    VIDEO_SetBlack(false);
+    VIDEO_Flush();
+
+    VIDEO_WaitVSync();
+    if (vmode->viTVMode & VI_NON_INTERLACE) VIDEO_WaitVSync();
+
+    /* Setup the EFB -> XFB copy operation */
+    GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+    GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
+    GX_SetDispCopyYScale((f32)vmode->xfbHeight / (f32)vmode->efbHeight);
+    GX_SetCopyFilter(vmode->aa, vmode->sample_pattern, GX_FALSE, vmode->vfilter);
+    GX_SetFieldMode(vmode->field_rendering,
+                    ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+
+    OGC_draw_init(vmode->fbWidth, vmode->efbHeight);
+}
+
+static int OGC_SetDisplayMode(_THIS, SDL_VideoDisplay *display,
+                              SDL_DisplayMode *mode)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+    /* The GX video mode is stored in the driverdata pointer */
+    GXRModeObj *vmode = mode->driverdata;
+
+    if (videodata->xfb[0])
+        free(MEM_K1_TO_K0(videodata->xfb[0]));
+    if (videodata->xfb[1])
+        free(MEM_K1_TO_K0(videodata->xfb[1]));
+
+    setup_video_mode(_this, vmode);
+    return 0;
+}
+
+static void OGC_ShowWindow(_THIS, SDL_Window *window)
+{
+    SDL_SetMouseFocus(window);
+    SDL_SetKeyboardFocus(window);
+}
+
+static int OGC_ShowMessageBox(_THIS, const SDL_MessageBoxData *messageboxdata,
+                              int *buttonid)
+{
+    /* Unimplemented, but at least show the message in the log */
+    SDL_SetError("ShowMessageBox unimplemented: \"%s\", \"%s\"",
+                 messageboxdata->title, messageboxdata->message);
+    return 0;
+}
+
+/* OGC driver bootstrap functions */
+
+static void OGC_DeleteDevice(SDL_VideoDevice *device)
+{
+    SDL_free(device->driverdata);
+    SDL_free(device);
+}
+
+static SDL_VideoDevice *OGC_CreateDevice(void)
+{
+    SDL_VideoDevice *device;
+    SDL_VideoData *videodata;
+
+    /* Initialize all variables that we clean on shutdown */
+    device = (SDL_VideoDevice *)SDL_calloc(1, sizeof(SDL_VideoDevice));
+    if (!device) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    videodata = (SDL_VideoData *)SDL_calloc(1, sizeof(SDL_VideoData));
+    if (!videodata) {
+        SDL_OutOfMemory();
+        SDL_free(device);
+        return NULL;
+    }
+
+    device->driverdata = videodata;
+
+    /* Set the function pointers */
+    device->VideoInit = OGC_VideoInit;
+    device->VideoQuit = OGC_VideoQuit;
+    device->SetDisplayMode = OGC_SetDisplayMode;
+    device->PumpEvents = OGC_PumpEvents;
+    device->ShowWindow = OGC_ShowWindow;
+    device->CreateWindowFramebuffer = SDL_OGC_CreateWindowFramebuffer;
+    device->UpdateWindowFramebuffer = SDL_OGC_UpdateWindowFramebuffer;
+    device->DestroyWindowFramebuffer = SDL_OGC_DestroyWindowFramebuffer;
+    device->ShowMessageBox = OGC_ShowMessageBox;
+
+#ifdef SDL_VIDEO_OPENGL
+    device->GL_LoadLibrary = SDL_OGC_GL_LoadLibrary;
+    device->GL_GetProcAddress = SDL_OGC_GL_GetProcAddress;
+    device->GL_UnloadLibrary = SDL_OGC_GL_UnloadLibrary;
+    device->GL_CreateContext = SDL_OGC_GL_CreateContext;
+    device->GL_MakeCurrent = SDL_OGC_GL_MakeCurrent;
+    device->GL_SetSwapInterval = SDL_OGC_GL_SetSwapInterval;
+    device->GL_GetSwapInterval = SDL_OGC_GL_GetSwapInterval;
+    device->GL_SwapWindow = SDL_OGC_GL_SwapWindow;
+    device->GL_DeleteContext = SDL_OGC_GL_DeleteContext;
+    device->GL_DefaultProfileConfig = SDL_OGC_GL_DefaultProfileConfig;
+#endif
+
+    device->free = OGC_DeleteDevice;
+
+    return device;
+}
+
+VideoBootStrap OGC_bootstrap = {
+    "ogc-video", "ogc video driver",
+    OGC_CreateDevice
+};
+
+int OGC_VideoInit(_THIS)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+    SDL_DisplayMode mode;
+    GXRModeObj *vmode;
+    static const GXColor background = { 0, 0, 0, 255 };
+
+    VIDEO_Init();
+
+    vmode = VIDEO_GetPreferredMode(NULL);
+
+    videodata->gp_fifo = memalign(32, DEFAULT_FIFO_SIZE);
+    memset(videodata->gp_fifo, 0, DEFAULT_FIFO_SIZE);
+    GX_Init(videodata->gp_fifo, DEFAULT_FIFO_SIZE);
+
+    setup_video_mode(_this, vmode);
+    GX_SetCopyClear(background, GX_MAX_Z24);
+
+    GX_SetPixelFmt(GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+    GX_SetCullMode(GX_CULL_NONE);
+    GX_SetBlendMode(GX_BM_NONE, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_CLEAR);
+
+    GX_SetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);
+
+    GX_Flush();
+
+    init_display_mode(&mode, vmode);
+    if (SDL_AddBasicVideoDisplay(&mode) < 0) {
+        return -1;
+    }
+
+    SDL_AddDisplayMode(&_this->displays[0], &mode);
+    add_supported_modes(&_this->displays[0], VI_FORMAT_FROM_MODE(vmode->viTVMode));
+
+    videodata->vmode = vmode;
+
+#ifdef __wii__
+    OGC_InitMouse(_this);
+#endif
+    return 0;
+}
+
+void OGC_VideoQuit(_THIS)
+{
+    SDL_VideoData *videodata = (SDL_VideoData *)_this->driverdata;
+    SDL_VideoDisplay *display;
+
+#ifdef __wii__
+    OGC_QuitMouse(_this);
+#endif
+
+    SDL_free(videodata->gp_fifo);
+    if (videodata->xfb[0])
+        free(MEM_K1_TO_K0(videodata->xfb[0]));
+    if (videodata->xfb[1])
+        free(MEM_K1_TO_K0(videodata->xfb[1]));
+
+    /* During shutdown, SDL_ResetDisplayModes() will be called and will invoke
+     * SDL_free() on driverdata. Nullify the pointers in order to avoid a
+     * crash, since we didn't actually allocate this memory. */
+    display = &_this->displays[0];
+    for (int i = display->num_display_modes; i--;) {
+        display->display_modes[i].driverdata = NULL;
+    }
+    display->desktop_mode.driverdata = NULL;
+}
+
+void *OGC_video_get_xfb(_THIS)
+{
+    SDL_VideoData *videodata = _this->driverdata;
+    return videodata->xfb[videodata->fb_index];
+}
+
+void OGC_video_flip(_THIS, bool vsync)
+{
+    SDL_VideoData *videodata = _this->driverdata;
+    void *xfb = OGC_video_get_xfb(_this);
+
+    if (_this->gl_config.driver_loaded &&
+        ogx_prepare_swap_buffers() < 0) return;
+
+#ifdef __wii__
+    OGC_draw_cursor(_this);
+    OGC_restore_viewport(_this);
+#endif
+    GX_CopyDisp(xfb, GX_FALSE);
+    GX_DrawDone();
+    GX_Flush();
+
+    VIDEO_SetNextFramebuffer(xfb);
+    VIDEO_Flush();
+    if (vsync) {
+        VIDEO_WaitVSync();
+    }
+
+    videodata->fb_index ^= 1;
+}
+
+#endif /* SDL_VIDEO_DRIVER_OGC */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/ogc/SDL_ogcvideo.h b/src/video/ogc/SDL_ogcvideo.h
new file mode 100644
index 0000000000..3821d1966c
--- /dev/null
+++ b/src/video/ogc/SDL_ogcvideo.h
@@ -0,0 +1,50 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2023 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_ogcvideo_h_
+#define SDL_ogcvideo_h_
+
+#include "../SDL_sysvideo.h"
+
+#include <ogc/gx_struct.h>
+
+typedef struct SDL_VideoData
+{
+    GXRModeObj *vmode;
+    u8 *gp_fifo;
+    void *xfb[2];
+    u8 fb_index;
+} SDL_VideoData;
+
+typedef struct SDL_WindowData
+{
+    void *pixels;
+    u8 *texels;
+    SDL_PixelFormatEnum surface_format;
+} SDL_WindowData;
+
+void *OGC_video_get_xfb(SDL_VideoDevice *device);
+void OGC_video_flip(SDL_VideoDevice *device, bool vsync);
+
+#endif /* SDL_ogcvideo_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 52a268561c..4cf924dd90 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -36,6 +36,10 @@ if(N3DS)
     link_libraries(SDL2::SDL2main)
 endif()
 
+if(OGC)
+    link_libraries(SDL2::SDL2main)
+endif()
+
 if(PSP)
     link_libraries(
         SDL2::SDL2main
