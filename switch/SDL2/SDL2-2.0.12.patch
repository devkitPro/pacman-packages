diff --git a/CMakeLists.switch b/CMakeLists.switch
new file mode 100644
index 000000000..b6c3817d9
--- /dev/null
+++ b/CMakeLists.switch
@@ -0,0 +1,86 @@
+cmake_minimum_required(VERSION 3.0)
+#set(CMAKE_VERBOSE_MAKEFILE ON)
+
+set(CMAKE_SYSTEM_NAME "Generic")
+
+set(DEVKITPRO $ENV{DEVKITPRO})
+set(CMAKE_SYSTEM_PROCESSOR "armv8-a")
+set(CMAKE_C_COMPILER "${DEVKITPRO}/devkitA64/bin/aarch64-none-elf-gcc")
+set(CMAKE_CXX_COMPILER "${DEVKITPRO}/devkitA64/bin/aarch64-none-elf-g++")
+set(CMAKE_ASM_COMPILER "${DEVKITPRO}/devkitA64/bin/aarch64-none-elf-as")
+set(CMAKE_AR "${DEVKITPRO}/devkitA64/bin/aarch64-none-elf-gcc-ar" CACHE STRING "")
+set(CMAKE_RANLIB "${DEVKITPRO}/devkitA64/bin/aarch64-none-elf-gcc-ranlib" CACHE STRING "")
+set(CMAKE_C_FLAGS "-g -O2 -march=armv8-a -mtune=cortex-a57 -mtp=soft -ftls-model=local-exec -fPIC -I${DEVKITPRO}/libnx/include -I${DEVKITPRO}/portlibs/switch/include" CACHE STRING "C flags")
+set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -fno-rtti -fno-exceptions" CACHE STRING "C++ flags")
+set(CMAKE_FIND_ROOT_PATH ${DEVKITPRO} ${DEVKITPRO}/devkitA64 ${DEVKITPRO}/libnx ${DEVKITPRO}/portlibs/switch)
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
+set(BUILD_SHARED_LIBS OFF CACHE INTERNAL "Shared libs not available")
+
+project(SDL2)
+
+set(SRC_DIRS
+        src
+        src/atomic
+        src/audio
+        src/audio/switch
+        src/cpuinfo
+        src/events
+        src/file
+        src/filesystem/dummy
+        src/haptic
+        src/haptic/dummy
+        src/joystick
+        src/joystick/switch
+        src/joystick/dummy
+        src/loadso
+        src/loadso/dummy
+        src/libm
+        src/power
+        src/render
+        src/render/software
+        src/render/opengl
+        src/render/opengles
+        src/render/opengles2
+        src/stdlib
+        src/thread
+        src/thread/switch
+        src/timer
+        src/timer/switch
+        src/video
+        src/video/yuv2rgb
+        src/video/switch
+        src/sensor
+        src/sensor/dummy
+        )
+
+set(SRC_FILES )
+foreach (DIR ${SRC_DIRS})
+    file(GLOB FILES ${DIR}/*.c*)
+    list(APPEND SRC_FILES ${FILES})
+endforeach (DIR)
+
+# SDL2 library
+add_library(${PROJECT_NAME} STATIC ${SRC_FILES})
+target_include_directories(${PROJECT_NAME} PUBLIC ${SRC_DIRS} include)
+target_compile_options(${PROJECT_NAME} PUBLIC -O3 -D__SWITCH__ -DSDL_VIDEO_STATIC_ANGLE)
+
+# SDL2 test
+add_executable(${PROJECT_NAME}.elf test/testswitch.c)
+target_include_directories(${PROJECT_NAME}.elf PRIVATE include)
+target_compile_options(${PROJECT_NAME}.elf PRIVATE -O3 -D__SWITCH__)
+target_link_libraries(${PROJECT_NAME}.elf
+        ${PROJECT_NAME}
+        ${DEVKITPRO}/portlibs/switch/lib/libEGL.a
+        ${DEVKITPRO}/portlibs/switch/lib/libglapi.a
+        ${DEVKITPRO}/portlibs/switch/lib/libdrm_nouveau.a
+        ${DEVKITPRO}/libnx/lib/libnx.a
+        stdc++
+        m
+        )
+set_target_properties(${PROJECT_NAME}.elf PROPERTIES LINK_FLAGS "-specs=${DEVKITPRO}/libnx/switch.specs")
+add_custom_target(${PROJECT_NAME}.nro
+        DEPENDS ${PROJECT_NAME}.elf
+        COMMAND elf2nro ${PROJECT_NAME}.elf ${PROJECT_NAME}.nro)
diff --git a/configure b/configure
index 9c46ffe2b..93d277692 100755
--- a/configure
+++ b/configure
@@ -25383,6 +25383,72 @@ $as_echo "#define SDL_TIMER_UNIX 1" >>confdefs.h
             have_timers=yes
         fi
         ;;
+	aarch64-none-elf*)
+        ARCH=switch
+        SDL_CFLAGS="$SDL_CFLAGS -D__SWITCH__ -march=armv8-a -mtune=cortex-a57 \
+            -mtp=soft -ftls-model=local-exec \
+            -isystem ${DEVKITPRO}/libnx/include -I${DEVKITPRO}/portlibs/switch/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -fPIC"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $SDL_CFLAGS -g -O3"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DSDL_VIDEO_STATIC_ANGLE"
+        EXTRA_LDFLAGS="-march=armv8-a -fPIE -L${DEVKITPRO}/libnx/lib -lEGL -lglapi -ldrm_nouveau -lnx"
+        CheckDeclarationAfterStatement
+
+        # Set up files for the video library
+        if test x$enable_video = xyes; then
+            SOURCES="$SOURCES $srcdir/src/video/switch/*.c"
+
+$as_echo "#define SDL_VIDEO_DRIVER_SWITCH 1" >>confdefs.h
+
+
+$as_echo "#define SDL_VIDEO_OPENGL_EGL 1" >>confdefs.h
+
+
+$as_echo "#define SDL_VIDEO_OPENGL 1" >>confdefs.h
+
+
+$as_echo "#define SDL_VIDEO_OPENGL_ES2 1" >>confdefs.h
+
+
+$as_echo "#define SDL_VIDEO_RENDER_OGL_ES2 1" >>confdefs.h
+
+            SUMMARY_video="${SUMMARY_video} switch_opengles2"
+            have_video=yes
+        fi
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+
+$as_echo "#define SDL_AUDIO_DRIVER_SWITCH 1" >>confdefs.h
+
+           SOURCES="$SOURCES $srcdir/src/audio/switch/*.c"
+           SUMMARY_audio="${SUMMARY_audio} switch"
+           have_audio=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+
+$as_echo "#define SDL_JOYSTICK_SWITCH 1" >>confdefs.h
+
+            SOURCES="$SOURCES $srcdir/src/joystick/switch/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+
+$as_echo "#define SDL_TIMER_SWITCH 1" >>confdefs.h
+
+            SOURCES="$SOURCES $srcdir/src/timer/switch/*.c"
+            have_timers=yes
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+
+$as_echo "#define SDL_THREAD_SWITCH 1" >>confdefs.h
+
+            SOURCES="$SOURCES $srcdir/src/thread/switch/*.c"
+            have_threads=yes
+        fi
+        ;;
     *)
         as_fn_error $? "
 *** Unsupported host:  Please add to configure.ac
diff --git a/configure.ac b/configure.ac
index 19361a4b8..0959f5272 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4085,6 +4085,54 @@ AS_HELP_STRING([--enable-render-d3d], [enable the Direct3D render driver [[defau
             have_timers=yes
         fi
         ;;
+	aarch64-none-elf*)
+        ARCH=switch
+        SDL_CFLAGS="$SDL_CFLAGS -D__SWITCH__ -march=armv8-a -mtune=cortex-a57 \
+            -mtp=soft -ftls-model=local-exec \
+            -isystem ${DEVKITPRO}/libnx/include -I${DEVKITPRO}/portlibs/switch/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -fPIC"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $SDL_CFLAGS -g -O3"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -DSDL_VIDEO_STATIC_ANGLE"
+        EXTRA_LDFLAGS="-march=armv8-a -fPIE -L${DEVKITPRO}/libnx/lib -lEGL -lglapi -ldrm_nouveau -lnx"
+        CheckDeclarationAfterStatement
+
+        # Set up files for the video library
+        if test x$enable_video = xyes; then
+            SOURCES="$SOURCES $srcdir/src/video/switch/*.c"
+            AC_DEFINE(SDL_VIDEO_DRIVER_SWITCH, 1, [ ])
+            AC_DEFINE(SDL_VIDEO_OPENGL_EGL, 1, [ ])
+            AC_DEFINE(SDL_VIDEO_OPENGL, 1, [ ])
+            AC_DEFINE(SDL_VIDEO_OPENGL_ES2, 1, [ ])
+            AC_DEFINE(SDL_VIDEO_RENDER_OGL_ES2, 1, [ ])
+            SUMMARY_video="${SUMMARY_video} switch_opengles2"
+            have_video=yes
+        fi
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+           AC_DEFINE(SDL_AUDIO_DRIVER_SWITCH, 1, [ ])
+           SOURCES="$SOURCES $srcdir/src/audio/switch/*.c"
+           SUMMARY_audio="${SUMMARY_audio} switch"
+           have_audio=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_SWITCH, 1, [ ])
+            SOURCES="$SOURCES $srcdir/src/joystick/switch/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            AC_DEFINE(SDL_TIMER_SWITCH, 1, [ ])
+            SOURCES="$SOURCES $srcdir/src/timer/switch/*.c"
+            have_timers=yes
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+            AC_DEFINE(SDL_THREAD_SWITCH, 1, [ ])
+            SOURCES="$SOURCES $srcdir/src/thread/switch/*.c"
+            have_threads=yes
+        fi
+        ;;
     *)
         AC_MSG_ERROR([
 *** Unsupported host:  Please add to configure.ac
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index f769e3cf4..f06209093 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -273,6 +273,7 @@
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WASAPI
 #undef SDL_AUDIO_DRIVER_WINMM
+#undef SDL_AUDIO_DRIVER_SWITCH
 
 /* Enable various input drivers */
 #undef SDL_INPUT_LINUXEV
@@ -290,6 +291,7 @@
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
 #undef SDL_JOYSTICK_HIDAPI
 #undef SDL_JOYSTICK_EMSCRIPTEN
+#undef SDL_JOYSTICK_SWITCH
 #undef SDL_HAPTIC_DUMMY
 #undef SDL_HAPTIC_ANDROID
 #undef SDL_HAPTIC_LINUX
@@ -312,12 +314,14 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_WINDOWS
+#undef SDL_THREAD_SWITCH
 
 /* Enable various timer systems */
 #undef SDL_TIMER_HAIKU
 #undef SDL_TIMER_DUMMY
 #undef SDL_TIMER_UNIX
 #undef SDL_TIMER_WINDOWS
+#undef SDL_TIMER_SWITCH
 
 /* Enable various video drivers */
 #undef SDL_VIDEO_DRIVER_HAIKU
@@ -363,6 +367,7 @@
 #undef SDL_VIDEO_DRIVER_VIVANTE
 #undef SDL_VIDEO_DRIVER_VIVANTE_VDK
 #undef SDL_VIDEO_DRIVER_QNX
+#undef SDL_VIDEO_DRIVER_SWITCH
 
 #undef SDL_VIDEO_RENDER_D3D
 #undef SDL_VIDEO_RENDER_D3D11
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 313749323..a276bc5a3 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -101,6 +101,9 @@ static const AudioBootStrap *const bootstrap[] = {
 #if SDL_AUDIO_DRIVER_EMSCRIPTEN
     &EMSCRIPTENAUDIO_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_SWITCH
+    &SWITCHAUDIO_bootstrap,
+#endif
 #if SDL_AUDIO_DRIVER_JACK
     &JACK_bootstrap,
 #endif
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 7359adcc9..9d56dab13 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -207,6 +207,7 @@ extern AudioBootStrap openslES_bootstrap;
 extern AudioBootStrap ANDROIDAUDIO_bootstrap;
 extern AudioBootStrap PSPAUDIO_bootstrap;
 extern AudioBootStrap EMSCRIPTENAUDIO_bootstrap;
+extern AudioBootStrap SWITCHAUDIO_bootstrap;
 
 #endif /* SDL_sysaudio_h_ */
 
diff --git a/src/audio/switch/SDL_switchaudio.c b/src/audio/switch/SDL_switchaudio.c
new file mode 100644
index 000000000..56211a5c7
--- /dev/null
+++ b/src/audio/switch/SDL_switchaudio.c
@@ -0,0 +1,227 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_AUDIO_DRIVER_SWITCH
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <malloc.h>
+
+#include "SDL_audio.h"
+#include "../SDL_audio_c.h"
+#include "../SDL_audiodev_c.h"
+
+#include "SDL_switchaudio.h"
+
+static const AudioRendererConfig arConfig =
+    {
+        .output_rate     = AudioRendererOutputRate_48kHz,
+        .num_voices      = 24,
+        .num_effects     = 0,
+        .num_sinks       = 1,
+        .num_mix_objs    = 1,
+        .num_mix_buffers = 2,
+    };
+
+static int
+SWITCHAUDIO_OpenDevice(_THIS, void *handle, const char *devname, int iscapture)
+{
+    static const u8 sink_channels[] = {0, 1};
+    SDL_bool supported_format = SDL_FALSE;
+    SDL_AudioFormat test_format;
+    Result res;
+    u32 size;
+    int mpid;
+
+    this->hidden = (struct SDL_PrivateAudioData *) SDL_malloc(sizeof(*this->hidden));
+    if (this->hidden == NULL) {
+        return SDL_OutOfMemory();
+    }
+    SDL_zerop(this->hidden);
+
+    res = audrenInitialize(&arConfig);
+    if (R_FAILED(res)) {
+        return SDL_SetError("audrenInitialize failed (0x%x)", res);
+    }
+    this->hidden->audr_device = true;
+
+    res = audrvCreate(&this->hidden->driver, &arConfig, 2);
+    if (R_FAILED(res)) {
+        return SDL_SetError("audrvCreate failed (0x%x)", res);
+    }
+    this->hidden->audr_driver = true;
+
+    test_format = SDL_FirstAudioFormat(this->spec.format);
+    while ((!supported_format) && (test_format)) {
+        if (test_format == AUDIO_S16SYS) {
+            supported_format = SDL_TRUE;
+        }
+        else {
+            test_format = SDL_NextAudioFormat();
+        }
+    }
+    if (!supported_format) {
+        return SDL_SetError("Unsupported audio format");
+    }
+
+    this->spec.format = test_format;
+    SDL_CalculateAudioSpec(&this->spec);
+
+    size = (u32) ((this->spec.size * 2) + 0xfff) & ~0xfff;
+    this->hidden->pool = memalign(0x1000, size);
+    for (int i = 0; i < 2; i++) {
+        this->hidden->buffer[i].data_raw = this->hidden->pool;
+        this->hidden->buffer[i].size = this->spec.size * 2;
+        this->hidden->buffer[i].start_sample_offset = i * this->spec.samples;
+        this->hidden->buffer[i].end_sample_offset = this->hidden->buffer[i].start_sample_offset + this->spec.samples;
+        this->hidden->buffer_tmp = malloc(this->spec.size);
+    }
+
+    mpid = audrvMemPoolAdd(&this->hidden->driver, this->hidden->pool, size);
+    audrvMemPoolAttach(&this->hidden->driver, mpid);
+
+    audrvDeviceSinkAdd(&this->hidden->driver, AUDREN_DEFAULT_DEVICE_NAME, 2, sink_channels);
+
+    res = audrenStartAudioRenderer();
+    if (R_FAILED(res)) {
+        return SDL_SetError("audrenStartAudioRenderer failed (0x%x)", res);
+    }
+
+    audrvVoiceInit(&this->hidden->driver, 0, this->spec.channels, PcmFormat_Int16, this->spec.freq);
+    audrvVoiceSetDestinationMix(&this->hidden->driver, 0, AUDREN_FINAL_MIX_ID);
+    if (this->spec.channels == 1) {
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 1.0f, 0, 0);
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 1.0f, 0, 1);
+    }
+    else {
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 1.0f, 0, 0);
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 0.0f, 0, 1);
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 0.0f, 1, 0);
+        audrvVoiceSetMixFactor(&this->hidden->driver, 0, 1.0f, 1, 1);
+    }
+
+    audrvVoiceStart(&this->hidden->driver, 0);
+
+    return 0;
+}
+
+static void
+SWITCHAUDIO_PlayDevice(_THIS)
+{
+    int current = -1;
+    for (int i = 0; i < 2; i++) {
+        if (this->hidden->buffer[i].state == AudioDriverWaveBufState_Free
+            || this->hidden->buffer[i].state == AudioDriverWaveBufState_Done) {
+            current = i;
+            break;
+        }
+    }
+
+    if (current >= 0) {
+        Uint8 *ptr = (Uint8 *) (this->hidden->pool + (current * this->spec.size));
+        memcpy(ptr, this->hidden->buffer_tmp, this->spec.size);
+        armDCacheFlush(ptr, this->spec.size);
+        audrvVoiceAddWaveBuf(&this->hidden->driver, 0, &this->hidden->buffer[current]);
+    }
+    else if (!audrvVoiceIsPlaying(&this->hidden->driver, 0)) {
+        audrvVoiceStart(&this->hidden->driver, 0);
+    }
+
+    audrvUpdate(&this->hidden->driver);
+
+    if (current >= 0) {
+        while (this->hidden->buffer[current].state != AudioDriverWaveBufState_Playing) {
+            audrvUpdate(&this->hidden->driver);
+            audrenWaitFrame();
+        }
+    }
+    else {
+        current = -1;
+        for (int i = 0; i < 2; i++) {
+            if (this->hidden->buffer[i].state == AudioDriverWaveBufState_Playing) {
+                current = i;
+                break;
+            }
+        }
+        while (this->hidden->buffer[current].state == AudioDriverWaveBufState_Playing) {
+            audrvUpdate(&this->hidden->driver);
+            audrenWaitFrame();
+        }
+    }
+}
+
+static void
+SWITCHAUDIO_WaitDevice(_THIS)
+{
+}
+
+static Uint8
+*SWITCHAUDIO_GetDeviceBuf(_THIS)
+{
+    return this->hidden->buffer_tmp;
+}
+
+static void
+SWITCHAUDIO_CloseDevice(_THIS)
+{
+    if (this->hidden->audr_driver) {
+        audrvClose(&this->hidden->driver);
+    }
+
+    if (this->hidden->audr_device) {
+        audrenExit();
+    }
+
+    if (this->hidden->buffer_tmp) {
+        free(this->hidden->buffer_tmp);
+    }
+
+    SDL_free(this->hidden);
+}
+
+static void
+SWITCHAUDIO_ThreadInit(_THIS)
+{
+
+}
+
+static int
+SWITCHAUDIO_Init(SDL_AudioDriverImpl *impl)
+{
+    impl->OpenDevice = SWITCHAUDIO_OpenDevice;
+    impl->PlayDevice = SWITCHAUDIO_PlayDevice;
+    impl->WaitDevice = SWITCHAUDIO_WaitDevice;
+    impl->GetDeviceBuf = SWITCHAUDIO_GetDeviceBuf;
+    impl->CloseDevice = SWITCHAUDIO_CloseDevice;
+    impl->ThreadInit = SWITCHAUDIO_ThreadInit;
+
+    impl->OnlyHasDefaultOutputDevice = 1;
+
+    return 1;
+}
+
+AudioBootStrap SWITCHAUDIO_bootstrap = {
+    "switch", "Nintendo Switch audio driver", SWITCHAUDIO_Init, 0
+};
+
+#endif /* SDL_AUDIO_DRIVER_SWITCH */
diff --git a/src/audio/switch/SDL_switchaudio.h b/src/audio/switch/SDL_switchaudio.h
new file mode 100644
index 000000000..f5e0340fb
--- /dev/null
+++ b/src/audio/switch/SDL_switchaudio.h
@@ -0,0 +1,41 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef SDL_switchaudio_h_
+#define SDL_switchaudio_h_
+
+#include <switch.h>
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the audio functions */
+#define _THIS   SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData
+{
+    AudioDriver driver;
+    AudioDriverWaveBuf buffer[2];
+    void *buffer_tmp;
+    void *pool;
+    bool audr_device;
+    bool audr_driver;
+};
+
+#endif /* SDL_switchaudio_h_ */
diff --git a/src/cpuinfo/SDL_cpuinfo.c b/src/cpuinfo/SDL_cpuinfo.c
index 9cecb4f16..1df492e07 100644
--- a/src/cpuinfo/SDL_cpuinfo.c
+++ b/src/cpuinfo/SDL_cpuinfo.c
@@ -880,7 +880,7 @@ SDL_GetSystemRAM(void)
 #endif
 #ifdef HAVE_SYSCTLBYNAME
         if (SDL_SystemRAM <= 0) {
-#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__SWITCH__)
 #ifdef HW_REALMEM
             int mib[2] = {CTL_HW, HW_REALMEM};
 #else
diff --git a/src/dynapi/SDL_dynapi.h b/src/dynapi/SDL_dynapi.h
index 764e5d978..988eb6341 100644
--- a/src/dynapi/SDL_dynapi.h
+++ b/src/dynapi/SDL_dynapi.h
@@ -57,6 +57,8 @@
 #define SDL_DYNAMIC_API 0
 #elif defined(__clang_analyzer__)
 #define SDL_DYNAMIC_API 0  /* Turn off for static analysis, so reports are more clear. */
+#elif defined(__SWITCH__) && __SWITCH__
+#define SDL_DYNAMIC_API 0  /* Probably not useful on switch. */
 #endif
 
 /* everyone else. This is where we turn on the API if nothing forced it off. */
diff --git a/src/joystick/SDL_gamecontrollerdb.h b/src/joystick/SDL_gamecontrollerdb.h
index 45379dabd..1061f6d64 100644
--- a/src/joystick/SDL_gamecontrollerdb.h
+++ b/src/joystick/SDL_gamecontrollerdb.h
@@ -670,6 +670,9 @@ static const char *s_ControllerMappings [] =
     "default,Standard Gamepad,a:b0,b:b1,back:b8,dpdown:b13,dpleft:b14,dpright:b15,dpup:b12,guide:b16,leftshoulder:b4,leftstick:b10,lefttrigger:b6,leftx:a0,lefty:a1,rightshoulder:b5,rightstick:b11,righttrigger:b7,rightx:a2,righty:a3,start:b9,x:b2,y:b3,",
 #endif
     "hidapi,*,a:b0,b:b1,back:b4,dpdown:b12,dpleft:b13,dpright:b14,dpup:b11,guide:b5,leftshoulder:b9,leftstick:b7,lefttrigger:a4,leftx:a0,lefty:a1,rightshoulder:b10,rightstick:b8,righttrigger:a5,rightx:a2,righty:a3,start:b6,x:b2,y:b3,",
+#if defined(SDL_JOYSTICK_SWITCH)
+    "53776974636820436F6E74726F6C6C65,Switch Controller,a:b1,b:b0,back:b11,dpdown:b15,dpleft:b12,dpright:b14,dpup:b13,leftshoulder:b6,leftstick:b4,lefttrigger:b8,leftx:a0,lefty:a1,rightshoulder:b7,rightstick:b5,righttrigger:b9,rightx:a2,righty:a3,start:b10,x:b3,y:b2,",
+#endif
     NULL
 };
 
diff --git a/src/joystick/SDL_joystick.c b/src/joystick/SDL_joystick.c
index 95aac9c6f..6784d0cba 100644
--- a/src/joystick/SDL_joystick.c
+++ b/src/joystick/SDL_joystick.c
@@ -68,6 +68,9 @@ static SDL_JoystickDriver *SDL_joystick_drivers[] = {
 #ifdef SDL_JOYSTICK_HAIKU
     &SDL_HAIKU_JoystickDriver,
 #endif
+#ifdef SDL_JOYSTICK_SWITCH
+    &SDL_SWITCH_JoystickDriver,
+#endif
 #ifdef SDL_JOYSTICK_USBHID  /* !!! FIXME: "USBHID" is a generic name, and doubly-confusing with HIDAPI next to it. This is the *BSD interface, rename this. */
     &SDL_BSD_JoystickDriver,
 #endif
diff --git a/src/joystick/SDL_sysjoystick.h b/src/joystick/SDL_sysjoystick.h
index 6eb8bf47e..71aef4c6b 100644
--- a/src/joystick/SDL_sysjoystick.h
+++ b/src/joystick/SDL_sysjoystick.h
@@ -153,6 +153,7 @@ extern SDL_JoystickDriver SDL_HIDAPI_JoystickDriver;
 extern SDL_JoystickDriver SDL_IOS_JoystickDriver;
 extern SDL_JoystickDriver SDL_LINUX_JoystickDriver;
 extern SDL_JoystickDriver SDL_WINDOWS_JoystickDriver;
+extern SDL_JoystickDriver SDL_SWITCH_JoystickDriver;
 
 #endif /* SDL_sysjoystick_h_ */
 
diff --git a/src/joystick/switch/SDL_sysjoystick.c b/src/joystick/switch/SDL_sysjoystick.c
new file mode 100644
index 000000000..c1a1199f1
--- /dev/null
+++ b/src/joystick/switch/SDL_sysjoystick.c
@@ -0,0 +1,230 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_JOYSTICK_SWITCH
+
+/* This is the dummy implementation of the SDL joystick API */
+
+#include "SDL_events.h"
+#include "../SDL_sysjoystick.h"
+
+#include <switch.h>
+
+#define JOYSTICK_COUNT 8
+
+typedef struct JoystickState
+{
+    HidControllerID id;
+    JoystickPosition l_pos;
+    JoystickPosition r_pos;
+    u64 buttons;
+} JoystickState;
+
+/* Current pad state */
+static JoystickState pad[JOYSTICK_COUNT];
+
+static HidControllerID pad_id[JOYSTICK_COUNT] = {
+        CONTROLLER_P1_AUTO, CONTROLLER_PLAYER_2,
+        CONTROLLER_PLAYER_3, CONTROLLER_PLAYER_4,
+        CONTROLLER_PLAYER_5, CONTROLLER_PLAYER_6,
+        CONTROLLER_PLAYER_7, CONTROLLER_PLAYER_8
+};
+
+static const HidControllerKeys pad_mapping[] = {
+        KEY_A, KEY_B, KEY_X, KEY_Y,
+        KEY_LSTICK, KEY_RSTICK,
+        KEY_L, KEY_R,
+        KEY_ZL, KEY_ZR,
+        KEY_PLUS, KEY_MINUS,
+        KEY_DLEFT, KEY_DUP, KEY_DRIGHT, KEY_DDOWN,
+        KEY_LSTICK_LEFT, KEY_LSTICK_UP, KEY_LSTICK_RIGHT, KEY_LSTICK_DOWN,
+        KEY_RSTICK_LEFT, KEY_RSTICK_UP, KEY_RSTICK_RIGHT, KEY_RSTICK_DOWN,
+        KEY_SL_LEFT, KEY_SR_LEFT, KEY_SL_RIGHT, KEY_SR_RIGHT
+};
+
+/* Function to scan the system for joysticks.
+ * It should return 0, or -1 on an unrecoverable fatal error.
+ */
+static int
+SWITCH_JoystickInit(void)
+{
+    for (int i = 0; i < JOYSTICK_COUNT; i++) {
+        pad[i].id = pad_id[i];
+    }
+
+    return JOYSTICK_COUNT;
+}
+
+static int
+SWITCH_JoystickGetCount(void)
+{
+    return JOYSTICK_COUNT;
+}
+
+static void
+SWITCH_JoystickDetect(void)
+{
+}
+
+/* Function to get the device-dependent name of a joystick */
+static const char *
+SWITCH_JoystickGetDeviceName(int device_index)
+{
+    return "Switch Controller";
+}
+
+static int
+SWITCH_JoystickGetDevicePlayerIndex(int device_index)
+{
+    return -1;
+}
+
+static void
+SWITCH_JoystickSetDevicePlayerIndex(int device_index, int player_index)
+{
+}
+
+static SDL_JoystickGUID
+SWITCH_JoystickGetDeviceGUID(int device_index)
+{
+    SDL_JoystickGUID guid;
+    /* the GUID is just the first 16 chars of the name for now */
+    const char *name = SWITCH_JoystickGetDeviceName(device_index);
+    SDL_zero(guid);
+    SDL_memcpy(&guid, name, SDL_min(sizeof(guid), SDL_strlen(name)));
+    return guid;
+}
+
+/* Function to perform the mapping from device index to the instance id for this index */
+static SDL_JoystickID
+SWITCH_JoystickGetDeviceInstanceID(int device_index)
+{
+    return device_index;
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the device index.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+static int
+SWITCH_JoystickOpen(SDL_Joystick *joystick, int device_index)
+{
+    joystick->nbuttons = sizeof(pad_mapping) / sizeof(*pad_mapping);
+    joystick->naxes = 4;
+    joystick->nhats = 0;
+    joystick->instance_id = device_index;
+
+    return 0;
+}
+
+static int
+SWITCH_JoystickRumble(SDL_Joystick * joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
+{
+    // TODO
+    return SDL_Unsupported();
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+static void
+SWITCH_JoystickUpdate(SDL_Joystick *joystick)
+{
+    u64 changed;
+    static JoystickState pad_old[JOYSTICK_COUNT];
+
+    int index = (int) SDL_JoystickInstanceID(joystick);
+    if (index > JOYSTICK_COUNT) {
+        return;
+    }
+
+    hidJoystickRead(&pad[index].l_pos, pad[index].id, JOYSTICK_LEFT);
+    hidJoystickRead(&pad[index].r_pos, pad[index].id, JOYSTICK_RIGHT);
+    pad[index].buttons = hidKeysHeld(pad[index].id);
+
+    // Axes
+    if (pad_old[index].l_pos.dx != pad[index].l_pos.dx) {
+        SDL_PrivateJoystickAxis(joystick, 0, (Sint16) pad[index].l_pos.dx);
+        pad_old[index].l_pos.dx = pad[index].l_pos.dx;
+    }
+    if (pad_old[index].l_pos.dy != pad[index].l_pos.dy) {
+        SDL_PrivateJoystickAxis(joystick, 1, (Sint16) -pad[index].l_pos.dy);
+        pad_old[index].l_pos.dy = -pad[index].l_pos.dy;
+    }
+    if (pad_old[index].r_pos.dx != pad[index].r_pos.dx) {
+        SDL_PrivateJoystickAxis(joystick, 2, (Sint16) pad[index].r_pos.dx);
+        pad_old[index].r_pos.dx = pad[index].r_pos.dx;
+    }
+    if (pad_old[index].r_pos.dy != pad[index].r_pos.dy) {
+        SDL_PrivateJoystickAxis(joystick, 3, (Sint16) -pad[index].r_pos.dy);
+        pad_old[index].r_pos.dy = -pad[index].r_pos.dy;
+    }
+
+    // Buttons
+    changed = pad_old[index].buttons ^ pad[index].buttons;
+    pad_old[index].buttons = pad[index].buttons;
+    if (changed) {
+        for (int i = 0; i < joystick->nbuttons; i++) {
+            if (changed & pad_mapping[i]) {
+                SDL_PrivateJoystickButton(
+                        joystick, (Uint8) i,
+                        (Uint8) ((pad[index].buttons & pad_mapping[i]) ? SDL_PRESSED : SDL_RELEASED));
+            }
+        }
+    }
+}
+
+/* Function to close a joystick after use */
+static void
+SWITCH_JoystickClose(SDL_Joystick *joystick)
+{
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+static void
+SWITCH_JoystickQuit(void)
+{
+}
+
+SDL_JoystickDriver SDL_SWITCH_JoystickDriver =
+{
+    SWITCH_JoystickInit,
+    SWITCH_JoystickGetCount,
+    SWITCH_JoystickDetect,
+    SWITCH_JoystickGetDeviceName,
+    SWITCH_JoystickGetDevicePlayerIndex,
+    SWITCH_JoystickSetDevicePlayerIndex,
+    SWITCH_JoystickGetDeviceGUID,
+    SWITCH_JoystickGetDeviceInstanceID,
+    SWITCH_JoystickOpen,
+    SWITCH_JoystickRumble,
+    SWITCH_JoystickUpdate,
+    SWITCH_JoystickClose,
+    SWITCH_JoystickQuit,
+};
+
+#endif /* SDL_JOYSTICK_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
\ No newline at end of file
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 9cc52af1a..34ad1ce8f 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -36,6 +36,8 @@
 #include "psp/SDL_systhread_c.h"
 #elif SDL_THREAD_STDCPP
 #include "stdcpp/SDL_systhread_c.h"
+#elif SDL_THREAD_SWITCH
+#include "switch/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/switch/SDL_syscond.c b/src/thread/switch/SDL_syscond.c
new file mode 100644
index 000000000..7fb3aa7e1
--- /dev/null
+++ b/src/thread/switch/SDL_syscond.c
@@ -0,0 +1,173 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include <switch.h>
+#include <threads.h>
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_SWITCH
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+
+struct SDL_cond
+{
+    cnd_t cnd;
+};
+
+struct SDL_mutex
+{
+    mtx_t mtx;
+};
+
+/* Create a condition variable */
+SDL_cond *
+SDL_CreateCond(void)
+{
+    SDL_cond *cond = NULL;
+
+    cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+    if (cond) {
+        int res = cnd_init(&cond->cnd);
+        if (res != thrd_success) {
+            printf("SDL_CreateCond::cnd_init failed: %i\n", res);
+        }
+    }
+    else {
+        SDL_OutOfMemory();
+    }
+    return (cond);
+}
+
+/* Destroy a condition variable */
+void
+SDL_DestroyCond(SDL_cond *cond)
+{
+    if (cond) {
+        cnd_destroy(&cond->cnd);
+        SDL_free(cond);
+    }
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int
+SDL_CondSignal(SDL_cond *cond)
+{
+    int res;
+
+    if (!cond) {
+        return SDL_SetError("Passed a NULL cond");
+    }
+
+    res = cnd_signal(&cond->cnd);
+    if (res != thrd_success) {
+        return SDL_SetError("SDL_CondSignal::cnd_signal failed: %i", res);
+    }
+
+    return 0;
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int
+SDL_CondBroadcast(SDL_cond *cond)
+{
+    int res;
+
+    if (!cond) {
+        return SDL_SetError("Passed a NULL cond");
+    }
+
+    res = cnd_broadcast(&cond->cnd);
+    if (res != thrd_success) {
+        return SDL_SetError("SDL_CondBroadcast::cnd_broadcast failed: %i", res);
+    }
+
+    return 0;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+   The mutex must be locked before entering this function!
+   The mutex is unlocked during the wait, and locked again after the wait.
+
+Typical use:
+
+Thread A:
+    SDL_LockMutex(lock);
+    while ( ! condition ) {
+        SDL_CondWait(cond, lock);
+    }
+    SDL_UnlockMutex(lock);
+
+Thread B:
+    SDL_LockMutex(lock);
+    ...
+    condition = true;
+    ...
+    SDL_CondSignal(cond);
+    SDL_UnlockMutex(lock);
+ */
+int
+SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+    struct timespec ts;
+    int res;
+
+    if (!cond || !mutex) {
+        return SDL_SetError("SDL_CondWaitTimeout: passed a NULL cond/mutex");
+    }
+
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_nsec += (long) (ms * 1E6);
+    res = cnd_timedwait(&cond->cnd, &mutex->mtx, &ts);
+    if (res == thrd_timedout) {
+        return SDL_MUTEX_TIMEDOUT;
+    } else if (res != thrd_success) {
+        return SDL_SetError("SDL_CondWaitTimeout::cnd_timedwait failed: %i", res);
+    }
+
+    return 0;
+}
+
+/* Wait on the condition variable forever */
+int
+SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+    int res;
+
+    if (!cond || !mutex) {
+        return SDL_SetError("SDL_CondWaitTimeout: passed a NULL cond/mutex");
+    }
+
+    res = cnd_wait(&cond->cnd, &mutex->mtx);
+    if (res != thrd_success) {
+        return SDL_SetError("SDL_CondWait::cnd_wait failed: %i", res);
+    }
+
+    return 0;
+}
+
+#endif /* SDL_THREAD_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/thread/switch/SDL_sysmutex.c b/src/thread/switch/SDL_sysmutex.c
new file mode 100644
index 000000000..ad61e8c35
--- /dev/null
+++ b/src/thread/switch/SDL_sysmutex.c
@@ -0,0 +1,86 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_SWITCH
+
+/* An implementation of mutexes */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_mutex
+{
+    mtx_t mtx;
+};
+
+/* Create a mutex */
+SDL_mutex *
+SDL_CreateMutex(void)
+{
+    SDL_mutex *mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+    if (mutex) {
+        mtx_init(&mutex->mtx, mtx_plain | mtx_recursive);
+    }
+    else {
+        SDL_OutOfMemory();
+    }
+
+    return mutex;
+}
+
+/* Free the mutex */
+void
+SDL_DestroyMutex(SDL_mutex *mutex)
+{
+    if (mutex) {
+        mtx_destroy(&mutex->mtx);
+        SDL_free(mutex);
+    }
+}
+
+/* Lock the mutex */
+int
+SDL_mutexP(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        return SDL_SetError("Passed a NULL mutex");
+    }
+
+    mtx_lock(&mutex->mtx);
+
+    return 0;
+}
+
+/* Unlock the mutex */
+int
+SDL_mutexV(SDL_mutex *mutex)
+{
+    if (mutex == NULL) {
+        return SDL_SetError("Passed a NULL mutex");
+    }
+
+    mtx_unlock(&mutex->mtx);
+
+    return 0;
+}
+
+#endif /* SDL_THREAD_SWITCH */
diff --git a/src/thread/switch/SDL_sysmutex_c.h b/src/thread/switch/SDL_sysmutex_c.h
new file mode 100644
index 000000000..307537fc9
--- /dev/null
+++ b/src/thread/switch/SDL_sysmutex_c.h
@@ -0,0 +1,22 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
diff --git a/src/thread/switch/SDL_syssem.c b/src/thread/switch/SDL_syssem.c
new file mode 100644
index 000000000..6a8d20701
--- /dev/null
+++ b/src/thread/switch/SDL_syssem.c
@@ -0,0 +1,172 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_SWITCH
+
+/* Semaphore functions for the SWITCH. */
+
+#include <stdio.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+
+struct SDL_semaphore
+{
+    Uint32 count;
+    Uint32 waiters_count;
+    SDL_mutex *count_lock;
+    SDL_cond *count_nonzero;
+};
+
+/* Create a semaphore */
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+    SDL_sem *sem;
+
+    sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+    if (!sem) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    sem->count = initial_value;
+    sem->waiters_count = 0;
+
+    sem->count_lock = SDL_CreateMutex();
+    sem->count_nonzero = SDL_CreateCond();
+    if (!sem->count_lock || !sem->count_nonzero) {
+        SDL_DestroySemaphore(sem);
+        return NULL;
+    }
+
+    return sem;
+}
+
+/* Free the semaphore */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+    if (sem) {
+        sem->count = 0xFFFFFFFF;
+        while (sem->waiters_count > 0) {
+            SDL_CondSignal(sem->count_nonzero);
+            SDL_Delay(10);
+        }
+        SDL_DestroyCond(sem->count_nonzero);
+        if (sem->count_lock) {
+            SDL_mutexP(sem->count_lock);
+            SDL_mutexV(sem->count_lock);
+            SDL_DestroyMutex(sem->count_lock);
+        }
+        SDL_free(sem);
+    }
+}
+
+/* TODO: This routine is a bit overloaded.
+ * If the timeout is 0 then just poll the semaphore; if it's SDL_MUTEX_MAXWAIT, pass
+ * NULL to sceKernelWaitSema() so that it waits indefinitely; and if the timeout
+ * is specified, convert it to microseconds. */
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    /* A timeout of 0 is an easy case */
+    if (timeout == 0) {
+        return SDL_SemTryWait(sem);
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    ++sem->waiters_count;
+    retval = 0;
+    while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT)) {
+        retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock, timeout);
+    }
+    --sem->waiters_count;
+    if (retval == 0) {
+        --sem->count;
+    }
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+    int retval;
+
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    retval = SDL_MUTEX_TIMEDOUT;
+    SDL_LockMutex(sem->count_lock);
+    if (sem->count > 0) {
+        --sem->count;
+        retval = 0;
+    }
+    SDL_UnlockMutex(sem->count_lock);
+
+    return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+/* Returns the current count of the semaphore */
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+    Uint32 value;
+
+    value = 0;
+    if (sem) {
+        SDL_LockMutex(sem->count_lock);
+        value = sem->count;
+        SDL_UnlockMutex(sem->count_lock);
+    }
+    return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    SDL_LockMutex(sem->count_lock);
+    if (sem->waiters_count > 0) {
+        SDL_CondSignal(sem->count_nonzero);
+    }
+    ++sem->count;
+    SDL_UnlockMutex(sem->count_lock);
+
+    return 0;
+}
+
+#endif /* SDL_THREAD_SWITCH */
diff --git a/src/thread/switch/SDL_systhread.c b/src/thread/switch/SDL_systhread.c
new file mode 100644
index 000000000..31e4904b1
--- /dev/null
+++ b/src/thread/switch/SDL_systhread.c
@@ -0,0 +1,90 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_THREAD_SWITCH
+
+/* SWITCH thread management routines for SDL */
+
+#include <stdio.h>
+#include <switch.h>
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+
+static int
+SDL_SYS_RunThread(void *data)
+{
+    SDL_RunThread(data);
+    return 0;
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+    int res = thrd_create(&thread->handle, SDL_SYS_RunThread, args);
+    if (res != thrd_success) {
+        return SDL_SetError("SDL_SYS_CreateThread failed: %i", res);
+    }
+
+    return 0;
+}
+
+void SDL_SYS_SetupThread(const char *name)
+{
+}
+
+SDL_threadID SDL_ThreadID(void)
+{
+    return (SDL_threadID) thrd_current();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+    if (thread) {
+        thrd_join(thread->handle, NULL);
+    }
+}
+
+void SDL_SYS_DetachThread(SDL_Thread *thread)
+{
+}
+
+int SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    Result res;
+
+    if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        res = svcSetThreadPriority(CUR_THREAD_HANDLE, 0x2B);
+    }
+    else {
+        // 0x3B = preemptive threading
+        res = svcSetThreadPriority(CUR_THREAD_HANDLE, 0x3B);
+    }
+
+    if(R_FAILED(res)) {
+        return SDL_SetError("SDL_SYS_SetThreadPriority failed: %i", res);
+    }
+
+    return 0;
+}
+
+#endif /* SDL_THREAD_SWITCH */
diff --git a/src/thread/switch/SDL_systhread_c.h b/src/thread/switch/SDL_systhread_c.h
new file mode 100644
index 000000000..892186e2c
--- /dev/null
+++ b/src/thread/switch/SDL_systhread_c.h
@@ -0,0 +1,25 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <switch.h>
+#include <threads.h>
+
+typedef thrd_t SYS_ThreadHandle;
diff --git a/src/thread/switch/SDL_systls.c b/src/thread/switch/SDL_systls.c
new file mode 100644
index 000000000..2472fbd60
--- /dev/null
+++ b/src/thread/switch/SDL_systls.c
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../SDL_thread_c.h"
+
+SDL_TLSData *
+SDL_SYS_GetTLSData(void)
+{
+    return SDL_Generic_GetTLSData();
+}
+
+int
+SDL_SYS_SetTLSData(SDL_TLSData *data)
+{
+    return SDL_Generic_SetTLSData(data);
+}
diff --git a/src/timer/switch/SDL_systimer.c b/src/timer/switch/SDL_systimer.c
new file mode 100644
index 000000000..f0a13a2bd
--- /dev/null
+++ b/src/timer/switch/SDL_systimer.c
@@ -0,0 +1,75 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2015 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifdef SDL_TIMER_SWITCH
+
+#include "SDL_timer.h"
+#include <switch.h>
+
+static bool started = false;
+static Uint64 start = 0;
+
+void
+SDL_TicksInit(void)
+{
+    if (started) {
+        return;
+    }
+
+    start = SDL_GetPerformanceCounter();
+    started = true;
+}
+
+void
+SDL_TicksQuit(void)
+{
+    started = false;
+}
+
+Uint32 SDL_GetTicks(void)
+{
+    if (!started) {
+        SDL_TicksInit();
+    }
+
+    return (Uint32) ((SDL_GetPerformanceCounter() - start) * 1000 / SDL_GetPerformanceFrequency());
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+    return armGetSystemTick();
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+    return armGetSystemTickFreq();
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+    svcSleepThread((Uint64) ms * 1000000);
+}
+
+#endif /* SDL_TIMER_SWITCH */
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 38ed97157..277db3703 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -430,6 +430,7 @@ extern VideoBootStrap VIVANTE_bootstrap;
 extern VideoBootStrap Emscripten_bootstrap;
 extern VideoBootStrap QNX_bootstrap;
 extern VideoBootStrap OFFSCREEN_bootstrap;
+extern VideoBootStrap SWITCH_bootstrap;
 
 extern SDL_VideoDevice *SDL_GetVideoDevice(void);
 extern int SDL_AddBasicVideoDisplay(const SDL_DisplayMode * desktop_mode);
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index de0bc1cbc..9be0210a5 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -112,6 +112,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_OFFSCREEN
     &OFFSCREEN_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_SWITCH
+	&SWITCH_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
     &DUMMY_bootstrap,
 #endif
@@ -1454,7 +1457,7 @@ SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags)
     }
 
     /* Some platforms have OpenGL enabled by default */
-#if (SDL_VIDEO_OPENGL && __MACOSX__) || __IPHONEOS__ || __ANDROID__ || __NACL__
+#if (SDL_VIDEO_OPENGL && __MACOSX__) || __IPHONEOS__ || __ANDROID__ || __NACL__ || __SWITCH__
     if (!_this->is_dummy && !(flags & SDL_WINDOW_VULKAN) && !SDL_IsVideoContextExternal()) {
         flags |= SDL_WINDOW_OPENGL;
     }
diff --git a/src/video/switch/SDL_switchkeyboard.c b/src/video/switch/SDL_switchkeyboard.c
new file mode 100644
index 000000000..0d8f7bc6b
--- /dev/null
+++ b/src/video/switch/SDL_switchkeyboard.c
@@ -0,0 +1,270 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include <switch.h>
+
+#include "SDL_events.h"
+#include "SDL_log.h"
+#include "SDL_switchvideo.h"
+#include "SDL_switchkeyboard.h"
+#include "../../events/SDL_keyboard_c.h"
+
+#define NUM_SCANCODES_SWITCH 160
+
+static uint8_t locks = 0;
+static bool keystate[NUM_SCANCODES_SWITCH] = { 0 };
+static const uint8_t switch_scancodes[NUM_SCANCODES_SWITCH] = {
+	KBD_A,
+	KBD_B,
+	KBD_C,
+	KBD_D,
+	KBD_E,
+	KBD_F,
+	KBD_G,
+	KBD_H,
+	KBD_I,
+	KBD_J,
+	KBD_K,
+	KBD_L,
+	KBD_M,
+	KBD_N,
+	KBD_O,
+	KBD_P,
+	KBD_Q,
+	KBD_R,
+	KBD_S,
+	KBD_T,
+	KBD_U,
+	KBD_V,
+	KBD_W,
+	KBD_X,
+	KBD_Y,
+	KBD_Z,
+	KBD_1,
+	KBD_2,
+	KBD_3,
+	KBD_4,
+	KBD_5,
+	KBD_6,
+	KBD_7,
+	KBD_8,
+	KBD_9,
+	KBD_0,
+	KBD_ENTER,
+	KBD_ESC,
+	KBD_BACKSPACE,
+	KBD_TAB,
+	KBD_SPACE,
+	KBD_MINUS,
+	KBD_EQUAL,
+	KBD_LEFTBRACE,
+	KBD_RIGHTBRACE,
+	KBD_BACKSLASH,
+	KBD_HASHTILDE,
+	KBD_SEMICOLON,
+	KBD_APOSTROPHE,
+	KBD_GRAVE,
+	KBD_COMMA,
+	KBD_DOT,
+	KBD_SLASH,
+	KBD_CAPSLOCK,
+	KBD_F1,
+	KBD_F2,
+	KBD_F3,
+	KBD_F4,
+	KBD_F5,
+	KBD_F6,
+	KBD_F7,
+	KBD_F8,
+	KBD_F9,
+	KBD_F10,
+	KBD_F11,
+	KBD_F12,
+	KBD_SYSRQ,
+	KBD_SCROLLLOCK,
+	KBD_PAUSE,
+	KBD_INSERT,
+	KBD_HOME,
+	KBD_PAGEUP,
+	KBD_DELETE,
+	KBD_END,
+	KBD_PAGEDOWN,
+	KBD_RIGHT,
+	KBD_LEFT,
+	KBD_DOWN,
+	KBD_UP,
+	KBD_NUMLOCK,
+	KBD_KPSLASH,
+	KBD_KPASTERISK,
+	KBD_KPMINUS,
+	KBD_KPPLUS,
+	KBD_KPENTER,
+	KBD_KP1,
+	KBD_KP2,
+	KBD_KP3,
+	KBD_KP4,
+	KBD_KP5,
+	KBD_KP6,
+	KBD_KP7,
+	KBD_KP8,
+	KBD_KP9,
+	KBD_KP0,
+	KBD_KPDOT,
+	KBD_102ND,
+	KBD_COMPOSE,
+	KBD_POWER,
+	KBD_KPEQUAL,
+	KBD_F13,
+	KBD_F14,
+	KBD_F15,
+	KBD_F16,
+	KBD_F17,
+	KBD_F18,
+	KBD_F19,
+	KBD_F20,
+	KBD_F21,
+	KBD_F22,
+	KBD_F23,
+	KBD_F24,
+	KBD_OPEN,
+	KBD_HELP,
+	KBD_PROPS,
+	KBD_FRONT,
+	KBD_STOP,
+	KBD_AGAIN,
+	KBD_UNDO,
+	KBD_CUT,
+	KBD_COPY,
+	KBD_PASTE,
+	KBD_FIND,
+	KBD_MUTE,
+	KBD_VOLUMEUP,
+	KBD_VOLUMEDOWN,
+	KBD_CAPSLOCK_ACTIVE,
+	KBD_NUMLOCK_ACTIVE,
+	KBD_SCROLLLOCK_ACTIVE,
+	KBD_KPCOMMA,
+	KBD_KPLEFTPAREN,
+	KBD_KPRIGHTPAREN,
+	KBD_LEFTCTRL,
+	KBD_LEFTSHIFT,
+	KBD_LEFTALT,
+	KBD_LEFTMETA,
+	KBD_RIGHTCTRL,
+	KBD_RIGHTSHIFT,
+	KBD_RIGHTALT,
+	KBD_RIGHTMETA,
+	KBD_MEDIA_PLAYPAUSE,
+	KBD_MEDIA_STOPCD,
+	KBD_MEDIA_PREVIOUSSONG,
+	KBD_MEDIA_NEXTSONG,
+	KBD_MEDIA_EJECTCD,
+	KBD_MEDIA_VOLUMEUP,
+	KBD_MEDIA_VOLUMEDOWN,
+	KBD_MEDIA_MUTE,
+	KBD_MEDIA_WWW,
+	KBD_MEDIA_BACK,
+	KBD_MEDIA_FORWARD,
+	KBD_MEDIA_STOP,
+	KBD_MEDIA_FIND,
+	KBD_MEDIA_SCROLLUP,
+	KBD_MEDIA_SCROLLDOWN,
+	KBD_MEDIA_EDIT,
+	KBD_MEDIA_SLEEP,
+	KBD_MEDIA_COFFEE,
+	KBD_MEDIA_REFRESH,
+	KBD_MEDIA_CALC
+};
+
+void
+SWITCH_InitKeyboard(void)
+{
+}
+
+void
+SWITCH_PollKeyboard(void)
+{
+	// We skip polling keyboard if no window is created
+	if (SDL_GetFocusWindow() == NULL)
+		return;
+
+	for (int i = 0; i < NUM_SCANCODES_SWITCH; i++) {
+
+		int keyCode = switch_scancodes[i];
+
+		if (hidKeyboardHeld(keyCode) && !keystate[i]) {
+			switch (keyCode) {
+				case SDL_SCANCODE_NUMLOCKCLEAR:
+					if (!(locks & 0x1)) {
+						SDL_SendKeyboardKey(SDL_PRESSED, keyCode);
+						locks |= 0x1;
+					} else {
+						SDL_SendKeyboardKey(SDL_RELEASED, keyCode);
+						locks &= ~0x1;
+					}
+					break;
+				case SDL_SCANCODE_CAPSLOCK:
+					if (!(locks & 0x2)) {
+						SDL_SendKeyboardKey(SDL_PRESSED, keyCode);
+						locks |= 0x2;
+					} else {
+						SDL_SendKeyboardKey(SDL_RELEASED, keyCode);
+						locks &= ~0x2;
+					}
+					break;
+				case SDL_SCANCODE_SCROLLLOCK:
+					if (!(locks & 0x4)) {
+						SDL_SendKeyboardKey(SDL_PRESSED, keyCode);
+						locks |= 0x4;
+					} else {
+						SDL_SendKeyboardKey(SDL_RELEASED, keyCode);
+						locks &= ~0x4;
+					}
+					break;
+				default:
+					SDL_SendKeyboardKey(SDL_PRESSED, keyCode);
+			}
+			keystate[i] = true;
+		} else if (!hidKeyboardHeld(keyCode) && keystate[i]) {
+			switch (keyCode) {
+				case SDL_SCANCODE_CAPSLOCK:
+				case SDL_SCANCODE_NUMLOCKCLEAR:
+				case SDL_SCANCODE_SCROLLLOCK:
+					break;
+				default:
+					SDL_SendKeyboardKey(SDL_RELEASED, keyCode);
+			}
+			keystate[i] = false;
+		}
+	}
+}
+
+void
+SWITCH_QuitKeyboard(void)
+{
+}
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchkeyboard.h b/src/video/switch/SDL_switchkeyboard.h
new file mode 100644
index 000000000..a8355db78
--- /dev/null
+++ b/src/video/switch/SDL_switchkeyboard.h
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_switchkeyboard_h
+#define _SDL_switchkeyboard_h
+
+#include "../../SDL_internal.h"
+
+/* Keyboard functions */
+extern void SWITCH_InitKeyboard(void);
+extern void SWITCH_PollKeyboard(void);
+extern void SWITCH_QuitKeyboard(void);
+
+#endif /* _SDL_switchkeyboard_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchmouse.c b/src/video/switch/SDL_switchmouse.c
new file mode 100644
index 000000000..02818a488
--- /dev/null
+++ b/src/video/switch/SDL_switchmouse.c
@@ -0,0 +1,114 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include <switch.h>
+
+#include "SDL_timer.h"
+#include "SDL_events.h"
+#include "SDL_log.h"
+#include "SDL_mouse.h"
+#include "SDL_switchvideo.h"
+#include "SDL_switchmouse_c.h"
+#include "../../events/SDL_mouse_c.h"
+
+static uint64_t prev_buttons = 0;
+static uint64_t last_timestamp = 0;
+const uint64_t mouse_read_interval = 15; // in ms
+
+static int
+SWITCH_SetRelativeMouseMode(SDL_bool enabled)
+{
+    return 0;
+}
+
+void 
+SWITCH_InitMouse(void)
+{
+    SDL_Mouse *mouse = SDL_GetMouse();
+
+    mouse->SetRelativeMouseMode = SWITCH_SetRelativeMouseMode;
+}
+
+void 
+SWITCH_PollMouse(void)
+{
+	SDL_Window *window = SDL_GetFocusWindow();
+	uint64_t buttons;
+	uint64_t changed_buttons;
+	MousePosition mouse_pos;
+	uint64_t timestamp;
+	int dx, dy;
+
+	// We skip polling mouse if no window is created
+	if (window == NULL)
+		return;
+
+	buttons = hidMouseButtonsHeld();
+	changed_buttons = buttons ^ prev_buttons;
+
+	if (changed_buttons & MOUSE_LEFT) {
+		if (prev_buttons & MOUSE_LEFT)
+			SDL_SendMouseButton(window, 0, SDL_RELEASED, SDL_BUTTON_LEFT);
+		else
+			SDL_SendMouseButton(window, 0, SDL_PRESSED, SDL_BUTTON_LEFT);
+	}
+	if (changed_buttons & MOUSE_RIGHT) {
+		if (prev_buttons & MOUSE_RIGHT)
+			SDL_SendMouseButton(window, 0, SDL_RELEASED, SDL_BUTTON_RIGHT);
+		else
+			SDL_SendMouseButton(window, 0, SDL_PRESSED, SDL_BUTTON_RIGHT);
+	}
+	if (changed_buttons & MOUSE_MIDDLE) {
+		if (prev_buttons & MOUSE_MIDDLE)
+			SDL_SendMouseButton(window, 0, SDL_RELEASED, SDL_BUTTON_MIDDLE);
+		else
+			SDL_SendMouseButton(window, 0, SDL_PRESSED, SDL_BUTTON_MIDDLE);
+	}
+
+	prev_buttons = buttons;
+
+	timestamp = SDL_GetTicks();
+
+	if (SDL_TICKS_PASSED(timestamp, last_timestamp + mouse_read_interval)) {
+		hidMouseRead(&mouse_pos);
+		// if hidMouseRead is called once per frame, a factor two on the velocities
+		// results in approximately the same mouse motion as reported by mouse_pos.x and mouse_pos.y
+		// but without the clamping to 1280 x 720
+		dx = mouse_pos.velocityX * 2;
+		dy = mouse_pos.velocityY * 2;
+		if (dx || dy) {
+			SDL_SendMouseMotion(window, 0, 1, dx, dy);
+		}
+		last_timestamp = timestamp;
+	}
+}
+
+void 
+SWITCH_QuitMouse(void)
+{
+}
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchmouse_c.h b/src/video/switch/SDL_switchmouse_c.h
new file mode 100644
index 000000000..c2bd2cfc0
--- /dev/null
+++ b/src/video/switch/SDL_switchmouse_c.h
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_switchmouse_h
+#define _SDL_switchmouse_h
+
+#include "../../SDL_internal.h"
+
+/* mouse functions */
+extern void SWITCH_InitMouse(void);
+extern void SWITCH_PollMouse(void);
+extern void SWITCH_QuitMouse(void);
+
+#endif /* _SDL_switchmouse_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchopengles.c b/src/video/switch/SDL_switchopengles.c
new file mode 100644
index 000000000..efed92328
--- /dev/null
+++ b/src/video/switch/SDL_switchopengles.c
@@ -0,0 +1,53 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+#include "SDL_log.h"
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include "SDL_video.h"
+#include "SDL_switchopengles.h"
+#include "SDL_switchvideo.h"
+
+/* EGL implementation of SDL OpenGL support */
+
+void
+SWITCH_GLES_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor)
+{
+    *mask = SDL_GL_CONTEXT_PROFILE_ES;
+    *major = 2;
+    *minor = 0;
+}
+
+int
+SWITCH_GLES_LoadLibrary(_THIS, const char *path)
+{
+    return SDL_EGL_LoadLibrary(_this, path, EGL_DEFAULT_DISPLAY, 0);
+}
+
+SDL_EGL_CreateContext_impl(SWITCH)
+SDL_EGL_MakeCurrent_impl(SWITCH)
+SDL_EGL_SwapWindow_impl(SWITCH)
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchopengles.h b/src/video/switch/SDL_switchopengles.h
new file mode 100644
index 000000000..3beb5eea7
--- /dev/null
+++ b/src/video/switch/SDL_switchopengles.h
@@ -0,0 +1,49 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#ifndef SDL_switchteopengles_h_
+#define SDL_switchteopengles_h_
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include "../SDL_sysvideo.h"
+#include "../SDL_egl_c.h"
+
+/* OpenGLES functions */
+#define SWITCH_GLES_GetAttribute SDL_EGL_GetAttribute
+#define SWITCH_GLES_GetProcAddress SDL_EGL_GetProcAddress
+#define SWITCH_GLES_UnloadLibrary SDL_EGL_UnloadLibrary
+#define SWITCH_GLES_SetSwapInterval SDL_EGL_SetSwapInterval
+#define SWITCH_GLES_GetSwapInterval SDL_EGL_GetSwapInterval
+#define SWITCH_GLES_DeleteContext SDL_EGL_DeleteContext
+
+extern int SWITCH_GLES_LoadLibrary(_THIS, const char *path);
+extern SDL_GLContext SWITCH_GLES_CreateContext(_THIS, SDL_Window *window);
+extern int SWITCH_GLES_SwapWindow(_THIS, SDL_Window *window);
+extern int SWITCH_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
+extern void SWITCH_GLES_DefaultProfileConfig(_THIS, int *mask, int *major, int *minor);
+extern void SWITCH_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h);
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+#endif /* SDL_switchteopengles_h_ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchtouch.c b/src/video/switch/SDL_switchtouch.c
new file mode 100644
index 000000000..5b9d3dc0a
--- /dev/null
+++ b/src/video/switch/SDL_switchtouch.c
@@ -0,0 +1,122 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include <switch.h>
+
+#include "SDL_events.h"
+#include "SDL_hints.h"
+#include "../../events/SDL_touch_c.h"
+#include "../../video/SDL_sysvideo.h"
+
+#define MAX_TOUCH 16
+
+typedef struct SwitchTouch
+{
+    SDL_FingerID id;
+    touchPosition position;
+} SwitchTouch;
+
+typedef struct TouchState
+{
+    SwitchTouch touch[MAX_TOUCH];
+    u32 count;
+} TouchState;
+
+TouchState touchState;
+
+TouchState touchState_old;
+
+void
+SWITCH_InitTouch(void)
+{
+    SDL_AddTouch((SDL_TouchID) 0, SDL_TOUCH_DEVICE_DIRECT, "Switch");
+    SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "0");
+}
+
+void
+SWITCH_QuitTouch(void)
+{
+
+}
+
+void
+SWITCH_PollTouch(void)
+{
+    SDL_Window *window = SDL_GetFocusWindow();
+    if (window == NULL) {
+        return;
+    }
+
+    memcpy(&touchState_old, &touchState, sizeof(touchState));
+
+    touchState.count = hidTouchCount();
+    if (touchState.count >= MAX_TOUCH) {
+        touchState.count = MAX_TOUCH - 1;
+    }
+
+    if (touchState.count > 0) {
+        for (u32 i = 0; i < touchState.count; i++) {
+
+            touchState.touch[i].id = i;
+            hidTouchRead(&touchState.touch[i].position, i);
+
+            // Send an initial touch
+            SDL_SendTouch(0, (SDL_FingerID) i, window, SDL_TRUE,
+                          (float) touchState.touch[i].position.px / 1280.0f,
+                          (float) touchState.touch[i].position.py / 720.0f, 1);
+
+            // Always send the motion
+            SDL_SendTouchMotion(0, (SDL_FingerID) i, window,
+                                (float) touchState.touch[i].position.px / 1280.0f,
+                                (float) touchState.touch[i].position.py / 720.0f, 1);
+        }
+    }
+
+    // some fingers might have been let go
+    if (touchState_old.count > 0) {
+
+        for (int i = 0; i < touchState_old.count; i++) {
+
+            int finger_up = 1;
+            if (touchState.count > 0) {
+                for (int j = 0; j < touchState.count; j++) {
+                    if (touchState.touch[j].id == touchState_old.touch[i].id) {
+                        finger_up = 0;
+                    }
+                }
+            }
+
+            if (finger_up == 1) {
+                // Finger released from screen
+                SDL_SendTouch((SDL_TouchID) 0, (SDL_FingerID) touchState_old.touch[i].id, window, SDL_FALSE,
+                              (float) touchState_old.touch[i].position.px / 1280.0f,
+                              (float) touchState_old.touch[i].position.py / 720.0f, 1);
+            }
+        }
+    }
+}
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchtouch.h b/src/video/switch/SDL_switchtouch.h
new file mode 100644
index 000000000..ac5908e39
--- /dev/null
+++ b/src/video/switch/SDL_switchtouch.h
@@ -0,0 +1,34 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_switchtouch_h
+#define _SDL_switchtouch_h
+
+#include "../../SDL_internal.h"
+
+/* Touch functions */
+extern void SWITCH_InitTouch(void);
+extern void SWITCH_QuitTouch(void);
+extern void SWITCH_PollTouch(void);
+
+#endif /* _SDL_switchtouch_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/src/video/switch/SDL_switchvideo.c b/src/video/switch/SDL_switchvideo.c
new file mode 100644
index 000000000..a39bf1835
--- /dev/null
+++ b/src/video/switch/SDL_switchvideo.c
@@ -0,0 +1,366 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include "../SDL_sysvideo.h"
+#include "../../render/SDL_sysrender.h"
+#include "../../events/SDL_keyboard_c.h"
+#include "../../events/SDL_mouse_c.h"
+#include "../../events/SDL_windowevents_c.h"
+
+#include "SDL_switchvideo.h"
+#include "SDL_switchopengles.h"
+#include "SDL_switchtouch.h"
+#include "SDL_switchkeyboard.h"
+#include "SDL_switchmouse_c.h"
+
+/* Currently only one window */
+static SDL_Window *switch_window = NULL;
+static AppletOperationMode operationMode;
+
+static int
+SWITCH_Available(void)
+{
+    return 1;
+}
+
+static void
+SWITCH_Destroy(SDL_VideoDevice *device)
+{
+    if (device != NULL) {
+        if(device->driverdata != NULL) {
+            SDL_free(device->driverdata);
+        }
+        SDL_free(device);
+    }
+}
+
+static SDL_VideoDevice *
+SWITCH_CreateDevice(int devindex)
+{
+    SDL_VideoDevice *device;
+
+    /* Initialize SDL_VideoDevice structure */
+    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
+    if (device == NULL) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    /* Setup amount of available displays */
+    device->num_displays = 0;
+
+    /* Set device free function */
+    device->free = SWITCH_Destroy;
+
+    /* Setup all functions which we can handle */
+    device->VideoInit = SWITCH_VideoInit;
+    device->VideoQuit = SWITCH_VideoQuit;
+    device->GetDisplayModes = SWITCH_GetDisplayModes;
+    device->SetDisplayMode = SWITCH_SetDisplayMode;
+    device->CreateSDLWindow = SWITCH_CreateWindow;
+    device->CreateSDLWindowFrom = SWITCH_CreateWindowFrom;
+    device->SetWindowTitle = SWITCH_SetWindowTitle;
+    device->SetWindowIcon = SWITCH_SetWindowIcon;
+    device->SetWindowPosition = SWITCH_SetWindowPosition;
+    device->SetWindowSize = SWITCH_SetWindowSize;
+    device->ShowWindow = SWITCH_ShowWindow;
+    device->HideWindow = SWITCH_HideWindow;
+    device->RaiseWindow = SWITCH_RaiseWindow;
+    device->MaximizeWindow = SWITCH_MaximizeWindow;
+    device->MinimizeWindow = SWITCH_MinimizeWindow;
+    device->RestoreWindow = SWITCH_RestoreWindow;
+    device->SetWindowGrab = SWITCH_SetWindowGrab;
+    device->DestroyWindow = SWITCH_DestroyWindow;
+
+    device->GL_LoadLibrary = SWITCH_GLES_LoadLibrary;
+    device->GL_GetProcAddress = SWITCH_GLES_GetProcAddress;
+    device->GL_UnloadLibrary = SWITCH_GLES_UnloadLibrary;
+    device->GL_CreateContext = SWITCH_GLES_CreateContext;
+    device->GL_MakeCurrent = SWITCH_GLES_MakeCurrent;
+    device->GL_SetSwapInterval = SWITCH_GLES_SetSwapInterval;
+    device->GL_GetSwapInterval = SWITCH_GLES_GetSwapInterval;
+    device->GL_SwapWindow = SWITCH_GLES_SwapWindow;
+    device->GL_DeleteContext = SWITCH_GLES_DeleteContext;
+    device->GL_DefaultProfileConfig = SWITCH_GLES_DefaultProfileConfig;
+
+    device->PumpEvents = SWITCH_PumpEvents;
+
+    return device;
+}
+
+VideoBootStrap SWITCH_bootstrap = {
+        "Switch",
+        "SDL2 video driver for Nintendo Switch",
+        SWITCH_Available,
+        SWITCH_CreateDevice
+};
+
+/*****************************************************************************/
+/* SDL Video and Display initialization/handling functions                   */
+/*****************************************************************************/
+int
+SWITCH_VideoInit(_THIS)
+{
+    SDL_VideoDisplay display;
+    SDL_DisplayMode current_mode;
+
+    SDL_zero(current_mode);
+    current_mode.w = 1920;
+    current_mode.h = 1080;
+    current_mode.refresh_rate = 60;
+    current_mode.format = SDL_PIXELFORMAT_RGBA8888;
+    current_mode.driverdata = NULL;
+
+    SDL_zero(display);
+    display.desktop_mode = current_mode;
+    display.current_mode = current_mode;
+    display.driverdata = NULL;
+    SDL_AddVideoDisplay(&display);
+
+    // init touch
+    SWITCH_InitTouch();
+    //init keyboard
+    SWITCH_InitKeyboard();
+    //init mouse
+    SWITCH_InitMouse();
+
+    return 0;
+}
+
+void
+SWITCH_VideoQuit(_THIS)
+{
+    if (_this->gl_config.driver_loaded) {
+        SDL_GL_UnloadLibrary();
+    }
+
+    // exit touch
+    SWITCH_QuitTouch();
+    //exit keyboard
+    SWITCH_QuitKeyboard();
+    //exit mouse
+    SWITCH_QuitMouse();
+}
+
+void
+SWITCH_GetDisplayModes(_THIS, SDL_VideoDisplay *display)
+{
+    SDL_DisplayMode mode;
+
+    // 1920x1080 RGBA8888, default mode
+    SDL_AddDisplayMode(display, &display->current_mode);
+
+    // 1280x720 RGBA8888
+    SDL_zero(mode);
+    mode.w = 1280;
+    mode.h = 720;
+    mode.refresh_rate = 60;
+    mode.format = SDL_PIXELFORMAT_RGBA8888;
+    SDL_AddDisplayMode(display, &mode);
+}
+
+int
+SWITCH_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode)
+{
+    SDL_WindowData *data = (SDL_WindowData *) SDL_GetFocusWindow()->driverdata;
+    SDL_GLContext ctx = SDL_GL_GetCurrentContext();
+    NWindow *nWindow = nwindowGetDefault();
+
+    if (data != NULL && data->egl_surface != EGL_NO_SURFACE) {
+        SDL_EGL_MakeCurrent(_this, NULL, NULL);
+        SDL_EGL_DestroySurface(_this, data->egl_surface);
+        nwindowSetDimensions(nWindow, mode->w, mode->h);
+        data->egl_surface = SDL_EGL_CreateSurface(_this, nWindow);
+        SDL_EGL_MakeCurrent(_this, data->egl_surface, ctx);
+    }
+
+    return 0;
+}
+
+int
+SWITCH_CreateWindow(_THIS, SDL_Window *window)
+{
+    Result rc;
+    SDL_WindowData *window_data = NULL;
+    NWindow *nWindow = NULL;
+
+    if (switch_window != NULL) {
+        return SDL_SetError("Switch only supports one window");
+    }
+
+    if (!_this->egl_data) {
+        return SDL_SetError("EGL not initialized");
+    }
+
+    window_data = (SDL_WindowData *) SDL_calloc(1, sizeof(SDL_WindowData));
+    if (window_data == NULL) {
+        return SDL_OutOfMemory();
+    }
+
+    nWindow = nwindowGetDefault();
+
+    rc = nwindowSetDimensions(nWindow, window->w, window->h);
+    if (R_FAILED(rc)) {
+        return SDL_SetError("Could not set NWindow dimensions: 0x%x", rc);
+    }
+
+    window_data->egl_surface = SDL_EGL_CreateSurface(_this, nWindow);
+    if (window_data->egl_surface == EGL_NO_SURFACE) {
+        return SDL_SetError("Could not create GLES window surface");
+    }
+
+    /* Setup driver data for this window */
+    window->driverdata = window_data;
+    switch_window = window;
+
+    /* starting operation mode */
+    operationMode = appletGetOperationMode();
+
+    /* One window, it always has focus */
+    SDL_SetMouseFocus(window);
+    SDL_SetKeyboardFocus(window);
+
+    /* Window has been successfully created */
+    return 0;
+}
+
+void
+SWITCH_DestroyWindow(_THIS, SDL_Window *window)
+{
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+
+    if (window == switch_window) {
+        if (data != NULL) {
+            if (data->egl_surface != EGL_NO_SURFACE) {
+                SDL_EGL_MakeCurrent(_this, NULL, NULL);
+                SDL_EGL_DestroySurface(_this, data->egl_surface);
+            }
+            if(window->driverdata != NULL) {
+                SDL_free(window->driverdata);
+                window->driverdata = NULL;
+            }
+        }
+        switch_window = NULL;
+    }
+}
+
+int
+SWITCH_CreateWindowFrom(_THIS, SDL_Window *window, const void *data)
+{
+    return -1;
+}
+void
+SWITCH_SetWindowTitle(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_SetWindowIcon(_THIS, SDL_Window *window, SDL_Surface *icon)
+{
+}
+void
+SWITCH_SetWindowPosition(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_SetWindowSize(_THIS, SDL_Window *window)
+{
+    u32 w = 0, h = 0;
+    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    SDL_GLContext ctx = SDL_GL_GetCurrentContext();
+    NWindow *nWindow = nwindowGetDefault();
+
+    if(window->w != w || window->h != h) {
+        if (data != NULL && data->egl_surface != EGL_NO_SURFACE) {
+            SDL_EGL_MakeCurrent(_this, NULL, NULL);
+            SDL_EGL_DestroySurface(_this, data->egl_surface);
+            nwindowSetDimensions(nWindow, window->w, window->h);
+            data->egl_surface = SDL_EGL_CreateSurface(_this, nWindow);
+            SDL_EGL_MakeCurrent(_this, data->egl_surface, ctx);
+        }
+    }
+}
+void
+SWITCH_ShowWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_HideWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_RaiseWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_MaximizeWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_MinimizeWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_RestoreWindow(_THIS, SDL_Window *window)
+{
+}
+void
+SWITCH_SetWindowGrab(_THIS, SDL_Window *window, SDL_bool grabbed)
+{
+}
+
+void
+SWITCH_PumpEvents(_THIS)
+{
+    AppletOperationMode om;
+
+    if (!appletMainLoop()) {
+        SDL_Event ev;
+        ev.type = SDL_QUIT;
+        SDL_PushEvent(&ev);
+        return;
+    }
+
+    hidScanInput();
+    SWITCH_PollTouch();
+    SWITCH_PollKeyboard();
+    SWITCH_PollMouse();
+
+    // handle docked / un-docked modes
+    // note that SDL_WINDOW_RESIZABLE is only possible in windowed mode,
+    // so we don't care about current fullscreen/windowed status
+    if(switch_window != NULL && switch_window->flags & SDL_WINDOW_RESIZABLE) {
+        om = appletGetOperationMode();
+        if(om != operationMode) {
+            operationMode = om;
+            if(operationMode == AppletOperationMode_Handheld) {
+                SDL_SetWindowSize(switch_window, 1280, 720);
+            } else {
+                SDL_SetWindowSize(switch_window, 1920, 1080);
+            }
+        }
+    }
+}
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
diff --git a/src/video/switch/SDL_switchvideo.h b/src/video/switch/SDL_switchvideo.h
new file mode 100644
index 000000000..d34643ed4
--- /dev/null
+++ b/src/video/switch/SDL_switchvideo.h
@@ -0,0 +1,62 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef __SDL_SWITCHVIDEO_H__
+#define __SDL_SWITCHVIDEO_H__
+
+#if SDL_VIDEO_DRIVER_SWITCH
+
+#include <switch.h>
+
+#include "../../SDL_internal.h"
+#include "../SDL_sysvideo.h"
+
+#include "SDL_egl.h"
+
+typedef struct SDL_WindowData
+{
+    EGLSurface egl_surface;
+} SDL_WindowData;
+
+int SWITCH_VideoInit(_THIS);
+void SWITCH_VideoQuit(_THIS);
+void SWITCH_GetDisplayModes(_THIS, SDL_VideoDisplay *display);
+int SWITCH_SetDisplayMode(_THIS, SDL_VideoDisplay *display, SDL_DisplayMode *mode);
+int SWITCH_CreateWindow(_THIS, SDL_Window *window);
+int SWITCH_CreateWindowFrom(_THIS, SDL_Window *window, const void *data);
+void SWITCH_SetWindowTitle(_THIS, SDL_Window *window);
+void SWITCH_SetWindowIcon(_THIS, SDL_Window *window, SDL_Surface *icon);
+void SWITCH_SetWindowPosition(_THIS, SDL_Window *window);
+void SWITCH_SetWindowSize(_THIS, SDL_Window *window);
+void SWITCH_ShowWindow(_THIS, SDL_Window *window);
+void SWITCH_HideWindow(_THIS, SDL_Window *window);
+void SWITCH_RaiseWindow(_THIS, SDL_Window *window);
+void SWITCH_MaximizeWindow(_THIS, SDL_Window *window);
+void SWITCH_MinimizeWindow(_THIS, SDL_Window *window);
+void SWITCH_RestoreWindow(_THIS, SDL_Window *window);
+void SWITCH_SetWindowGrab(_THIS, SDL_Window *window, SDL_bool grabbed);
+void SWITCH_DestroyWindow(_THIS, SDL_Window *window);
+void SWITCH_PumpEvents(_THIS);
+
+#endif /* SDL_VIDEO_DRIVER_SWITCH */
+#endif /* __SDL_SWITCHVIDEO_H__ */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff --git a/test/configure b/test/configure
index 24d27f36f..b9e8df026 100755
--- a/test/configure
+++ b/test/configure
@@ -640,6 +640,7 @@ infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -720,6 +721,7 @@ datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE}'
@@ -972,6 +974,15 @@ do
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1109,7 +1120,7 @@ fi
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1262,6 +1273,7 @@ Fine tuning of the installation directories:
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff --git a/test/testswitch.c b/test/testswitch.c
new file mode 100644
index 000000000..51012e481
--- /dev/null
+++ b/test/testswitch.c
@@ -0,0 +1,239 @@
+/*
+  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <switch.h>
+#include "SDL2/SDL.h"
+
+static SDL_DisplayMode modes[5];
+
+static int mode_count = 0, current_mode = 0;
+
+void print_info(SDL_Window *window, SDL_Renderer *renderer)
+{
+    int w, h;
+    SDL_DisplayMode mode;
+
+    SDL_GetWindowSize(window, &w, &h);
+    SDL_Log("window size: %i x %i\n", w, h);
+    SDL_GetRendererOutputSize(renderer, &w, &h);
+    SDL_Log("renderer size: %i x %i\n", w, h);
+
+    SDL_GetCurrentDisplayMode(0, &mode);
+    SDL_Log("display mode: %i x %i @ %i bpp (%s)",
+            mode.w, mode.h,
+            SDL_BITSPERPIXEL(mode.format),
+            SDL_GetPixelFormatName(mode.format));
+}
+
+void change_mode(SDL_Window *window)
+{
+    current_mode++;
+    if (current_mode == mode_count) {
+        current_mode = 0;
+    }
+
+    SDL_SetWindowDisplayMode(window, &modes[current_mode]);
+}
+
+void draw_rects(SDL_Renderer *renderer, int x, int y)
+{
+    // R
+    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
+    SDL_Rect r = {x, y, 64, 64};
+    SDL_RenderFillRect(renderer, &r);
+
+    // G
+    SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
+    SDL_Rect g = {x + 64, y, 64, 64};
+    SDL_RenderFillRect(renderer, &g);
+
+    // B
+    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);
+    SDL_Rect b = {x + 128, y, 64, 64};
+    SDL_RenderFillRect(renderer, &b);
+}
+
+int main(int argc, char *argv[])
+{
+    SDL_Event event;
+    SDL_Window *window;
+    SDL_Renderer *renderer;
+    int done = 0, x = 0, w = 0, h = 0;
+
+    // mandatory at least on switch, else gfx is not properly closed
+    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK) < 0) {
+        SDL_Log("SDL_Init: %s\n", SDL_GetError());
+        return -1;
+    }
+
+    /// create a window (OpenGL always enabled)
+    /// available switch SDL2 video modes :
+    /// 1920 x 1080 @ 32 bpp (SDL_PIXELFORMAT_RGBA8888)
+    /// 1280 x 720 @ 32 bpp (SDL_PIXELFORMAT_RGBA8888)
+    ///
+    /// SDL_SetWindowSize to change window size when SDL_WINDOW_FULLSCREEN is NOT used (preferably)
+    /// SDL_SetDisplayMode to change display size after SDL_CreateWindow called with SDL_WINDOW_FULLSCREEN
+    /// (this means window size won't change, you'll need to handle that, as any SDL2 app)
+    window = SDL_CreateWindow("sdl2_gles2", 0, 0, 1280, 720, 0);
+    if (!window) {
+        SDL_Log("SDL_CreateWindow: %s\n", SDL_GetError());
+        SDL_Quit();
+        return -1;
+    }
+
+    // create a renderer (OpenGL ES2)
+    renderer = SDL_CreateRenderer(window, 0, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
+    if (!renderer) {
+        SDL_Log("SDL_CreateRenderer: %s\n", SDL_GetError());
+        SDL_Quit();
+        return -1;
+    }
+
+    // pint some info about display/window/renderer
+    print_info(window, renderer);
+
+    // list available display modes
+    mode_count = SDL_GetNumDisplayModes(0);
+    for (int i = 0; i < mode_count; i++) {
+        SDL_DisplayMode mode;
+        SDL_GetDisplayMode(0, i, &mode);
+        modes[i] = mode;
+        SDL_Log("found display mode: %i x %i @ %i bpp (%s)",
+                mode.w, mode.h,
+                SDL_BITSPERPIXEL(mode.format),
+                SDL_GetPixelFormatName(mode.format));
+    }
+
+    // open CONTROLLER_PLAYER_1 and CONTROLLER_PLAYER_2
+    // when railed, both joycons are mapped to joystick #0,
+    // else joycons are individually mapped to joystick #0, joystick #1, ...
+    // https://github.com/devkitPro/SDL/blob/switch-sdl2/src/joystick/switch/SDL_sysjoystick.c#L45
+    for (int i = 0; i < 2; i++) {
+        if (SDL_JoystickOpen(i) == NULL) {
+            SDL_Log("SDL_JoystickOpen: %s\n", SDL_GetError());
+            SDL_Quit();
+            return -1;
+        }
+    }
+
+    while (!done) {
+
+        while (SDL_PollEvent(&event)) {
+
+            switch (event.type) {
+
+                case SDL_JOYAXISMOTION:
+                    SDL_Log("Joystick %d axis %d value: %d\n",
+                            event.jaxis.which,
+                            event.jaxis.axis, event.jaxis.value);
+                    break;
+
+                case SDL_JOYBUTTONDOWN:
+                    SDL_Log("Joystick %d button %d down\n",
+                            event.jbutton.which, event.jbutton.button);
+                    // https://github.com/devkitPro/SDL/blob/switch-sdl2/src/joystick/switch/SDL_sysjoystick.c#L52
+                    if (event.jbutton.which == 0) {
+                        if (event.jbutton.button == 0) {
+                            // joystick #0 down (A)
+                            change_mode(window);
+                            print_info(window, renderer);
+                        }
+                        else if (event.jbutton.button == 2) {
+                            // joystick #0 down (X)
+                            if (w == 1920) {
+                                SDL_SetWindowSize(window, 1280, 720);
+                            }
+                            else {
+                                SDL_SetWindowSize(window, 1920, 1080);
+                            }
+                            print_info(window, renderer);
+                        }
+                    }
+                    // joystick #0 down (B)
+                    if (event.jbutton.which == 0 && event.jbutton.button == 1) {
+                        done = 1;
+                    }
+                    break;
+
+                default:
+                    break;
+            }
+        }
+
+        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
+        SDL_RenderClear(renderer);
+
+        // Fill renderer bounds
+        SDL_SetRenderDrawColor(renderer, 111, 111, 111, 255);
+        SDL_GetWindowSize(window, &w, &h);
+        SDL_Rect f = {0, 0, w, h};
+        SDL_RenderFillRect(renderer, &f);
+
+        draw_rects(renderer, x, 0);
+        draw_rects(renderer, x, h - 64);
+
+        SDL_RenderPresent(renderer);
+
+        x++;
+        if (x > w - 192) {
+            x = 0;
+        }
+    }
+
+    SDL_DestroyRenderer(renderer);
+    SDL_DestroyWindow(window);
+    SDL_Quit();
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------------
+// nxlink support
+//-----------------------------------------------------------------------------
+
+#include <unistd.h>
+
+static int s_nxlinkSock = -1;
+
+static void initNxLink()
+{
+    if (R_FAILED(socketInitializeDefault()))
+        return;
+
+    s_nxlinkSock = nxlinkStdio();
+    if (s_nxlinkSock >= 0)
+        printf("printf output now goes to nxlink server\n");
+    else
+        socketExit();
+}
+
+static void deinitNxLink()
+{
+    if (s_nxlinkSock >= 0) {
+        close(s_nxlinkSock);
+        socketExit();
+        s_nxlinkSock = -1;
+    }
+}
+
+void userAppInit()
+{
+    initNxLink();
+}
+
+void userAppExit()
+{
+    deinitNxLink();
+}
