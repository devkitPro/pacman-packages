diff --git a/include/EGL/eglplatform.h b/include/EGL/eglplatform.h
index 939539e640e..1ce16b2e109 100644
--- a/include/EGL/eglplatform.h
+++ b/include/EGL/eglplatform.h
@@ -152,6 +152,12 @@ typedef void              *EGLNativeDisplayType;
 typedef khronos_uintptr_t  EGLNativePixmapType;
 typedef khronos_uintptr_t  EGLNativeWindowType;
 
+#elif defined(__SWITCH__)
+
+typedef void            *EGLNativeDisplayType;
+typedef khronos_uint8_t *EGLNativePixmapType;
+typedef void            *EGLNativeWindowType;
+
 #else
 #error "Platform not recognized"
 #endif
diff --git a/include/c11/threads.h b/include/c11/threads.h
index 3c3f23a8ab8..b512521535f 100644
--- a/include/c11/threads.h
+++ b/include/c11/threads.h
@@ -37,6 +37,32 @@
 
 #include "c99_compat.h" /* for `inline` */
 
+#ifdef _ISOC11_SOURCE
+#include <threads.h>
+#include <limits.h>
+
+/*-------------------- 7.25.7 Time functions --------------------*/
+// 7.25.6.1
+#ifndef HAVE_TIMESPEC_GET
+#include <sys/time.h>
+
+static inline int
+timespec_get(struct timespec *ts, int base)
+{
+    if (!ts) return 0;
+    if (base == TIME_UTC) {
+        struct timeval tv;
+        gettimeofday(&tv, NULL);
+        ts->tv_sec = tv.tv_sec;
+        ts->tv_nsec = tv.tv_usec * 1000;
+        return base;
+    }
+    return 0;
+}
+#endif
+
+#else
+
 /*---------------------------- types ----------------------------*/
 typedef void (*tss_dtor_t)(void*);
 typedef int (*thrd_start_t)(void*);
@@ -68,6 +94,6 @@ enum {
 #error Not supported on this platform.
 #endif
 
-
+#endif
 
 #endif /* EMULATED_THREADS_H_INCLUDED_ */
diff --git a/include/c99_alloca.h b/include/c99_alloca.h
index 5a3b8c19abb..5c4b6510e8d 100644
--- a/include/c99_alloca.h
+++ b/include/c99_alloca.h
@@ -35,7 +35,7 @@
 
 #  define alloca _alloca
 
-#elif defined(__sun) || defined(__CYGWIN__)
+#elif defined(__sun) || defined(__CYGWIN__) || defined(_GNU_SOURCE)
 
 #  include <alloca.h>
 
diff --git a/meson.build b/meson.build
index ba4fdb2a59f..0ed24fd6fcc 100644
--- a/meson.build
+++ b/meson.build
@@ -146,7 +146,7 @@ if dri_drivers.contains('auto')
       error('Unknown architecture @0@. Please pass -Ddri-drivers to set driver options. Patches gladly accepted to fix this.'.format(
             host_machine.cpu_family()))
     endif
-  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())
+  elif ['darwin', 'windows', 'cygwin', 'haiku', 'horizon'].contains(host_machine.system())
     # only swrast would make sense here, but gallium swrast is a much better default
     dri_drivers = []
   else
@@ -182,6 +182,8 @@ if gallium_drivers.contains('auto')
       error('Unknown architecture @0@. Please pass -Dgallium-drivers to set driver options. Patches gladly accepted to fix this.'.format(
             host_machine.cpu_family()))
     endif
+  elif ['horizon'].contains(host_machine.system())
+    gallium_drivers = ['nouveau']
   elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())
     gallium_drivers = ['swrast']
   else
@@ -234,7 +236,7 @@ if _vulkan_drivers.contains('auto')
       error('Unknown architecture @0@. Please pass -Dvulkan-drivers to set driver options. Patches gladly accepted to fix this.'.format(
             host_machine.cpu_family()))
     endif
-  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())
+  elif ['darwin', 'windows', 'cygwin', 'haiku', 'horizon'].contains(host_machine.system())
     # No vulkan driver supports windows or macOS currently
     _vulkan_drivers = []
   else
@@ -285,6 +287,8 @@ if _platforms.contains('auto')
     _platforms = ['haiku']
   elif host_machine.system() == 'windows'
     _platforms = ['windows']
+  elif ['horizon'].contains(host_machine.system())
+    _platforms = ['switch']
   else
     error('Unknown OS @0@. Please pass -Dplatforms to set platforms. Patches gladly accepted to fix this.'.format(
           host_machine.system()))
@@ -296,6 +300,7 @@ with_platform_x11 = _platforms.contains('x11')
 with_platform_wayland = _platforms.contains('wayland')
 with_platform_drm = _platforms.contains('drm')
 with_platform_haiku = _platforms.contains('haiku')
+with_platform_switch = _platforms.contains('switch')
 with_platform_surfaceless = _platforms.contains('surfaceless')
 with_platform_windows = _platforms.contains('windows')
 
@@ -320,7 +325,7 @@ with_glx = get_option('glx')
 if with_glx == 'auto'
   if with_dri
     with_glx = 'dri'
-  elif with_platform_haiku
+  elif with_platform_haiku or with_platform_switch
     with_glx = 'disabled'
   elif host_machine.system() == 'windows'
     with_glx = 'disabled'
@@ -363,11 +368,11 @@ _egl = get_option('egl')
 if _egl == 'auto'
   with_egl = (
     not ['darwin', 'windows'].contains(host_machine.system()) and
-    with_dri and with_shared_glapi and with_platforms
+    (with_dri or with_platform_switch) and with_shared_glapi and with_platforms
   )
 elif _egl == 'true'
-  if not with_dri
-    error('EGL requires dri')
+  if not (with_dri or with_platform_switch)
+    error('EGL requires dri or -Dplatforms=switch')
   elif not with_shared_glapi
     error('EGL requires shared-glapi')
   elif not with_platforms
@@ -791,6 +796,9 @@ endif
 if with_platform_haiku
   pre_args += '-DHAVE_HAIKU_PLATFORM'
 endif
+if with_platform_switch
+  pre_args += '-DHAVE_SWITCH_PLATFORM'
+endif
 
 if meson.version().version_compare('>=0.50')
   prog_python = import('python').find_installation('python3')
@@ -825,7 +833,7 @@ endif
 with_shader_cache = false
 _shader_cache = get_option('shader-cache')
 if _shader_cache != 'false'
-  if host_machine.system() == 'windows'
+  if ['windows','horizon'].contains(host_machine.system())
     if _shader_cache == 'true'
       error('Shader Cache does not currently work on Windows')
     endif
@@ -887,7 +895,7 @@ if cc.compiles('__uint128_t foo(void) { return 0; }',
 endif
 
 # TODO: this is very incomplete
-if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd'].contains(host_machine.system())
+if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'horizon'].contains(host_machine.system())
   pre_args += '-D_GNU_SOURCE'
 elif host_machine.system() == 'sunos'
   pre_args += '-D__EXTENSIONS__'
@@ -912,6 +920,10 @@ elif host_machine.system() == 'windows'
   endif
 endif
 
+if ['horizon'].contains(host_machine.system())
+  pre_args += '-D_ISOC11_SOURCE'
+endif
+
 # Check for generic C arguments
 c_args = []
 c_vis_args = []
@@ -1017,6 +1029,16 @@ else
     cpp_vis_args += '-fvisibility=hidden'
   endif
 
+  if host_machine.system() == 'horizon'
+    # Disable exceptions/rtti support on Switch in order to save on code size.
+    # Disable usage of __cxa_atexit since newlib only supports 32 atexit functions
+    # and mesa wants to register around 200 objects worth of global destructors.
+    cpp_args += [
+      '-fno-exceptions',
+      '-fno-rtti',
+      '-fno-use-cxa-atexit',
+    ]
+  endif
 endif
 
 # set linker arguments
@@ -1243,7 +1265,7 @@ ld_args_build_id = cc.get_supported_link_arguments('-Wl,--build-id=sha1')
 # check for dl support
 dep_dl = null_dep
 if not cc.has_function('dlopen')
-  dep_dl = cc.find_library('dl', required : host_machine.system() != 'windows')
+  dep_dl = cc.find_library('dl', required : not ['windows','horizon'].contains(host_machine.system()))
 endif
 if cc.has_function('dladdr', dependencies : dep_dl)
   # This is really only required for megadrivers
@@ -1265,42 +1287,50 @@ else
   dep_clock = cc.find_library('rt')
 endif
 
-# TODO: some of these may be conditional
-dep_zlib = dependency('zlib', version : '>= 1.2.3', fallback : ['zlib', 'zlib_dep'])
-pre_args += '-DHAVE_ZLIB'
-
-_zstd = get_option('zstd')
-if _zstd != 'false'
-  dep_zstd = dependency('libzstd', required : _zstd == 'true')
-  if dep_zstd.found()
-    pre_args += '-DHAVE_ZSTD'
-  endif
-else
-  dep_zstd = null_dep
-endif
+if host_machine.system() != 'horizon'
+  # TODO: some of these may be conditional
+  dep_zlib = dependency('zlib', version : '>= 1.2.3', fallback : ['zlib', 'zlib_dep'])
+  pre_args += '-DHAVE_ZLIB'
 
-dep_thread = dependency('threads')
-if dep_thread.found() and host_machine.system() != 'windows'
-  pre_args += '-DHAVE_PTHREAD'
-  if cc.has_function(
-      'pthread_setaffinity_np',
-      dependencies : dep_thread,
-      prefix : '#include <pthread.h>',
-      args : '-D_GNU_SOURCE')
-    pre_args += '-DHAVE_PTHREAD_SETAFFINITY'
+  _zstd = get_option('zstd')
+  if _zstd != 'false'
+    dep_zstd = dependency('libzstd', required : _zstd == 'true')
+    if dep_zstd.found()
+      pre_args += '-DHAVE_ZSTD'
+    endif
+  else
+    dep_zstd = null_dep
+  endif
+
+  dep_thread = dependency('threads')
+  if dep_thread.found() and host_machine.system() != 'windows'
+    pre_args += '-DHAVE_PTHREAD'
+    if cc.has_function(
+        'pthread_setaffinity_np',
+        dependencies : dep_thread,
+        prefix : '#include <pthread.h>',
+        args : '-D_GNU_SOURCE')
+      pre_args += '-DHAVE_PTHREAD_SETAFFINITY'
+    endif
+    if cc.has_function(
+        'pthread_setaffinity_np',
+        dependencies : dep_thread,
+        prefix : '#include <pthread_np.h>')
+      pre_args += '-DPTHREAD_SETAFFINITY_IN_NP_HEADER'
+    endif
   endif
-  if cc.has_function(
-      'pthread_setaffinity_np',
-      dependencies : dep_thread,
-      prefix : '#include <pthread_np.h>')
-    pre_args += '-DPTHREAD_SETAFFINITY_IN_NP_HEADER'
+  if host_machine.system() != 'windows'
+    dep_expat = dependency('expat', fallback : ['expat', 'expat_dep'])
+  else
+    dep_expat = null_dep
   endif
-endif
-if host_machine.system() != 'windows'
-  dep_expat = dependency('expat', fallback : ['expat', 'expat_dep'])
 else
+  dep_zlib = null_dep
+  dep_zstd = null_dep
+  dep_thread = null_dep
   dep_expat = null_dep
 endif
+
 # this only exists on linux so either this is linux and it will be found, or
 # it's not linux and wont
 dep_m = cc.find_library('m', required : false)
@@ -1419,7 +1449,7 @@ endif
 
 dep_llvm = null_dep
 with_llvm = false
-if _llvm != 'false'
+if _llvm != 'false' and not ['horizon'].contains(host_machine.system())
   dep_llvm = dependency(
     'llvm',
     version : _llvm_version,
diff --git a/meson_options.txt b/meson_options.txt
index ab43150669b..349ae5efd27 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -24,7 +24,7 @@ option(
   value : ['auto'],
   choices : [
     '', 'auto', 'x11', 'wayland', 'drm', 'surfaceless', 'haiku', 'android',
-    'windows',
+    'windows', 'switch',
   ],
   description : 'window systems to support. If this is set to `auto`, all platforms applicable will be enabled.'
 )
diff --git a/src/compiler/glsl/glsl_lexer.ll b/src/compiler/glsl/glsl_lexer.ll
index 7d7ee0c00ff..289e6da3e62 100644
--- a/src/compiler/glsl/glsl_lexer.ll
+++ b/src/compiler/glsl/glsl_lexer.ll
@@ -21,6 +21,7 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
+
 #include <ctype.h>
 #include <limits.h>
 #include "util/strtod.h"
@@ -174,7 +175,7 @@ literal_integer(char *text, int len, struct _mesa_glsl_parse_state *state,
    else
       lval->n = (int)value;
 
-   if (is_long && !is_uint && base == 10 && value > (uint64_t)LLONG_MAX + 1) {
+   if (is_long && !is_uint && base == 10 && value > (uint64_t)INT64_MAX + 1) {
       /* Tries to catch unintentionally providing a negative value. */
       _mesa_glsl_warning(lloc, state,
                          "signed literal value `%s' is interpreted as %lld",
diff --git a/src/egl/drivers/switch/egl_switch.c b/src/egl/drivers/switch/egl_switch.c
new file mode 100644
index 00000000000..af56ca6fcef
--- /dev/null
+++ b/src/egl/drivers/switch/egl_switch.c
@@ -0,0 +1,750 @@
+/*
+ * Mesa 3-D graphics library
+ *
+ * Copyright (C) 2014 Adrián Arroyo Calle <adrian.arroyocalle@gmail.com>
+ * Copyright (C) 2018 Jules Blok
+ * Copyright (C) 2018-2019 fincs
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "eglconfig.h"
+#include "eglcontext.h"
+#include "egldisplay.h"
+#include "egldriver.h"
+#include "eglcurrent.h"
+#include "egllog.h"
+#include "eglsurface.h"
+#include "eglimage.h"
+#include "egltypedefs.h"
+
+#include <switch.h>
+
+#include "target-helpers/inline_debug_helper.h"
+
+#include "nouveau/switch/nouveau_switch_public.h"
+
+#include "pipe/p_context.h"
+#include "pipe/p_screen.h"
+#include "pipe/p_state.h"
+
+#include "util/u_atomic.h"
+#include "util/u_box.h"
+#include "util/u_debug.h"
+#include "util/format/u_format.h"
+#include "util/u_inlines.h"
+#include "util/u_memory.h"
+
+#include "state_tracker/st_api.h"
+#include "state_tracker/st_gl_api.h"
+#include "state_tracker/drm_driver.h"
+
+#include "mapi/glapi/glapi.h"
+
+#define NUM_BUFFERS 3
+
+#ifdef DEBUG
+#	define TRACE(x...) _eglLog(_EGL_DEBUG, "egl_switch: " x)
+#	define CALLED() TRACE("CALLED: %s\n", __PRETTY_FUNCTION__)
+#else
+#	define TRACE(x...)
+#  define CALLED()
+#endif
+#define ERROR(x...) _eglLog(_EGL_FATAL, "egl_switch: " x)
+
+_EGL_DRIVER_STANDARD_TYPECASTS(switch_egl)
+
+struct switch_egl_display
+{
+    struct st_manager *stmgr;
+    struct st_api *stapi;
+};
+
+struct switch_egl_config
+{
+    _EGLConfig base;
+    struct st_visual stvis;
+};
+
+struct switch_egl_context
+{
+    _EGLContext base;
+    struct st_context_iface *stctx;
+};
+
+struct switch_egl_surface
+{
+    _EGLSurface base;
+    struct st_framebuffer_iface *stfbi;
+    struct pipe_resource *attachments[ST_ATTACHMENT_COUNT];
+
+    NWindow* nw;
+    s32 cur_slot;
+    struct pipe_resource *buffers[NUM_BUFFERS];
+    NvFence fences[NUM_BUFFERS];
+};
+
+struct switch_framebuffer
+{
+   struct st_framebuffer_iface base;
+   struct switch_egl_display* display;
+   struct switch_egl_surface* surface;
+   struct pipe_resource template;
+};
+
+static inline struct switch_framebuffer *
+switch_framebuffer(struct st_framebuffer_iface *stfbi)
+{
+    return (struct switch_framebuffer *)stfbi;
+}
+
+//-----------------------------------------------------------------------------
+// switch_framebuffer methods
+//-----------------------------------------------------------------------------
+
+static uint32_t drifb_ID = 0;
+
+// Called via st_manager_flush_frontbuffer. Users of this function include:
+// - st_context_flush with ST_FLUSH_FRONT
+// - glFlush
+// - glFinish
+// We don't support rendering to the front buffer, so our implementation is dummy.
+static bool
+switch_st_framebuffer_flush_front(struct st_context_iface *stctx, struct st_framebuffer_iface *stfbi, enum st_attachment_type statt)
+{
+    return true;
+}
+
+// Called via st_framebuffer_validate.
+static bool
+switch_st_framebuffer_validate(struct st_context_iface *stctx, struct st_framebuffer_iface *stfbi,
+                   const enum st_attachment_type *statts, unsigned count, struct pipe_resource **out)
+{
+    struct switch_framebuffer *fb = switch_framebuffer(stfbi);
+    struct switch_egl_surface *surface = fb->surface;
+    struct pipe_screen *screen = stfbi->state_manager->screen;
+    enum st_attachment_type i;
+    CALLED();
+
+    for (i = 0; i < count; i++)
+    {
+        struct pipe_resource* res = surface->attachments[statts[i]];
+        if (!res)
+        {
+            switch (statts[i])
+            {
+                case ST_ATTACHMENT_BACK_LEFT:
+                {
+                    Result rc = nwindowDequeueBuffer(surface->nw, &surface->cur_slot, NULL);
+                    if (R_FAILED(rc)) fatalThrow(rc);
+
+                    // Use the dequeued buffer as the back buffer
+                    res = surface->buffers[surface->cur_slot];
+                    break;
+                }
+                case ST_ATTACHMENT_DEPTH_STENCIL:
+                case ST_ATTACHMENT_ACCUM:
+                {
+                    // Configure format/bind parameters
+                    if (statts[i] == ST_ATTACHMENT_DEPTH_STENCIL)
+                    {
+                        fb->template.format = stfbi->visual->depth_stencil_format;
+                        fb->template.bind = PIPE_BIND_DEPTH_STENCIL;
+                    } else if (statts[i] == ST_ATTACHMENT_ACCUM)
+                    {
+                        fb->template.format = stfbi->visual->accum_format;
+                        fb->template.bind = PIPE_BIND_RENDER_TARGET;
+                    }
+
+                    // Create the requested resource
+                    res = screen->resource_create(screen, &fb->template);
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            // Register the attachment for future calls
+            surface->attachments[statts[i]] = res;
+        }
+        pipe_resource_reference(&out[i], res);
+    }
+
+    return true;
+}
+
+// Called via st_manager_flush_swapbuffers, which itself is only used during glFinish.
+// We don't actually want to swap the buffers during glFinish, so our implementation is dummy.
+static bool
+switch_st_framebuffer_flush_swapbuffers(struct st_context_iface *stctx, struct st_framebuffer_iface *stfbi)
+{
+    return true;
+}
+
+//-----------------------------------------------------------------------------
+// EGL driver methods
+//-----------------------------------------------------------------------------
+
+static void
+switch_egl_surface_cleanup(struct switch_egl_surface *surface)
+{
+    u32 i;
+
+    for (i = 0; i < ST_ATTACHMENT_COUNT; i ++)
+    {
+        if (i == ST_ATTACHMENT_FRONT_LEFT || i == ST_ATTACHMENT_BACK_LEFT)
+            continue;
+        pipe_resource_reference(&surface->attachments[i], NULL);
+    }
+
+    if (surface->nw)
+    {
+        if (surface->cur_slot >= 0)
+            nwindowCancelBuffer(surface->nw, surface->cur_slot, NULL);
+        nwindowReleaseBuffers(surface->nw);
+    }
+
+    for (i = 0; i < NUM_BUFFERS; i ++)
+        pipe_resource_reference(&surface->buffers[i], NULL);
+
+    if (surface->stfbi)
+        free(surface->stfbi);
+
+    free(surface);
+}
+
+// Called via eglCreateWindowSurface(), drv->API.CreateWindowSurface().
+static _EGLSurface *
+switch_create_window_surface(_EGLDriver *drv, _EGLDisplay *dpy,
+    _EGLConfig *conf, void *native_window, const EGLint *attrib_list)
+{
+    struct switch_egl_surface *surface;
+    struct switch_framebuffer *fb;
+    struct switch_egl_display *display = switch_egl_display(dpy);
+    struct switch_egl_config *config = switch_egl_config(conf);
+    u32 width, height, i;
+    CALLED();
+
+    surface = (struct switch_egl_surface*) calloc(1, sizeof (*surface));
+    if (!surface)
+    {
+        _eglError(EGL_BAD_ALLOC, "switch_create_window_surface: failed to allocate switch_egl_surface");
+        return NULL;
+    }
+
+    if (!_eglInitSurface(&surface->base, dpy, EGL_WINDOW_BIT, conf, attrib_list, native_window))
+        goto cleanup;
+
+    fb = (struct switch_framebuffer *) calloc(1, sizeof (*fb));
+    if (!fb)
+    {
+        _eglError(EGL_BAD_ALLOC, "switch_create_window_surface: failed to allocate switch_framebuffer");
+        goto cleanup;
+    }
+
+    // Use the specified native window, and check its validity
+    surface->nw = (NWindow*)native_window;
+    if (!nwindowIsValid(surface->nw))
+    {
+        _eglError(EGL_BAD_NATIVE_WINDOW, "switch_create_window_surface: not a valid native window reference");
+        goto cleanup;
+    }
+
+    // Allocate framebuffers and attach them to the native window
+    nwindowGetDimensions(surface->nw, &width, &height);
+    fb->display = display;
+    fb->surface = surface;
+    fb->template.target = PIPE_TEXTURE_RECT;
+    fb->template.format = config->stvis.color_format;
+    fb->template.width0 = (u16)width;
+    fb->template.height0 = (u16)height;
+    fb->template.depth0 = 1;
+    fb->template.array_size = 1;
+    fb->template.usage = PIPE_USAGE_DEFAULT;
+    fb->template.bind = PIPE_BIND_RENDER_TARGET;
+    for (i = 0; i < NUM_BUFFERS; i ++)
+    {
+        // Allocate a framebuffer
+        surface->fences[i].id = UINT32_MAX;
+        surface->buffers[i] = display->stmgr->screen->resource_create(display->stmgr->screen, &fb->template);
+        if (!surface->buffers[i])
+        {
+            _eglError(EGL_BAD_ALLOC, "switch_create_window_surface: failed to allocate framebuffers");
+            goto cleanup;
+        }
+
+        // Retrieve the native graphic buffer struct associated with this framebuffer
+        NvGraphicBuffer grbuf;
+        int err = nouveau_switch_resource_get_buffer(surface->buffers[i], &grbuf);
+        if (err != 0)
+        {
+            _eglError(EGL_BAD_ALLOC, "switch_create_window_surface: nouveau_switch_resource_get_buffer failed");
+            goto cleanup;
+        }
+
+        // Attach the framebuffer to the native window
+        Result rc = nwindowConfigureBuffer(surface->nw, i, &grbuf);
+        if (R_FAILED(rc)) fatalThrow(rc);
+    }
+
+    surface->stfbi = &fb->base;
+    surface->cur_slot = -1;
+
+    // Setup the st_framebuffer_iface
+    fb->base.visual = &config->stvis;
+    fb->base.flush_front = switch_st_framebuffer_flush_front;
+    fb->base.validate = switch_st_framebuffer_validate;
+    fb->base.flush_swapbuffers = switch_st_framebuffer_flush_swapbuffers;
+    p_atomic_set(&fb->base.stamp, 0);
+    fb->base.ID = p_atomic_inc_return(&drifb_ID);
+    fb->base.state_manager = display->stmgr;
+
+    return &surface->base;
+
+cleanup:
+    switch_egl_surface_cleanup(surface);
+    return NULL;
+}
+
+
+static _EGLSurface *
+switch_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
+    _EGLConfig *conf, void *native_pixmap, const EGLint *attrib_list)
+{
+    CALLED();
+    return NULL;
+}
+
+
+static _EGLSurface *
+switch_create_pbuffer_surface(_EGLDriver *drv, _EGLDisplay *disp,
+    _EGLConfig *conf, const EGLint *attrib_list)
+{
+    CALLED();
+    return NULL;
+}
+
+
+static EGLBoolean
+switch_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
+{
+    struct switch_egl_surface* surface = switch_egl_surface(surf);
+    CALLED();
+
+    if (_eglPutSurface(surf))
+        switch_egl_surface_cleanup(surface);
+
+    return EGL_TRUE;
+}
+
+
+static EGLBoolean
+switch_add_config(_EGLDisplay *dpy, EGLint *id, enum pipe_format colorfmt, enum pipe_format depthfmt)
+{
+    CALLED();
+
+    struct switch_egl_config* conf;
+    conf = (struct switch_egl_config*) calloc(1, sizeof (*conf));
+    if (!conf)
+        return _eglError(EGL_BAD_ALLOC, "switch_add_config failed to alloc");
+
+    TRACE("Initializing config\n");
+    _eglInitConfig(&conf->base, dpy, ++*id);
+
+    // General configuration
+    conf->base.NativeRenderable = EGL_TRUE;
+    conf->base.SurfaceType = EGL_WINDOW_BIT; // we only support creating window surfaces
+    conf->base.RenderableType = EGL_OPENGL_BIT | EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENGL_ES3_BIT_KHR;
+    conf->base.Conformant = conf->base.RenderableType;
+    conf->base.MinSwapInterval = 0;
+    conf->base.MaxSwapInterval = INT32_MAX;
+
+    // Color buffer configuration
+    conf->base.RedSize    = util_format_get_component_bits(colorfmt, UTIL_FORMAT_COLORSPACE_RGB, 0);
+    conf->base.GreenSize  = util_format_get_component_bits(colorfmt, UTIL_FORMAT_COLORSPACE_RGB, 1);
+    conf->base.BlueSize   = util_format_get_component_bits(colorfmt, UTIL_FORMAT_COLORSPACE_RGB, 2);
+    conf->base.AlphaSize  = util_format_get_component_bits(colorfmt, UTIL_FORMAT_COLORSPACE_RGB, 3);
+    conf->base.BufferSize = conf->base.RedSize+conf->base.GreenSize+conf->base.BlueSize+conf->base.AlphaSize;
+
+    // Depth/stencil buffer configuration
+    if (depthfmt != PIPE_FORMAT_NONE) {
+        conf->base.DepthSize   = util_format_get_component_bits(depthfmt, UTIL_FORMAT_COLORSPACE_ZS, 0);
+        conf->base.StencilSize = util_format_get_component_bits(depthfmt, UTIL_FORMAT_COLORSPACE_ZS, 1);
+    }
+
+    // Visual
+    conf->stvis.buffer_mask = ST_ATTACHMENT_FRONT_LEFT_MASK | ST_ATTACHMENT_BACK_LEFT_MASK;
+    conf->stvis.color_format = colorfmt;
+    conf->stvis.depth_stencil_format = depthfmt;
+    conf->stvis.accum_format = PIPE_FORMAT_R16G16B16A16_FLOAT;
+    conf->stvis.render_buffer = ST_ATTACHMENT_BACK_LEFT_MASK;
+
+    if (!_eglValidateConfig(&conf->base, EGL_FALSE)) {
+        _eglLog(_EGL_DEBUG, "Switch: failed to validate config");
+        free(conf);
+        return EGL_FALSE;
+    }
+
+    _eglLinkConfig(&conf->base);
+    return EGL_TRUE;
+}
+
+
+static EGLBoolean
+switch_add_configs_for_visuals(_EGLDisplay *dpy)
+{
+    CALLED();
+
+    // List of supported color buffer formats
+    static const enum pipe_format colorfmts[] = {
+        PIPE_FORMAT_R8G8B8A8_UNORM,
+        //PIPE_FORMAT_R8G8B8X8_UNORM,
+        //PIPE_FORMAT_B5G6R5_UNORM,
+    };
+
+    // List of supported depth buffer formats
+    static const enum pipe_format depthfmts[] = {
+        PIPE_FORMAT_NONE,
+        PIPE_FORMAT_S8_UINT,
+        PIPE_FORMAT_Z16_UNORM,
+        PIPE_FORMAT_Z24X8_UNORM,
+        PIPE_FORMAT_Z24_UNORM_S8_UINT,
+        PIPE_FORMAT_Z32_FLOAT,
+        PIPE_FORMAT_Z32_FLOAT_S8X24_UINT,
+    };
+
+    // Add all combinations of color/depth buffer formats
+    EGLint config_id = 0;
+    EGLint i, j;
+    for (i = 0; i < sizeof(colorfmts)/sizeof(colorfmts[0]); i ++) {
+        for (j = 0; j < sizeof(depthfmts)/sizeof(depthfmts[0]); j ++) {
+            EGLBoolean rc = switch_add_config(dpy, &config_id, colorfmts[i], depthfmts[j]);
+            if (!rc)
+                return rc;
+        }
+    }
+
+    return EGL_TRUE;
+}
+
+// Called from st_api_create_context. This is only ever used for detecting
+// whether the ST_MANAGER_BROKEN_INVALIDATE workaround is required.
+static int
+switch_st_get_param(struct st_manager *stmgr, enum st_manager_param param)
+{
+    return 0;
+}
+
+static EGLBoolean
+switch_initialize(_EGLDriver *drv, _EGLDisplay *dpy)
+{
+    struct switch_egl_display *display;
+    struct st_manager *stmgr;
+    struct pipe_screen *screen;
+    CALLED();
+
+    if (!switch_add_configs_for_visuals(dpy))
+        return EGL_FALSE;
+
+    display = (struct switch_egl_display*) calloc(1, sizeof (*display));
+    if (!display) {
+        _eglError(EGL_BAD_ALLOC, "switch_initialize");
+        return EGL_FALSE;
+    }
+    dpy->DriverData = display;
+    dpy->Version = 14;
+
+    dpy->ClientAPIs = 0;
+    if (_eglIsApiValid(EGL_OPENGL_API))
+        dpy->ClientAPIs |= EGL_OPENGL_BIT;
+    if (_eglIsApiValid(EGL_OPENGL_ES_API))
+        dpy->ClientAPIs |= EGL_OPENGL_ES_BIT | EGL_OPENGL_ES2_BIT | EGL_OPENGL_ES3_BIT_KHR;
+
+    dpy->Extensions.KHR_create_context = EGL_TRUE;
+    dpy->Extensions.KHR_surfaceless_context = EGL_TRUE;
+
+    stmgr = CALLOC_STRUCT(st_manager);
+    if (!stmgr) {
+        _eglError(EGL_BAD_ALLOC, "switch_initialize");
+        return EGL_FALSE;
+    }
+
+    stmgr->get_param = switch_st_get_param;
+
+    // Create nouveau screen
+    TRACE("Creating nouveau screen\n");
+    screen = nouveau_switch_screen_create();
+    if (!screen)
+    {
+        TRACE("Failed to create nouveau screen\n");
+        return EGL_FALSE;
+    }
+
+    // Inject optional trace/debug/etc wrappers
+    TRACE("Wrapping screen\n");
+    stmgr->screen = debug_screen_wrap(screen);
+
+    display->stmgr = stmgr;
+    display->stapi = st_gl_api_create();
+    return EGL_TRUE;
+}
+
+
+static EGLBoolean
+switch_terminate(_EGLDriver* drv, _EGLDisplay* dpy)
+{
+    struct switch_egl_display *display = switch_egl_display(dpy);
+    CALLED();
+
+    // Release all non-current Context/Surfaces
+    _eglReleaseDisplayResources(drv, dpy);
+
+    _eglCleanupDisplay(dpy);
+
+    display->stapi->destroy(display->stapi);
+
+    display->stmgr->screen->destroy(display->stmgr->screen);
+    free(display->stmgr);
+    free(display);
+
+    return EGL_TRUE;
+}
+
+
+static _EGLContext*
+switch_create_context(_EGLDriver *drv, _EGLDisplay *dpy, _EGLConfig *conf,
+    _EGLContext *share_list, const EGLint *attrib_list)
+{
+    struct switch_egl_context *context;
+    struct switch_egl_display *display = switch_egl_display(dpy);
+    struct switch_egl_config *config = switch_egl_config(conf);
+    CALLED();
+
+    context = (struct switch_egl_context*) calloc(1, sizeof (*context));
+    if (!context) {
+        _eglError(EGL_BAD_ALLOC, "switch_create_context");
+        return NULL;
+    }
+
+    if (!_eglInitContext(&context->base, dpy, conf, attrib_list))
+        goto cleanup;
+
+    struct st_context_attribs attribs;
+    memset(&attribs, 0, sizeof(attribs));
+
+    attribs.major = context->base.ClientMajorVersion;
+    attribs.minor = context->base.ClientMinorVersion;
+    attribs.visual = config->stvis;
+
+    switch (eglQueryAPI()) {
+        case EGL_OPENGL_API:
+            switch (context->base.Profile) {
+                case EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR:
+                    /* There are no profiles before OpenGL 3.2.  The
+                     * EGL_KHR_create_context spec says:
+                     *
+                     *     "If the requested OpenGL version is less than 3.2,
+                     *      EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR is ignored and the functionality
+                     *      of the context is determined solely by the requested version.."
+                     */
+
+                    if (attribs.major > 3 || (attribs.major == 3 && attribs.minor >= 2)) {
+                        attribs.profile = ST_PROFILE_OPENGL_CORE;
+                        break;
+                    }
+                    /* fall-through */
+                case EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR:
+                    attribs.profile = ST_PROFILE_DEFAULT;
+                    break;
+                default:
+                    _eglError(EGL_BAD_CONFIG, "switch_create_context");
+                    goto cleanup;
+            }
+            break;
+        case EGL_OPENGL_ES_API:
+            switch (context->base.ClientMajorVersion) {
+            case 1:
+                attribs.profile = ST_PROFILE_OPENGL_ES1;
+                break;
+            case 2:
+            case 3: // ST_PROFILE_OPENGL_ES2 is used for OpenGL ES 3.x too
+                attribs.profile = ST_PROFILE_OPENGL_ES2;
+                break;
+            default:
+                _eglError(EGL_BAD_CONFIG, "switch_create_context");
+                goto cleanup;
+            }
+            break;
+        default:
+            _eglError(EGL_BAD_CONFIG, "switch_create_context");
+            goto cleanup;
+    }
+
+    enum st_context_error error;
+    context->stctx = display->stapi->create_context(display->stapi, display->stmgr, &attribs, &error, NULL);
+    if (error != ST_CONTEXT_SUCCESS) {
+        _eglError(EGL_BAD_MATCH, "switch_create_context");
+        goto cleanup;
+    }
+
+    return &context->base;
+
+cleanup:
+    free(context);
+    return NULL;
+}
+
+
+static EGLBoolean
+switch_destroy_context(_EGLDriver* drv, _EGLDisplay *disp, _EGLContext* ctx)
+{
+    struct switch_egl_context* context = switch_egl_context(ctx);
+    CALLED();
+
+    if (_eglPutContext(ctx))
+    {
+        context->stctx->destroy(context->stctx);
+        free(context);
+        ctx = NULL;
+    }
+    return EGL_TRUE;
+}
+
+
+static EGLBoolean
+switch_make_current(_EGLDriver* drv, _EGLDisplay* dpy, _EGLSurface *dsurf,
+    _EGLSurface *rsurf, _EGLContext *ctx)
+{
+    struct switch_egl_display* disp = switch_egl_display(dpy);
+    struct switch_egl_context* cont = switch_egl_context(ctx);
+    struct switch_egl_surface* draw_surf = switch_egl_surface(dsurf);
+    struct switch_egl_surface* read_surf = switch_egl_surface(rsurf);
+    CALLED();
+
+    _EGLContext *old_ctx;
+    _EGLSurface *old_dsurf, *old_rsurf;
+
+    if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
+        return EGL_FALSE;
+
+    EGLBoolean ret = disp->stapi->make_current(disp->stapi, cont ? cont->stctx : NULL,
+        draw_surf ? draw_surf->stfbi : NULL, read_surf ? read_surf->stfbi : NULL);
+
+    if (old_ctx) {
+        if (old_dsurf) {
+            switch_destroy_surface(drv, dpy, old_dsurf);
+        }
+        if (old_rsurf) {
+            switch_destroy_surface(drv, dpy, old_rsurf);
+        }
+        switch_destroy_context(drv, dpy, old_ctx);
+    }
+
+    return ret;
+}
+
+
+static EGLBoolean
+switch_swap_interval(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf, EGLint interval)
+{
+    CALLED();
+    struct switch_egl_surface* surface = switch_egl_surface(surf);
+
+    nwindowSetSwapInterval(surface->nw, interval);
+    return EGL_TRUE;
+}
+
+
+static EGLBoolean
+switch_swap_buffers(_EGLDriver *drv, _EGLDisplay *dpy, _EGLSurface *surf)
+{
+    CALLED();
+    struct switch_egl_surface* surface = switch_egl_surface(surf);
+    struct switch_egl_context* context = switch_egl_context(surface->base.CurrentContext);
+
+    if (surface->cur_slot < 0) {
+        TRACE("Nothing to do\n");
+        return EGL_TRUE;
+    }
+
+    TRACE("Flushing context\n");
+    context->stctx->flush(context->stctx, ST_FLUSH_END_OF_FRAME, NULL, NULL, NULL);
+
+    NvMultiFence mf = {0};
+    NvFence fence;
+    struct pipe_resource *old_back = surface->attachments[ST_ATTACHMENT_BACK_LEFT];
+    fence.id = nouveau_switch_resource_get_syncpoint(old_back, &fence.value);
+    if ((int)fence.id >= 0) {
+        NvFence* surf_fence = &surface->fences[surface->cur_slot];
+        if (surf_fence->id != fence.id || surf_fence->value != fence.value) {
+            TRACE("Using fence: {%d,%u}\n", (int)fence.id, fence.value);
+            *surf_fence = fence;
+            nvMultiFenceCreate(&mf, &fence);
+        }
+    }
+
+    TRACE("Queuing buffer\n");
+    Result rc = nwindowQueueBuffer(surface->nw, surface->cur_slot, &mf);
+    if (R_FAILED(rc)) fatalThrow(rc);
+
+    // Update framebuffer state
+    surface->cur_slot = -1;
+    surface->attachments[ST_ATTACHMENT_BACK_LEFT] = NULL;
+    surface->attachments[ST_ATTACHMENT_FRONT_LEFT] = old_back;
+    p_atomic_inc(&surface->stfbi->stamp);
+    return EGL_TRUE;
+}
+
+
+/*
+ * Called from eglGetProcAddress() via drv->API.GetProcAddress().
+ */
+static _EGLProc
+switch_get_proc_address(_EGLDriver *drv, const char *procname)
+{
+    return _glapi_get_proc_address(procname);
+}
+
+
+/**
+ * This is the main entrypoint into the driver, called by libEGL.
+ * Create a new _EGLDriver object and init its dispatch table.
+ */
+void
+_eglInitDriver(_EGLDriver *driver)
+{
+    CALLED();
+
+    driver->API.Initialize = switch_initialize;
+    driver->API.Terminate = switch_terminate;
+    driver->API.CreateContext = switch_create_context;
+    driver->API.DestroyContext = switch_destroy_context;
+    driver->API.MakeCurrent = switch_make_current;
+    driver->API.CreateWindowSurface = switch_create_window_surface;
+    driver->API.CreatePixmapSurface = switch_create_pixmap_surface;
+    driver->API.CreatePbufferSurface = switch_create_pbuffer_surface;
+    driver->API.DestroySurface = switch_destroy_surface;
+    driver->API.SwapInterval = switch_swap_interval;
+    driver->API.SwapBuffers = switch_swap_buffers;
+    driver->API.GetProcAddress = switch_get_proc_address;
+}
diff --git a/src/egl/main/eglcurrent.c b/src/egl/main/eglcurrent.c
index 29be4268025..aa9d02fe34c 100644
--- a/src/egl/main/eglcurrent.c
+++ b/src/egl/main/eglcurrent.c
@@ -39,21 +39,23 @@
 
 /* a fallback thread info to guarantee that every thread always has one */
 static _EGLThreadInfo dummy_thread;
-static mtx_t _egl_TSDMutex = _MTX_INITIALIZER_NP;
-static EGLBoolean _egl_TSDInitialized;
-static tss_t _egl_TSD;
-static void _eglDestroyThreadInfo(_EGLThreadInfo *t);
 
 #ifdef USE_ELF_TLS
 static __thread const _EGLThreadInfo *_egl_TLS
    __attribute__ ((tls_model("initial-exec")));
+#else
+static mtx_t _egl_TSDMutex = _MTX_INITIALIZER_NP;
+static EGLBoolean _egl_TSDInitialized;
+static tss_t _egl_TSD;
+static void (*_egl_FreeTSD)(_EGLThreadInfo *);
 #endif
 
 static inline void _eglSetTSD(const _EGLThreadInfo *t)
 {
-   tss_set(_egl_TSD, (void *) t);
 #ifdef USE_ELF_TLS
    _egl_TLS = t;
+#else
+   tss_set(_egl_TSD, (void *) t);
 #endif
 }
 
@@ -68,6 +70,7 @@ static inline _EGLThreadInfo *_eglGetTSD(void)
 
 static inline void _eglFiniTSD(void)
 {
+#ifndef USE_ELF_TLS
    mtx_lock(&_egl_TSDMutex);
    if (_egl_TSDInitialized) {
       _EGLThreadInfo *t = _eglGetTSD();
@@ -77,10 +80,12 @@ static inline void _eglFiniTSD(void)
       tss_delete(_egl_TSD);
    }
    mtx_unlock(&_egl_TSDMutex);
+#endif
 }
 
 static inline EGLBoolean _eglInitTSD()
 {
+#ifndef USE_ELF_TLS
    if (!_egl_TSDInitialized) {
       mtx_lock(&_egl_TSDMutex);
 
@@ -96,7 +101,7 @@ static inline EGLBoolean _eglInitTSD()
 
       mtx_unlock(&_egl_TSDMutex);
    }
-
+#endif
    return EGL_TRUE;
 }
 
diff --git a/src/egl/main/egldevice.c b/src/egl/main/egldevice.c
index 415b0508888..d7665cb6174 100644
--- a/src/egl/main/egldevice.c
+++ b/src/egl/main/egldevice.c
@@ -25,6 +25,7 @@
  *
  **************************************************************************/
 
+#include <stdlib.h>
 #ifdef HAVE_LIBDRM
 #include <xf86drm.h>
 #endif
diff --git a/src/egl/main/egldisplay.c b/src/egl/main/egldisplay.c
index f6e85c79aa9..582e9e3e06c 100644
--- a/src/egl/main/egldisplay.c
+++ b/src/egl/main/egldisplay.c
@@ -73,6 +73,7 @@ static const struct {
    { _EGL_PLATFORM_DRM, "drm" },
    { _EGL_PLATFORM_ANDROID, "android" },
    { _EGL_PLATFORM_HAIKU, "haiku" },
+   { _EGL_PLATFORM_SWITCH, "switch" },
    { _EGL_PLATFORM_SURFACELESS, "surfaceless" },
    { _EGL_PLATFORM_DEVICE, "device" },
 };
@@ -382,7 +383,7 @@ EGLBoolean
 _eglCheckResource(void *res, _EGLResourceType type, _EGLDisplay *disp)
 {
    _EGLResource *list = disp->ResourceLists[type];
-   
+
    if (!res)
       return EGL_FALSE;
 
diff --git a/src/egl/main/egldisplay.h b/src/egl/main/egldisplay.h
index 02ac4fb9a9d..2d8cff739f0 100644
--- a/src/egl/main/egldisplay.h
+++ b/src/egl/main/egldisplay.h
@@ -49,6 +49,7 @@ enum _egl_platform_type {
    _EGL_PLATFORM_DRM,
    _EGL_PLATFORM_ANDROID,
    _EGL_PLATFORM_HAIKU,
+   _EGL_PLATFORM_SWITCH,
    _EGL_PLATFORM_SURFACELESS,
    _EGL_PLATFORM_DEVICE,
 
diff --git a/src/egl/main/eglglobals.c b/src/egl/main/eglglobals.c
index 6811048bdf7..3f67dac321e 100644
--- a/src/egl/main/eglglobals.c
+++ b/src/egl/main/eglglobals.c
@@ -135,7 +135,11 @@ EGLBoolean
 _eglPointerIsDereferencable(void *p)
 {
    uintptr_t addr = (uintptr_t) p;
+#ifndef __SWITCH__
    const long page_size = getpagesize();
+#else
+   const long page_size = 0x1000;
+#endif
 #ifdef HAVE_MINCORE
    unsigned char valid = 0;
 
diff --git a/src/egl/main/eglglobals.h b/src/egl/main/eglglobals.h
index fc3b6bd62a7..4db07f65918 100644
--- a/src/egl/main/eglglobals.h
+++ b/src/egl/main/eglglobals.h
@@ -31,6 +31,7 @@
 #ifndef EGLGLOBALS_INCLUDED
 #define EGLGLOBALS_INCLUDED
 
+#include <assert.h>
 #include <stdbool.h>
 #include "c11/threads.h"
 
diff --git a/src/egl/main/egllog.c b/src/egl/main/egllog.c
index 6a91952577f..5aed9b0588b 100644
--- a/src/egl/main/egllog.c
+++ b/src/egl/main/egllog.c
@@ -56,6 +56,10 @@
 
 #endif /* HAVE_ANDROID_PLATFORM */
 
+#ifdef HAVE_SWITCH_PLATFORM
+#include <switch/kernel/svc.h>
+#endif
+
 #define MAXSTRING 1000
 #define FALLBACK_LOG_LEVEL _EGL_WARNING
 
@@ -85,7 +89,7 @@ static const char *level_strings[] = {
 static void
 _eglDefaultLogger(EGLint level, const char *msg)
 {
-#ifdef HAVE_ANDROID_PLATFORM
+#if defined(HAVE_ANDROID_PLATFORM)
    static const int egl2alog[] = {
       [_EGL_FATAL] = ANDROID_LOG_ERROR,
       [_EGL_WARNING]  = ANDROID_LOG_WARN,
@@ -94,6 +98,9 @@ _eglDefaultLogger(EGLint level, const char *msg)
    };
    LOG_PRI(egl2alog[level], LOG_TAG, "%s", msg);
 #else
+#if defined(HAVE_SWITCH_PLATFORM)
+   svcOutputDebugString(msg, strlen(msg) + 1);
+#endif
    fprintf(stderr, "libEGL %s: %s\n", level_strings[level], msg);
 #endif /* HAVE_ANDROID_PLATFORM */
 }
diff --git a/src/egl/meson.build b/src/egl/meson.build
index 12d74ec37fa..47fdfa74bca 100644
--- a/src/egl/meson.build
+++ b/src/egl/meson.build
@@ -22,6 +22,7 @@ inc_egl = include_directories('.', 'main')
 inc_egl_dri2 = include_directories('drivers/dri2')
 
 c_args_for_egl = []
+objs_for_egl = []
 link_for_egl = []
 deps_for_egl = []
 incs_for_egl = [inc_include, inc_src, inc_egl]
@@ -137,6 +138,20 @@ elif with_platform_haiku
   files_egl += files('drivers/haiku/egl_haiku.cpp')
   link_for_egl += libgl
   deps_for_egl += cpp.find_library('be')
+elif with_platform_switch
+  incs_for_egl += [inc_gallium, inc_gallium_aux, inc_gallium_winsys, inc_mesa]
+  files_egl += files('drivers/switch/egl_switch.c')
+  objs_for_egl += [
+    libmesa_common.extract_all_objects(),
+    libmesa_gallium.extract_all_objects(),
+    libglsl.extract_all_objects(),
+    libglcpp.extract_all_objects(),
+    libcompiler.extract_all_objects(),
+    libgallium.extract_all_objects(),
+    libgalliumvl_stub.extract_all_objects(),
+    libnouveauwinsys.extract_all_objects(),
+    libnouveau.extract_all_objects()
+  ]
 endif
 
 if cc.has_function('mincore')
@@ -158,7 +173,11 @@ else
   )
 endif
 
-libegl = shared_library(
+if not with_platform_switch
+  link_for_egl += libmesa_util
+endif
+
+libegl = library(
   egl_lib_name,
   files_egl,
   c_args : [
@@ -167,6 +186,7 @@ libegl = shared_library(
     '-D_EGL_NATIVE_PLATFORM=_EGL_PLATFORM_@0@'.format(egl_native_platform.to_upper()),
   ],
   include_directories : incs_for_egl,
+  objects : objs_for_egl,
   link_with : [link_for_egl, libglapi],
   link_args : [ld_args_bsymbolic, ld_args_gc_sections],
   dependencies : [deps_for_egl, dep_dl, dep_libdrm, dep_clock, dep_thread, idep_mesautil],
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_util.h b/src/gallium/auxiliary/driver_ddebug/dd_util.h
index 4c77cbcc163..0996525b083 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_util.h
+++ b/src/gallium/auxiliary/driver_ddebug/dd_util.h
@@ -38,7 +38,7 @@
 #include "util/u_string.h"
 
 #include "pipe/p_config.h"
-#if defined(PIPE_OS_UNIX)
+#if defined(PIPE_OS_UNIX) || defined(PIPE_OS_SWITCH)
 #include <unistd.h>
 #include <sys/stat.h>
 #elif defined(PIPE_OS_WINDOWS)
diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 1e2b948e348..b9a7ce1b336 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -1014,7 +1014,7 @@ static void strcat_without_spaces(char *dst, const char *src)
 }
 
 
-#ifdef PIPE_OS_WINDOWS
+#if defined(PIPE_OS_WINDOWS) || defined(PIPE_OS_SWITCH)
 #define W_OK 0
 static int
 access(const char *pathname, int mode)
@@ -1022,6 +1022,9 @@ access(const char *pathname, int mode)
    /* no-op */
    return 0;
 }
+#endif
+
+#if defined(PIPE_OS_WINDOWS)
 
 #define PATH_SEP "\\"
 
diff --git a/src/gallium/auxiliary/os/os_thread.h b/src/gallium/auxiliary/os/os_thread.h
index f2629c5ffe5..7f5718e567f 100644
--- a/src/gallium/auxiliary/os/os_thread.h
+++ b/src/gallium/auxiliary/os/os_thread.h
@@ -117,6 +117,8 @@ pipe_semaphore_wait(pipe_semaphore *sema)
  * Thread-specific data.
  */
 
+#if !defined(GLX_USE_TLS)
+
 typedef struct {
    tss_t key;
    int initMagic;
@@ -155,7 +157,7 @@ pipe_tsd_set(pipe_tsd *tsd, void *value)
    }
 }
 
-
+#endif
 
 /*
  * Thread statistics.
diff --git a/src/gallium/auxiliary/target-helpers/inline_debug_helper.h b/src/gallium/auxiliary/target-helpers/inline_debug_helper.h
index 08aea330710..eaf07647b5f 100644
--- a/src/gallium/auxiliary/target-helpers/inline_debug_helper.h
+++ b/src/gallium/auxiliary/target-helpers/inline_debug_helper.h
@@ -27,6 +27,7 @@ extern "C" {
 static inline struct pipe_screen *
 debug_screen_wrap(struct pipe_screen *screen)
 {
+#ifdef DEBUG
    screen = ddebug_screen_create(screen);
    screen = rbug_screen_create(screen);
    screen = trace_screen_create(screen);
@@ -34,6 +35,7 @@ debug_screen_wrap(struct pipe_screen *screen)
 
    if (debug_get_bool_option("GALLIUM_TESTS", FALSE))
       util_run_tests(screen);
+#endif
 
    return screen;
 }
diff --git a/src/gallium/auxiliary/util/u_network.c b/src/gallium/auxiliary/util/u_network.c
index 31139f2983f..47ceca7cf1c 100644
--- a/src/gallium/auxiliary/util/u_network.c
+++ b/src/gallium/auxiliary/util/u_network.c
@@ -9,7 +9,7 @@
 #  include <winsock2.h>
 #  include <windows.h>
 #  include <ws2tcpip.h>
-#elif defined(PIPE_OS_UNIX)
+#elif defined(PIPE_OS_UNIX) || defined(PIPE_OS_SWITCH)
 #  include <sys/socket.h>
 #  include <netinet/in.h>
 #  include <unistd.h>
diff --git a/src/gallium/auxiliary/util/u_tests.c b/src/gallium/auxiliary/util/u_tests.c
index 00f75906173..19dce75af52 100644
--- a/src/gallium/auxiliary/util/u_tests.c
+++ b/src/gallium/auxiliary/util/u_tests.c
@@ -587,7 +587,7 @@ test_sync_file_fences(struct pipe_context *ctx)
    pass = pass && screen->fence_finish(screen, NULL, final_fence, 0);
 
    /* Cleanup. */
-#ifndef PIPE_OS_WINDOWS
+#if !defined(PIPE_OS_WINDOWS) && !defined(PIPE_OS_SWITCH)
    if (buf_fd >= 0)
       close(buf_fd);
    if (tex_fd >= 0)
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir.cpp
index c65853578f6..f89962d1afa 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir.cpp
@@ -1305,9 +1305,11 @@ nv50_ir_generate_code(struct nv50_ir_prog_info *info)
    prog->optLevel = info->optLevel;
 
    switch (info->bin.sourceRep) {
+#ifndef __SWITCH__
    case PIPE_SHADER_IR_NIR:
       ret = prog->makeFromNIR(info) ? 0 : -2;
       break;
+#endif
    case PIPE_SHADER_IR_TGSI:
       ret = prog->makeFromTGSI(info) ? 0 : -2;
       break;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_nvc0.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_nvc0.cpp
index b6e35dd0ee4..e91a2de6d44 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_nvc0.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_emit_nvc0.cpp
@@ -24,6 +24,8 @@
 
 namespace nv50_ir {
 
+#ifndef __SWITCH__
+
 // Argh, all these assertions ...
 
 class CodeEmitterNVC0 : public CodeEmitter
@@ -3535,4 +3537,6 @@ TargetNVC0::getCodeEmitter(Program::Type type)
    return createCodeEmitterNVC0(type);
 }
 
+#endif
+
 } // namespace nv50_ir
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_target.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_target.cpp
index 5c6d0570ae2..c2c2fce1699 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_target.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_target.cpp
@@ -153,6 +153,7 @@ Target *Target::create(unsigned int chipset)
    case 0x120:
    case 0x130:
       return getTargetGM107(chipset);
+#ifndef __SWITCH__
    case 0xc0:
    case 0xd0:
    case 0xe0:
@@ -164,6 +165,7 @@ Target *Target::create(unsigned int chipset)
    case 0x90:
    case 0xa0:
       return getTargetNV50(chipset);
+#endif
    default:
       ERROR("unsupported target: NV%x\n", chipset);
       return 0;
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.cpp
index 60134b445db..0274338e10f 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.cpp
@@ -24,11 +24,15 @@
 
 namespace nv50_ir {
 
+#ifndef __SWITCH__
+
 Target *getTargetNVC0(unsigned int chipset)
 {
    return new TargetNVC0(chipset);
 }
 
+#endif
+
 TargetNVC0::TargetNVC0(unsigned int card) :
    Target(card < 0x110, false, card >= 0xe4)
 {
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.h b/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.h
index 2077207bb23..87d30720794 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.h
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_target_nvc0.h
@@ -40,7 +40,9 @@ public:
 
    void initProps(const struct opProperties *props, int size);
 
+#ifndef __SWITCH__
    virtual CodeEmitter *getCodeEmitter(Program::Type);
+#endif
 
    CodeEmitter *createCodeEmitterNVC0(Program::Type);
    CodeEmitter *createCodeEmitterGK110(Program::Type);
diff --git a/src/gallium/drivers/nouveau/nouveau_debug.h b/src/gallium/drivers/nouveau/nouveau_debug.h
index 546a4ad0af3..9bd2046914d 100644
--- a/src/gallium/drivers/nouveau/nouveau_debug.h
+++ b/src/gallium/drivers/nouveau/nouveau_debug.h
@@ -16,7 +16,7 @@
 #define NOUVEAU_DEBUG 0
 
 #define NOUVEAU_ERR(fmt, args...)                                 \
-   fprintf(stderr, "%s:%d - " fmt, __FUNCTION__, __LINE__, ##args)
+   debug_printf("%s:%d - " fmt, __FUNCTION__, __LINE__, ##args)
 
 #define NOUVEAU_DBG(ch, args...)           \
    if ((NOUVEAU_DEBUG) & (NOUVEAU_DEBUG_##ch))        \
diff --git a/src/gallium/drivers/nouveau/nouveau_screen.c b/src/gallium/drivers/nouveau/nouveau_screen.c
index de9cce3812a..22fdb9f8ccd 100644
--- a/src/gallium/drivers/nouveau/nouveau_screen.c
+++ b/src/gallium/drivers/nouveau/nouveau_screen.c
@@ -92,18 +92,12 @@ nouveau_screen_fence_finish(struct pipe_screen *screen,
 struct nouveau_bo *
 nouveau_screen_bo_from_handle(struct pipe_screen *pscreen,
                               struct winsys_handle *whandle,
-                              unsigned *out_stride)
+                              unsigned *out_stride, unsigned *out_offset)
 {
    struct nouveau_device *dev = nouveau_screen(pscreen)->device;
    struct nouveau_bo *bo = 0;
    int ret;
 
-   if (whandle->offset != 0) {
-      debug_printf("%s: attempt to import unsupported winsys offset %d\n",
-                   __FUNCTION__, whandle->offset);
-      return NULL;
-   }
-
    if (whandle->type != WINSYS_HANDLE_TYPE_SHARED &&
        whandle->type != WINSYS_HANDLE_TYPE_FD) {
       debug_printf("%s: attempt to import unsupported handle type %d\n",
@@ -123,6 +117,7 @@ nouveau_screen_bo_from_handle(struct pipe_screen *pscreen,
    }
 
    *out_stride = whandle->stride;
+   *out_offset = whandle->offset;
    return bo;
 }
 
@@ -131,9 +126,11 @@ bool
 nouveau_screen_bo_get_handle(struct pipe_screen *pscreen,
                              struct nouveau_bo *bo,
                              unsigned stride,
+                             unsigned offset,
                              struct winsys_handle *whandle)
 {
    whandle->stride = stride;
+   whandle->offset = offset;
 
    if (whandle->type == WINSYS_HANDLE_TYPE_SHARED) {
       return nouveau_bo_name_get(bo, &whandle->handle) == 0;
@@ -163,9 +160,11 @@ nouveau_disk_cache_create(struct nouveau_screen *screen)
    _mesa_sha1_final(&ctx, sha1);
    disk_cache_format_hex_id(cache_id, sha1, 20 * 2);
 
+#ifndef __SWITCH__
    if (screen->prefer_nir)
       driver_flags |= NOUVEAU_SHADER_CACHE_FLAGS_IR_NIR;
    else
+#endif
       driver_flags |= NOUVEAU_SHADER_CACHE_FLAGS_IR_TGSI;
 
    screen->disk_shader_cache =
@@ -188,7 +187,11 @@ nouveau_screen_init(struct nouveau_screen *screen, struct nouveau_device *dev)
    if (nv_dbg)
       nouveau_mesa_debug = atoi(nv_dbg);
 
+#ifndef __SWITCH__
    screen->prefer_nir = debug_get_bool_option("NV50_PROG_USE_NIR", false);
+#else
+   screen->prefer_nir = false;
+#endif
    screen->force_enable_cl = debug_get_bool_option("NOUVEAU_ENABLE_CL", false);
    if (screen->force_enable_cl)
       glsl_type_singleton_init_or_ref();
@@ -225,17 +228,23 @@ nouveau_screen_init(struct nouveau_screen *screen, struct nouveau_device *dev)
 
    ret = nouveau_object_new(&dev->object, 0, NOUVEAU_FIFO_CHANNEL_CLASS,
                             data, size, &screen->channel);
-   if (ret)
+   if (ret) {
+      debug_printf("nouveau_object_new: failed with %d\n", ret);
       return ret;
+   }
 
    ret = nouveau_client_new(screen->device, &screen->client);
-   if (ret)
+   if (ret) {
+      debug_printf("nouveau_client_new: failed with %d\n", ret);
       return ret;
+   }
    ret = nouveau_pushbuf_new(screen->client, screen->channel,
                              4, 512 * 1024, 1,
                              &screen->pushbuf);
-   if (ret)
+   if (ret) {
+      debug_printf("nouveau_pushbuf_new: failed with %d\n", ret);
       return ret;
+   }
 
    /* getting CPU time first appears to be more accurate */
    screen->cpu_gpu_time_delta = os_time_get();
@@ -282,8 +291,6 @@ nouveau_screen_init(struct nouveau_screen *screen, struct nouveau_device *dev)
 void
 nouveau_screen_fini(struct nouveau_screen *screen)
 {
-   int fd = screen->drm->fd;
-
    if (screen->force_enable_cl)
       glsl_type_singleton_decref();
 
@@ -297,7 +304,6 @@ nouveau_screen_fini(struct nouveau_screen *screen)
 
    nouveau_device_del(&screen->device);
    nouveau_drm_del(&screen->drm);
-   close(fd);
 
    disk_cache_destroy(screen->disk_shader_cache);
 }
diff --git a/src/gallium/drivers/nouveau/nouveau_screen.h b/src/gallium/drivers/nouveau/nouveau_screen.h
index 40464225c75..b6785a7f2bf 100644
--- a/src/gallium/drivers/nouveau/nouveau_screen.h
+++ b/src/gallium/drivers/nouveau/nouveau_screen.h
@@ -137,11 +137,12 @@ bool
 nouveau_screen_bo_get_handle(struct pipe_screen *pscreen,
                              struct nouveau_bo *bo,
                              unsigned stride,
+                             unsigned offset,
                              struct winsys_handle *whandle);
 struct nouveau_bo *
 nouveau_screen_bo_from_handle(struct pipe_screen *pscreen,
                               struct winsys_handle *whandle,
-                              unsigned *out_stride);
+                              unsigned *out_stride, unsigned *out_offset);
 
 
 int nouveau_screen_init(struct nouveau_screen *, struct nouveau_device *);
diff --git a/src/gallium/drivers/nouveau/nouveau_vp3_video.c b/src/gallium/drivers/nouveau/nouveau_vp3_video.c
index b28d31e0079..a5027515399 100644
--- a/src/gallium/drivers/nouveau/nouveau_vp3_video.c
+++ b/src/gallium/drivers/nouveau/nouveau_vp3_video.c
@@ -20,10 +20,10 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-#include <sys/mman.h>
 #include <sys/stat.h>
 #include <stdio.h>
 #include <fcntl.h>
+#include <unistd.h>
 
 #include <nvif/class.h>
 
@@ -293,7 +293,7 @@ nouveau_vp3_load_firmware(struct nouveau_vp3_decoder *dec,
    if (nouveau_bo_map(dec->fw_bo, NOUVEAU_BO_WR, dec->client))
       return 1;
 
-   fd = open(path, O_RDONLY | O_CLOEXEC);
+   fd = open(path, O_RDONLY);
    if (fd < 0) {
       fprintf(stderr, "opening firmware file %s failed: %m\n", path);
       return 1;
@@ -347,8 +347,7 @@ nouveau_vp3_load_firmware(struct nouveau_vp3_decoder *dec,
       default:
          return 1;
    }
-   munmap(dec->fw_bo->map, dec->fw_bo->size);
-   dec->fw_bo->map = NULL;
+   nouveau_bo_unmap(dec->fw_bo);
    return 0;
 }
 
diff --git a/src/gallium/drivers/nouveau/nouveau_winsys.h b/src/gallium/drivers/nouveau/nouveau_winsys.h
index e0ed0af3eaa..3a686bd8f6c 100644
--- a/src/gallium/drivers/nouveau/nouveau_winsys.h
+++ b/src/gallium/drivers/nouveau/nouveau_winsys.h
@@ -6,7 +6,6 @@
 
 #include "pipe/p_defines.h"
 
-#include "drm-uapi/drm.h"
 #include <nouveau.h>
 
 #ifndef NV04_PFIFO_MAX_PACKET_LEN
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_miptree.c b/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
index e4ed0dbd2a8..231e06c2048 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
@@ -52,14 +52,15 @@ nv30_miptree_get_handle(struct pipe_screen *pscreen,
                         struct winsys_handle *handle)
 {
    struct nv30_miptree *mt = nv30_miptree(pt);
-   unsigned stride;
+   unsigned stride, offset;
 
    if (!mt || !mt->base.bo)
       return false;
 
    stride = mt->level[0].pitch;
+   offset = mt->level[0].offset;
 
-   return nouveau_screen_bo_get_handle(pscreen, mt->base.bo, stride, handle);
+   return nouveau_screen_bo_get_handle(pscreen, mt->base.bo, stride, offset, handle);
 }
 
 static void
@@ -513,7 +514,7 @@ nv30_miptree_from_handle(struct pipe_screen *pscreen,
                          struct winsys_handle *handle)
 {
    struct nv30_miptree *mt;
-   unsigned stride;
+   unsigned stride, offset;
 
    /* only supports 2D, non-mipmapped textures for the moment */
    if ((tmpl->target != PIPE_TEXTURE_2D &&
@@ -527,7 +528,7 @@ nv30_miptree_from_handle(struct pipe_screen *pscreen,
    if (!mt)
       return NULL;
 
-   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, handle, &stride);
+   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, handle, &stride, &offset);
    if (mt->base.bo == NULL) {
       FREE(mt);
       return NULL;
@@ -539,7 +540,7 @@ nv30_miptree_from_handle(struct pipe_screen *pscreen,
    mt->base.base.screen = pscreen;
    mt->uniform_pitch = stride;
    mt->level[0].pitch = mt->uniform_pitch;
-   mt->level[0].offset = 0;
+   mt->level[0].offset = offset;
 
    /* no need to adjust bo reference count */
    return &mt->base.base;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_screen.c b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
index c4b514cfa61..5c8d300cfe4 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_screen.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include <xf86drm.h>
 #include <nouveau_drm.h>
 #include "util/format/u_format.h"
 #include "util/format/u_format_s3tc.h"
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_miptree.c b/src/gallium/drivers/nouveau/nv50/nv50_miptree.c
index 400ce6c9326..6248e369116 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_miptree.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_miptree.c
@@ -184,16 +184,18 @@ nv50_miptree_get_handle(struct pipe_screen *pscreen,
                         struct winsys_handle *whandle)
 {
    struct nv50_miptree *mt = nv50_miptree(pt);
-   unsigned stride;
+   unsigned stride, offset;
 
    if (!mt || !mt->base.bo)
       return false;
 
    stride = mt->level[0].pitch;
+   offset = mt->level[0].offset;
 
    return nouveau_screen_bo_get_handle(pscreen,
                                        mt->base.bo,
                                        stride,
+                                       offset,
                                        whandle);
 }
 
@@ -403,7 +405,7 @@ nv50_miptree_from_handle(struct pipe_screen *pscreen,
                          struct winsys_handle *whandle)
 {
    struct nv50_miptree *mt;
-   unsigned stride;
+   unsigned stride, offset;
 
    /* only supports 2D, non-mipmapped textures for the moment */
    if ((templ->target != PIPE_TEXTURE_2D &&
@@ -417,7 +419,7 @@ nv50_miptree_from_handle(struct pipe_screen *pscreen,
    if (!mt)
       return NULL;
 
-   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride);
+   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride, &offset);
    if (mt->base.bo == NULL) {
       FREE(mt);
       return NULL;
@@ -430,7 +432,7 @@ nv50_miptree_from_handle(struct pipe_screen *pscreen,
    pipe_reference_init(&mt->base.base.reference, 1);
    mt->base.base.screen = pscreen;
    mt->level[0].pitch = stride;
-   mt->level[0].offset = 0;
+   mt->level[0].offset = offset;
    mt->level[0].tile_mode = mt->base.bo->config.nv50.tile_mode;
 
    NOUVEAU_DRV_STAT(nouveau_screen(pscreen), tex_obj_current_count, 1);
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_screen.c b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
index e61d00c0b42..81009059d0b 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_screen.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
@@ -21,7 +21,6 @@
  */
 
 #include <errno.h>
-#include <xf86drm.h>
 #include <nouveau_drm.h>
 #include "util/format/u_format.h"
 #include "util/format/u_format_s3tc.h"
diff --git a/src/gallium/drivers/nouveau/nv50/nv84_video.c b/src/gallium/drivers/nouveau/nv50/nv84_video.c
index 0b5ebd48cc9..60676d0ac8f 100644
--- a/src/gallium/drivers/nouveau/nv50/nv84_video.c
+++ b/src/gallium/drivers/nouveau/nv50/nv84_video.c
@@ -20,7 +20,6 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-#include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <fcntl.h>
@@ -34,7 +33,7 @@
 static int
 nv84_copy_firmware(const char *path, void *dest, ssize_t len)
 {
-   int fd = open(path, O_RDONLY | O_CLOEXEC);
+   int fd = open(path, O_RDONLY);
    ssize_t r;
    if (fd < 0) {
       fprintf(stderr, "opening firmware file %s failed: %m\n", path);
@@ -88,8 +87,7 @@ nv84_load_firmwares(struct nouveau_device *dev, struct nv84_decoder *dec,
    ret = nv84_copy_firmware(fw1, fw->map, size1);
    if (fw2 && !ret)
       ret = nv84_copy_firmware(fw2, fw->map + dec->vp_fw2_offset, size2);
-   munmap(fw->map, fw->size);
-   fw->map = NULL;
+   nouveau_bo_unmap(fw);
    if (!ret)
       return fw;
 error:
diff --git a/src/gallium/drivers/nouveau/nv50/nv98_video_vp.c b/src/gallium/drivers/nouveau/nv50/nv98_video_vp.c
index f1cdf168ed4..eb09bbc5ca1 100644
--- a/src/gallium/drivers/nouveau/nv50/nv98_video_vp.c
+++ b/src/gallium/drivers/nouveau/nv50/nv98_video_vp.c
@@ -21,7 +21,6 @@
  */
 
 #include "nv50/nv98_video.h"
-#include <sys/mman.h>
 
 #if NOUVEAU_VP3_DEBUG_FENCE
 static void dump_comm_vp(struct nouveau_vp3_decoder *dec, struct comm *comm, u32 comm_seq,
@@ -50,8 +49,7 @@ static void dump_comm_vp(struct nouveau_vp3_decoder *dec, struct comm *comm, u32
       for (i = 0; i < comm->byte_ofs + slice_size; i += 0x10) {
          debug_printf("%05x: %08x %08x %08x %08x\n", i, map[i/4], map[i/4+1], map[i/4+2], map[i/4+3]);
       }
-      munmap(inter_bo->map, inter_bo->size);
-      inter_bo->map = NULL;
+      nouveau_bo_unmap(inter_bo);
    }
    assert((comm->pvp_stage & 0xff) == 0xff);
 }
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_program.c b/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
index 32aa82d168c..4cbe3cb8184 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_program.c
@@ -587,9 +587,11 @@ nvc0_program_translate(struct nvc0_program *prog, uint16_t chipset,
    case PIPE_SHADER_IR_TGSI:
       info->bin.source = (void *)prog->pipe.tokens;
       break;
+#ifndef __SWITCH__
    case PIPE_SHADER_IR_NIR:
       info->bin.source = (void *)nir_shader_clone(NULL, prog->pipe.ir.nir);
       break;
+#endif
    default:
       assert(!"unsupported IR!");
       free(info);
@@ -722,8 +724,10 @@ nvc0_program_translate(struct nvc0_program *prog, uint16_t chipset,
 #endif
 
 out:
+#ifndef __SWITCH__
    if (info->bin.sourceRep == PIPE_SHADER_IR_NIR)
       ralloc_free((void *)info->bin.source);
+#endif
    FREE(info);
    return !ret;
 }
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
index 7abbf762af2..5fa47ec8266 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
@@ -20,7 +20,6 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-#include <xf86drm.h>
 #include <nouveau_drm.h>
 #include <nvif/class.h>
 #include "util/format/u_format.h"
@@ -440,6 +439,7 @@ nvc0_screen_get_shader_param(struct pipe_screen *pscreen,
    }
 
    switch (param) {
+#ifndef __SWITCH__
    case PIPE_SHADER_CAP_PREFERRED_IR:
       return screen->prefer_nir ? PIPE_SHADER_IR_NIR : PIPE_SHADER_IR_TGSI;
    case PIPE_SHADER_CAP_SUPPORTED_IRS: {
@@ -449,6 +449,12 @@ nvc0_screen_get_shader_param(struct pipe_screen *pscreen,
          irs |= 1 << PIPE_SHADER_IR_NIR_SERIALIZED;
       return irs;
    }
+#else
+   case PIPE_SHADER_CAP_PREFERRED_IR:
+      return PIPE_SHADER_IR_TGSI;
+   case PIPE_SHADER_CAP_SUPPORTED_IRS:
+      return 1 << PIPE_SHADER_IR_TGSI;
+#endif
    case PIPE_SHADER_CAP_MAX_INSTRUCTIONS:
    case PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS:
    case PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS:
@@ -939,6 +945,8 @@ nvc0_screen_bind_cb_3d(struct nvc0_screen *screen, bool *can_serialize,
    IMMED_NVC0(push, NVC0_3D(CB_BIND(stage)), (index << 4) | (size >= 0));
 }
 
+#ifndef __SWITCH__
+
 static const nir_shader_compiler_options nir_options = {
    .lower_fdiv = false,
    .lower_ffma = false,
@@ -1010,6 +1018,8 @@ nvc0_screen_get_compiler_options(struct pipe_screen *pscreen,
    return NULL;
 }
 
+#endif
+
 #define FAIL_SCREEN_INIT(str, err)                    \
    do {                                               \
       NOUVEAU_ERR(str, err);                          \
@@ -1052,6 +1062,7 @@ nvc0_screen_create(struct nouveau_device *dev)
    ret = nouveau_screen_init(&screen->base, dev);
    if (ret)
       FAIL_SCREEN_INIT("Base screen init failed: %d\n", ret);
+
    chan = screen->base.channel;
    push = screen->base.pushbuf;
    push->user_priv = screen;
@@ -1084,8 +1095,10 @@ nvc0_screen_create(struct nouveau_device *dev)
    pscreen->get_sample_pixel_grid = nvc0_screen_get_sample_pixel_grid;
    pscreen->get_driver_query_info = nvc0_screen_get_driver_query_info;
    pscreen->get_driver_query_group_info = nvc0_screen_get_driver_query_group_info;
+#ifndef __SWITCH__
    /* nir stuff */
    pscreen->get_compiler_options = nvc0_screen_get_compiler_options;
+#endif
 
    nvc0_screen_init_resource_functions(pscreen);
 
@@ -1103,8 +1116,7 @@ nvc0_screen_create(struct nouveau_device *dev)
    screen->fence.map = screen->fence.bo->map;
    screen->base.fence.emit = nvc0_screen_fence_emit;
    screen->base.fence.update = nvc0_screen_fence_update;
-
-
+#if 0 // TODO: Support queries
    ret = nouveau_object_new(chan, (dev->chipset < 0xe0) ? 0x1f906e : 0x906e,
                             NVIF_CLASS_SW_GF100, NULL, 0, &screen->nvsw);
    if (ret)
@@ -1112,7 +1124,7 @@ nvc0_screen_create(struct nouveau_device *dev)
 
    BEGIN_NVC0(push, SUBC_SW(NV01_SUBCHAN_OBJECT), 1);
    PUSH_DATA (push, screen->nvsw->handle);
-
+#endif
    switch (dev->chipset & ~0xf) {
    case 0x130:
    case 0x120:
@@ -1135,9 +1147,9 @@ nvc0_screen_create(struct nouveau_device *dev)
 
    BEGIN_NVC0(push, SUBC_M2MF(NV01_SUBCHAN_OBJECT), 1);
    PUSH_DATA (push, screen->m2mf->oclass);
-   if (screen->m2mf->oclass == NVE4_P2MF_CLASS) {
+   if (screen->m2mf->oclass >= NVE4_P2MF_CLASS) {
       BEGIN_NVC0(push, SUBC_COPY(NV01_SUBCHAN_OBJECT), 1);
-      PUSH_DATA (push, 0xa0b5);
+      PUSH_DATA (push, screen->m2mf->oclass >= NVF0_P2MF_CLASS ? 0xb0b5 : 0xa0b5);
    }
 
    ret = nouveau_object_new(chan, 0xbeef902d, NVC0_2D_CLASS, NULL, 0,
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 5cb07609dae..a2cb6f3400f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -602,9 +602,11 @@ nvc0_sp_state_create(struct pipe_context *pipe,
    case PIPE_SHADER_IR_TGSI:
       prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);
       break;
+#ifndef __SWITCH__
    case PIPE_SHADER_IR_NIR:
       prog->pipe.ir.nir = cso->ir.nir;
       break;
+#endif
    default:
       assert(!"unsupported IR!");
       free(prog);
@@ -630,8 +632,10 @@ nvc0_sp_state_delete(struct pipe_context *pipe, void *hwcso)
 
    if (prog->pipe.type == PIPE_SHADER_IR_TGSI)
       FREE((void *)prog->pipe.tokens);
+#ifndef __SWITCH__
    else if (prog->pipe.type == PIPE_SHADER_IR_NIR)
       ralloc_free(prog->pipe.ir.nir);
+#endif
    FREE(prog);
 }
 
@@ -735,6 +739,7 @@ nvc0_cp_state_create(struct pipe_context *pipe,
    case PIPE_SHADER_IR_TGSI:
       prog->pipe.tokens = tgsi_dup_tokens((const struct tgsi_token *)cso->prog);
       break;
+#ifndef __SWITCH__
    case PIPE_SHADER_IR_NIR:
       prog->pipe.ir.nir = (nir_shader *)cso->prog;
       break;
@@ -747,6 +752,7 @@ nvc0_cp_state_create(struct pipe_context *pipe,
       prog->pipe.type = PIPE_SHADER_IR_NIR;
       break;
    }
+#endif
    default:
       assert(!"unsupported IR!");
       free(prog);
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_video_vp.c b/src/gallium/drivers/nouveau/nvc0/nvc0_video_vp.c
index 3de4ec14867..8b481f0a640 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_video_vp.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_video_vp.c
@@ -21,7 +21,6 @@
  */
 
 #include "nvc0/nvc0_video.h"
-#include <sys/mman.h>
 
 #if NOUVEAU_VP3_DEBUG_FENCE
 static void dump_comm_vp(struct nouveau_vp3_decoder *dec, struct comm *comm, u32 comm_seq,
@@ -50,8 +49,7 @@ static void dump_comm_vp(struct nouveau_vp3_decoder *dec, struct comm *comm, u32
       for (i = 0; i < comm->byte_ofs + slice_size; i += 0x10) {
          debug_printf("%05x: %08x %08x %08x %08x\n", i, map[i/4], map[i/4+1], map[i/4+2], map[i/4+3]);
       }
-      munmap(inter_bo->map, inter_bo->size);
-      inter_bo->map = NULL;
+      nouveau_bo_unmap(inter_bo);
    }
    assert((comm->pvp_stage & 0xff) == 0xff);
 }
diff --git a/src/gallium/include/pipe/p_config.h b/src/gallium/include/pipe/p_config.h
index 2c1698d0e9c..d717103a9cf 100644
--- a/src/gallium/include/pipe/p_config.h
+++ b/src/gallium/include/pipe/p_config.h
@@ -1,8 +1,8 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2008 VMware, Inc.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,24 +22,24 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 
 /**
  * @file
  * Gallium configuration defines.
- * 
- * This header file sets several defines based on the compiler, processor 
- * architecture, and operating system being used. These defines should be used 
- * throughout the code to facilitate porting to new platforms. It is likely that 
- * this file is auto-generated by an autoconf-like tool at some point, as some 
- * things cannot be determined by pre-defined environment alone. 
- * 
+ *
+ * This header file sets several defines based on the compiler, processor
+ * architecture, and operating system being used. These defines should be used
+ * throughout the code to facilitate porting to new platforms. It is likely that
+ * this file is auto-generated by an autoconf-like tool at some point, as some
+ * things cannot be determined by pre-defined environment alone.
+ *
  * See also:
  * - http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
  * - echo | gcc -dM -E - | sort
  * - http://msdn.microsoft.com/en-us/library/b0084kay.aspx
- * 
+ *
  * @author José Fonseca <jfonseca@vmware.com>
  */
 
@@ -65,8 +65,8 @@
  * - 1400: Visual C++ 2005
  * - 1310: Visual C++ .NET 2003
  * - 1300: Visual C++ .NET 2002
- * 
- * __MSC__ seems to be an old macro -- it is not pre-defined on recent MSVC 
+ *
+ * __MSC__ seems to be an old macro -- it is not pre-defined on recent MSVC
  * versions.
  */
 #if defined(_MSC_VER) || defined(__MSC__)
@@ -145,6 +145,10 @@
 #define PIPE_OS_ANDROID
 #endif
 
+#if DETECT_OS_SWITCH
+#define PIPE_OS_SWITCH
+#endif
+
 #if DETECT_OS_FREEBSD
 #define PIPE_OS_FREEBSD
 #endif
diff --git a/src/gallium/meson.build b/src/gallium/meson.build
index 1f81fcf1fd5..b15a01a3e46 100644
--- a/src/gallium/meson.build
+++ b/src/gallium/meson.build
@@ -78,7 +78,11 @@ else
   driver_radeonsi = declare_dependency()
 endif
 if with_gallium_nouveau
-  subdir('winsys/nouveau/drm')
+  if with_dri
+    subdir('winsys/nouveau/drm')
+  elif with_platform_switch
+    subdir('winsys/nouveau/switch')
+  endif
   subdir('drivers/nouveau')
 else
   driver_nouveau = declare_dependency()
diff --git a/src/gallium/winsys/nouveau/switch/meson.build b/src/gallium/winsys/nouveau/switch/meson.build
new file mode 100644
index 00000000000..22c45281367
--- /dev/null
+++ b/src/gallium/winsys/nouveau/switch/meson.build
@@ -0,0 +1,29 @@
+# Copyright © 2019 fincs
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+libnouveauwinsys = static_library(
+  'nouveauwinsys',
+  files('nouveau_switch_public.h', 'nouveau_switch_winsys.c'),
+  include_directories : [
+    inc_src, inc_include, inc_gallium, inc_gallium_aux, inc_gallium_drivers,
+  ],
+  c_args : [c_vis_args],
+  dependencies : [dep_libdrm_nouveau],
+)
diff --git a/src/gallium/winsys/nouveau/switch/nouveau_switch_public.h b/src/gallium/winsys/nouveau/switch/nouveau_switch_public.h
new file mode 100644
index 00000000000..33b35885818
--- /dev/null
+++ b/src/gallium/winsys/nouveau/switch/nouveau_switch_public.h
@@ -0,0 +1,13 @@
+
+#ifndef __NOUVEAU_SWITCH_PUBLIC_H__
+#define __NOUVEAU_SWITCH_PUBLIC_H__
+#include <switch.h>
+
+struct pipe_screen;
+struct pipe_resource;
+
+struct pipe_screen *nouveau_switch_screen_create(void);
+int nouveau_switch_resource_get_syncpoint(struct pipe_resource *resource, unsigned int *out_threshold);
+int nouveau_switch_resource_get_buffer(struct pipe_resource *resource, NvGraphicBuffer *buffer);
+
+#endif
diff --git a/src/gallium/winsys/nouveau/switch/nouveau_switch_winsys.c b/src/gallium/winsys/nouveau/switch/nouveau_switch_winsys.c
new file mode 100644
index 00000000000..87b9eff8017
--- /dev/null
+++ b/src/gallium/winsys/nouveau/switch/nouveau_switch_winsys.c
@@ -0,0 +1,206 @@
+#include <stdint.h>
+#include "pipe/p_context.h"
+#include "pipe/p_state.h"
+#include "pipe/p_screen.h"
+#include "util/format/u_format.h"
+#include "util/u_memory.h"
+#include "util/u_inlines.h"
+#include "util/u_hash_table.h"
+#include "os/os_thread.h"
+
+#include "state_tracker/drm_driver.h"
+#include "drm-uapi/drm_fourcc.h"
+
+#include "nouveau_switch_public.h"
+
+#include "nouveau/nouveau_winsys.h"
+#include "nouveau/nouveau_screen.h"
+#include "nouveau/nouveau_buffer.h"
+
+#include <nvif/class.h>
+#include <nvif/cl0080.h>
+
+static mtx_t nouveau_screen_mutex = _MTX_INITIALIZER_NP;
+
+bool nouveau_drm_screen_unref(struct nouveau_screen *screen)
+{
+	int ret;
+	if (screen->refcount == -1)
+		return true;
+
+	mtx_lock(&nouveau_screen_mutex);
+	ret = --screen->refcount;
+	assert(ret >= 0);
+	mtx_unlock(&nouveau_screen_mutex);
+	return ret == 0;
+}
+
+PUBLIC struct pipe_screen *
+nouveau_switch_screen_create(void)
+{
+	struct nouveau_drm *drm = NULL;
+	struct nouveau_device *dev = NULL;
+	struct nouveau_screen *(*init)(struct nouveau_device *);
+	struct nouveau_screen *screen = NULL;
+	int ret;
+
+	mtx_lock(&nouveau_screen_mutex);
+
+	ret = nouveau_drm_new(0, &drm);
+	if (ret)
+		goto err;
+
+	ret = nouveau_device_new(&drm->client, NV_DEVICE,
+				 &(struct nv_device_v0) {
+					.device = ~0ULL,
+				 }, sizeof(struct nv_device_v0), &dev);
+	if (ret)
+		goto err;
+
+	switch (dev->chipset & ~0xf) {
+#if 0
+	case 0x30:
+	case 0x40:
+	case 0x60:
+		init = nv30_screen_create;
+		break;
+	case 0x50:
+	case 0x80:
+	case 0x90:
+	case 0xa0:
+		init = nv50_screen_create;
+		break;
+#endif
+	case 0xc0:
+	case 0xd0:
+	case 0xe0:
+	case 0xf0:
+	case 0x100:
+	case 0x110:
+	case 0x120:
+	case 0x130:
+		init = nvc0_screen_create;
+		break;
+	default:
+		debug_printf("%s: unknown chipset nv%02x\n", __func__,
+			     dev->chipset);
+		goto err;
+	}
+
+	screen = init(dev);
+	if (!screen || !screen->base.context_create)
+		goto err;
+
+	screen->refcount = 1;
+	mtx_unlock(&nouveau_screen_mutex);
+	return &screen->base;
+
+err:
+	if (screen) {
+		screen->base.destroy(&screen->base);
+	} else {
+		nouveau_device_del(&dev);
+		nouveau_drm_del(&drm);
+	}
+	mtx_unlock(&nouveau_screen_mutex);
+	return NULL;
+}
+
+PUBLIC int
+nouveau_switch_resource_get_syncpoint(struct pipe_resource *resource, unsigned int *out_threshold)
+{
+	struct nv04_resource* priv = nv04_resource(resource);
+	return nouveau_bo_get_syncpoint(priv->bo, out_threshold);
+}
+
+PUBLIC int
+nouveau_switch_resource_get_buffer(struct pipe_resource *resource, NvGraphicBuffer *buffer)
+{
+	struct winsys_handle whandle = {0};
+
+	if ((resource->target != PIPE_TEXTURE_2D && resource->target != PIPE_TEXTURE_RECT) || resource->last_level != 0 || resource->depth0 != 1 || resource->array_size > 1) {
+		debug_printf("%s: unsupported resource type\n", __func__);
+		return -1;
+	}
+
+	whandle.type = WINSYS_HANDLE_TYPE_SHARED;
+	if (!resource->screen->resource_get_handle(resource->screen, NULL, resource, &whandle, 0)) {
+		debug_printf("%s: resource_get_handle failed\n", __func__);
+		return -2;
+	}
+
+	u32 block_height_log2;
+	switch (whandle.modifier) {
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_ONE_GOB:
+			block_height_log2 = 0;
+			break;
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_TWO_GOB:
+			block_height_log2 = 1;
+			break;
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_FOUR_GOB:
+			block_height_log2 = 2;
+			break;
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_EIGHT_GOB:
+			block_height_log2 = 3;
+			break;
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_SIXTEEN_GOB:
+			block_height_log2 = 4;
+			break;
+		case DRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK_THIRTYTWO_GOB:
+			block_height_log2 = 5;
+			break;
+		default:
+			debug_printf("%s: unsupported resource layout\n", __func__);
+			return -3;
+	}
+
+	u32 format;
+	NvColorFormat colorfmt;
+	switch (resource->format) {
+		case PIPE_FORMAT_R8G8B8A8_UNORM:
+			format = PIXEL_FORMAT_RGBA_8888;
+			colorfmt = NvColorFormat_A8B8G8R8;
+			break;
+		case PIPE_FORMAT_R8G8B8X8_UNORM:
+			format = PIXEL_FORMAT_RGBX_8888;
+			colorfmt = NvColorFormat_X8B8G8R8;
+			break;
+		case PIPE_FORMAT_B5G6R5_UNORM:
+			format = PIXEL_FORMAT_RGB_565;
+			colorfmt = NvColorFormat_R5G6B5;
+			break;
+		default:
+			debug_printf("%s: unsupported resource format\n", __func__);
+			return -4;
+	}
+
+	const u32 bytes_per_pixel = ((u64)colorfmt >> 3) & 0x1F;
+	const u32 block_height = 8 * (1U << block_height_log2);
+	const u32 width_aligned = whandle.stride / bytes_per_pixel;
+	const u32 height_aligned = (resource->height0 + block_height - 1) &~ (block_height - 1);
+	const u32 fb_size = whandle.stride*height_aligned;
+
+	memset(buffer, 0, sizeof(*buffer));
+	buffer->header.num_ints = (sizeof(NvGraphicBuffer) - sizeof(NativeHandle)) / 4;
+	buffer->unk0 = -1;
+	buffer->nvmap_id = whandle.handle;
+	buffer->magic = 0xDAFFCAFF;
+	buffer->pid = 42;
+	buffer->usage = GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
+	buffer->format = format;
+	buffer->ext_format = format;
+	buffer->stride = width_aligned;
+	buffer->total_size = fb_size;
+	buffer->num_planes = 1;
+	buffer->planes[0].width = resource->width0;
+	buffer->planes[0].height = resource->height0;
+	buffer->planes[0].color_format = colorfmt;
+	buffer->planes[0].layout = NvLayout_BlockLinear;
+	buffer->planes[0].pitch = whandle.stride;
+	buffer->planes[0].offset = whandle.offset;
+	buffer->planes[0].kind = NvKind_Generic_16BX2;
+	buffer->planes[0].block_height_log2 = block_height_log2;
+	buffer->planes[0].size = fb_size;
+
+	return 0;
+}
diff --git a/src/loader/loader.c b/src/loader/loader.c
index 8548cbdfedb..058a38af1d2 100644
--- a/src/loader/loader.c
+++ b/src/loader/loader.c
@@ -26,7 +26,9 @@
  *    Rob Clark <robclark@freedesktop.org>
  */
 
+#ifdef HAVE_DLFCN_H
 #include <dlfcn.h>
+#endif
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/stat.h>
@@ -515,6 +517,7 @@ loader_get_extensions_name(const char *driver_name)
    return name;
 }
 
+#ifdef HAVE_DLFCN_H
 /**
  * Opens a DRI driver using its driver name, returning the __DRIextension
  * entrypoints.
@@ -602,3 +605,4 @@ loader_open_driver(const char *driver_name,
    *out_driver_handle = driver;
    return extensions;
 }
+#endif
diff --git a/src/mapi/es1api/meson.build b/src/mapi/es1api/meson.build
index 711048421b8..c83a862bec3 100644
--- a/src/mapi/es1api/meson.build
+++ b/src/mapi/es1api/meson.build
@@ -32,7 +32,7 @@ if with_platform_windows
   _es1_c_args += ['-D_GDI32_', '-DBUILD_GL32']
 endif
 
-libglesv1_cm = shared_library(
+libglesv1_cm = library(
   'GLESv1_CM' + get_option('gles-lib-suffix'),
   ['../entry.c', es1_glapi_mapi_tmp_h],
   c_args : [
diff --git a/src/mapi/es2api/meson.build b/src/mapi/es2api/meson.build
index ac79aa66f89..3ba80c96248 100644
--- a/src/mapi/es2api/meson.build
+++ b/src/mapi/es2api/meson.build
@@ -32,7 +32,7 @@ if with_platform_windows
   _es2_c_args += ['-D_GDI32_', '-DBUILD_GL32']
 endif
 
-libgles2 = shared_library(
+libgles2 = library(
   'GLESv2' + get_option('gles-lib-suffix'),
   ['../entry.c', es2_glapi_mapi_tmp_h],
   c_args : [
diff --git a/src/mapi/shared-glapi/meson.build b/src/mapi/shared-glapi/meson.build
index 5b9db0c081a..315b72e65de 100644
--- a/src/mapi/shared-glapi/meson.build
+++ b/src/mapi/shared-glapi/meson.build
@@ -41,7 +41,7 @@ if with_platform_windows
   _glapi_c_args += ['-D_GLAPI_DLL_EXPORTS']
 endif
 
-libglapi = shared_library(
+libglapi = library(
   'glapi',
   [files_mapi_glapi, files_mapi_util, shared_glapi_mapi_tmp_h],
   c_args : [
@@ -61,6 +61,15 @@ libglapi = shared_library(
   install : true,
 )
 
+pkg.generate(
+  name : 'glapi',
+  filebase : 'glapi',
+  description : 'Mesa OpenGL shared library',
+  version : meson.project_version(),
+  libraries : libglapi,
+  libraries_private : gl_priv_libs,
+)
+
 if with_any_opengl and with_tests
   test(
     'shared-glapi-test',
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 2b8becb806d..3038ac3641b 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1233,7 +1233,7 @@ _mesa_initialize_context(struct gl_context *ctx,
     * has errors so don't enable it for setuid processes.
     */
    if (env_var_as_boolean("MESA_NO_ERROR", false)) {
-#if !defined(_WIN32)
+#if !defined(_WIN32) && !defined(__SWITCH__)
       if (geteuid() == getuid())
 #endif
          ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR;
diff --git a/src/mesa/main/errors.c b/src/mesa/main/errors.c
index 91988f183f8..eeaefde0960 100644
--- a/src/mesa/main/errors.c
+++ b/src/mesa/main/errors.c
@@ -36,6 +36,10 @@
 #include "context.h"
 #include "debug_output.h"
 
+#if defined(__SWITCH__)
+#include <switch/kernel/svc.h>
+#endif
+
 
 static FILE *LogFile = NULL;
 
@@ -81,13 +85,17 @@ output_if_debug(const char *prefixString, const char *outputString,
          fprintf(LogFile, "\n");
       fflush(LogFile);
 
-#if defined(_WIN32)
+#if defined(_WIN32) || defined(__SWITCH__)
       /* stderr from windows applications without console is not usually
        * visible, so communicate with the debugger instead */
       {
          char buf[4096];
          snprintf(buf, sizeof(buf), "%s: %s%s", prefixString, outputString, newline ? "\n" : "");
+#ifdef __SWITCH__
+         svcOutputDebugString(buf, sizeof(buf));
+#else
          OutputDebugStringA(buf);
+#endif
       }
 #endif
    }
diff --git a/src/mesa/main/execmem.c b/src/mesa/main/execmem.c
index b2018b5e767..823fe406f76 100644
--- a/src/mesa/main/execmem.c
+++ b/src/mesa/main/execmem.c
@@ -133,6 +133,7 @@ _mesa_exec_free(void *addr)
 
 
 #else
+#include <stdlib.h>
 
 /*
  * Just use regular memory.
diff --git a/src/mesa/main/glspirv.c b/src/mesa/main/glspirv.c
index 64daf54ec42..6386d5315bb 100644
--- a/src/mesa/main/glspirv.c
+++ b/src/mesa/main/glspirv.c
@@ -325,6 +325,7 @@ _mesa_SpecializeShaderARB(GLuint shader,
       return;
    }
 
+#ifndef __SWITCH__
    sh = _mesa_lookup_shader_err(ctx, shader, "glSpecializeShaderARB");
    if (!sh)
       return;
@@ -417,4 +418,5 @@ _mesa_SpecializeShaderARB(GLuint shader,
 
  end:
    free(spec_entries);
+#endif
 }
diff --git a/src/mesa/main/hash.h b/src/mesa/main/hash.h
index 0a3996a7d00..a1d4aa98a34 100644
--- a/src/mesa/main/hash.h
+++ b/src/mesa/main/hash.h
@@ -34,6 +34,7 @@
 
 #include <stdbool.h>
 #include <stdint.h>
+#include <assert.h>
 #include "glheader.h"
 
 #include "c11/threads.h"
diff --git a/src/mesa/state_tracker/st_cb_clear.c b/src/mesa/state_tracker/st_cb_clear.c
index e38f44ed78b..4419be0eaac 100644
--- a/src/mesa/state_tracker/st_cb_clear.c
+++ b/src/mesa/state_tracker/st_cb_clear.c
@@ -1,9 +1,9 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2007 VMware, Inc.
  * All Rights Reserved.
  * Copyright 2009 VMware, Inc.  All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -11,11 +11,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -23,7 +23,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 
  /*
@@ -110,9 +110,13 @@ static inline void
 set_fragment_shader(struct st_context *st)
 {
    struct pipe_screen *pscreen = st->pipe->screen;
+#ifndef __SWITCH__
    bool use_nir = PIPE_SHADER_IR_NIR ==
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const bool use_nir = false;
+#endif
 
    if (!st->clear.fs) {
       if (use_nir) {
@@ -164,9 +168,13 @@ static inline void
 set_vertex_shader(struct st_context *st)
 {
    struct pipe_screen *pscreen = st->pipe->screen;
+#ifndef __SWITCH__
    bool use_nir = PIPE_SHADER_IR_NIR ==
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const bool use_nir = false;
+#endif
 
    /* vertex shader - still required to provide the linkage between
     * fragment shader input semantics and vertex_element/buffers.
@@ -198,9 +206,13 @@ set_vertex_shader_layered(struct st_context *st)
 {
    struct pipe_context *pipe = st->pipe;
    struct pipe_screen *pscreen = pipe->screen;
+#ifndef __SWITCH__
    bool use_nir = PIPE_SHADER_IR_NIR ==
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const bool use_nir = false;
+#endif
 
    if (!pipe->screen->get_param(pipe->screen, PIPE_CAP_TGSI_INSTANCEID)) {
       assert(!"Got layered clear, but VS instancing is unsupported");
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index 3f84b22154d..9278f6ebb9f 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -284,9 +284,13 @@ get_drawpix_z_stencil_program(struct st_context *st,
       return st->drawpix.zs_shaders[shaderIndex];
    }
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir =
       pscreen->get_shader_param(pscreen, PIPE_SHADER_FRAGMENT,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
 
    if (preferred_ir == PIPE_SHADER_IR_NIR)
       cso = make_drawpix_z_stencil_program_nir(st, write_depth, write_stencil);
@@ -312,9 +316,13 @@ st_make_passthrough_vertex_shader(struct st_context *st)
    if (st->passthrough_vs)
       return;
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir =
       screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
 
    if (preferred_ir == PIPE_SHADER_IR_NIR) {
       unsigned inputs[] =
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index 4960a55e986..deb95d247e7 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -126,9 +126,13 @@ lookup_shader(struct st_context *st,
       CachedShaders[i].semantic_indexes[j] = semantic_indexes[j];
    }
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir =
       screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
 
    if (preferred_ir == PIPE_SHADER_IR_NIR) {
       unsigned inputs[2 + MAX_TEXTURE_UNITS];
diff --git a/src/mesa/state_tracker/st_cb_memoryobjects.c b/src/mesa/state_tracker/st_cb_memoryobjects.c
index d81c7692c1f..7d2c3d7396b 100644
--- a/src/mesa/state_tracker/st_cb_memoryobjects.c
+++ b/src/mesa/state_tracker/st_cb_memoryobjects.c
@@ -80,7 +80,7 @@ st_import_memoryobj_fd(struct gl_context *ctx,
                                                       &whandle,
                                                       obj->Dedicated);
 
-#if !defined(_WIN32)
+#if !defined(_WIN32) && !defined(__SWITCH__)
    /* We own fd, but we no longer need it. So get rid of it */
    close(fd);
 #endif
diff --git a/src/mesa/state_tracker/st_cb_semaphoreobjects.c b/src/mesa/state_tracker/st_cb_semaphoreobjects.c
index 7a32d9b138f..88b41dc9047 100644
--- a/src/mesa/state_tracker/st_cb_semaphoreobjects.c
+++ b/src/mesa/state_tracker/st_cb_semaphoreobjects.c
@@ -68,7 +68,7 @@ st_import_semaphoreobj_fd(struct gl_context *ctx,
 
    pipe->create_fence_fd(pipe, &st_obj->fence, fd, PIPE_FD_TYPE_SYNCOBJ);
 
-#if !defined(_WIN32)
+#if !defined(_WIN32) && !defined(__SWITCH__)
    /* We own fd, but we no longer need it. So get rid of it */
    close(fd);
 #endif
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 4f7fd242741..848d075dd41 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -453,7 +453,9 @@ st_destroy_context_priv(struct st_context *st, bool destroy_pipe)
    uint i;
 
    st_destroy_atoms(st);
+#ifndef __SWITCH__
    st_destroy_draw(st);
+#endif
    st_destroy_clear(st);
    st_destroy_bitmap(st);
    st_destroy_drawpix(st);
@@ -773,9 +775,13 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
 
    ctx->Const.ShaderCompilerOptions[MESA_SHADER_VERTEX].PositionAlwaysInvariant = options->vs_position_always_invariant;
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir = (enum pipe_shader_ir)
       screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
    ctx->Const.UseNIRGLSLLinker = preferred_ir == PIPE_SHADER_IR_NIR;
 
    if (ctx->Const.GLSLVersion < 400) {
@@ -901,14 +907,18 @@ st_init_driver_functions(struct pipe_screen *screen,
    st_init_bitmap_functions(functions);
    st_init_copy_image_functions(functions);
    st_init_drawpixels_functions(functions);
+#ifndef __SWITCH__
    st_init_rasterpos_functions(functions);
+#endif
 
    st_init_drawtex_functions(functions);
 
    st_init_eglimage_functions(functions);
 
    st_init_fbo_functions(functions);
+#ifndef __SWITCH__
    st_init_feedback_functions(functions);
+#endif
    st_init_memoryobject_functions(functions);
    st_init_msaa_functions(functions);
    st_init_perfmon_functions(functions);
@@ -943,9 +953,13 @@ st_init_driver_functions(struct pipe_screen *screen,
    /* GL_ARB_get_program_binary */
    functions->GetProgramBinaryDriverSHA1 = st_get_program_binary_driver_sha1;
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir = (enum pipe_shader_ir)
       screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
    if (preferred_ir == PIPE_SHADER_IR_NIR) {
       functions->ShaderCacheSerializeDriverBlob =  st_serialise_nir_program;
       functions->ProgramBinarySerializeDriverBlob =
@@ -1062,8 +1076,10 @@ st_destroy_context(struct st_context *st)
     */
    _mesa_make_current(ctx, NULL, NULL);
 
+#ifndef __SWITCH__
    /* This must be called first so that glthread has a chance to finish */
    _mesa_glthread_destroy(ctx);
+#endif
 
    _mesa_HashWalk(ctx->Shared->TexObjects, destroy_tex_sampler_cb, st);
 
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index cbc8b139dbb..551879efc8d 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -347,6 +347,7 @@ st_init_draw_functions(struct dd_function_table *functions)
    functions->DrawIndirect = st_indirect_draw_vbo;
 }
 
+#ifndef __SWITCH__
 
 void
 st_destroy_draw(struct st_context *st)
@@ -380,6 +381,8 @@ st_get_draw_context(struct st_context *st)
    return st->draw;
 }
 
+#endif
+
 /**
  * Draw a quad with given position, texcoords and color.
  */
diff --git a/src/mesa/state_tracker/st_glsl_to_ir.cpp b/src/mesa/state_tracker/st_glsl_to_ir.cpp
index e450fec6d99..1d1fb4ec2a5 100644
--- a/src/mesa/state_tracker/st_glsl_to_ir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_ir.cpp
@@ -47,9 +47,13 @@ st_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
 {
    struct pipe_screen *pscreen = ctx->st->pipe->screen;
 
+#ifndef __SWITCH__
    enum pipe_shader_ir preferred_ir = (enum pipe_shader_ir)
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
+#else
+   const enum pipe_shader_ir preferred_ir = PIPE_SHADER_IR_TGSI;
+#endif
    bool use_nir = preferred_ir == PIPE_SHADER_IR_NIR;
 
    /* Return early if we are loading the shader from on-disk cache */
@@ -59,11 +63,13 @@ st_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
 
    assert(prog->data->LinkStatus);
 
+#ifndef __SWITCH__
    /* Skip the GLSL steps when using SPIR-V. */
    if (prog->data->spirv) {
       assert(use_nir);
       return st_link_nir(ctx, prog);
    }
+#endif
 
    for (unsigned i = 0; i < MESA_SHADER_STAGES; i++) {
       if (prog->_LinkedShaders[i] == NULL)
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
index 8eb0dda9fae..2c8acb33176 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
@@ -4243,7 +4243,7 @@ glsl_to_tgsi_visitor::canonicalize_gather_offset(st_src_reg offset)
 
    return offset;
 }
- 
+
 bool
 glsl_to_tgsi_visitor::handle_bound_deref(ir_dereference *ir)
 {
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi_array_merge.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi_array_merge.cpp
index e54bb7b9f4d..5db79283a18 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi_array_merge.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi_array_merge.cpp
@@ -126,11 +126,13 @@
 
 #include "program/prog_instruction.h"
 #include "util/u_math.h"
-#include <ostream>
 #include <cassert>
 #include <algorithm>
 
+#ifndef NDEBUG
+#include <ostream>
 #include <iostream>
+#endif
 
 #include "st_glsl_to_tgsi_array_merge.h"
 
@@ -302,6 +304,7 @@ void array_live_range::set_target(array_live_range  *target)
    target_array = target;
 }
 
+#ifndef NDEBUG
 void array_live_range::print(std::ostream& os) const
 {
    os << "[id:" << id
@@ -312,6 +315,7 @@ void array_live_range::print(std::ostream& os) const
       << ", nc:" << (int)used_component_count
       << "]";
 }
+#endif
 
 bool array_live_range::time_doesnt_overlap(const array_live_range& other) const
 {
@@ -388,6 +392,7 @@ uint16_t array_remapping::map_swizzles(uint16_t old_swizzle) const
    return out_swizzle;
 }
 
+#ifndef NDEBUG
 void array_remapping::print(std::ostream& os) const
 {
    if (is_valid()) {
@@ -399,6 +404,7 @@ void array_remapping::print(std::ostream& os) const
       os << "[unused]";
    }
 }
+#endif
 
 /* Required by the unit tests */
 bool operator == (const array_remapping& lhs, const array_remapping& rhs)
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi_private.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi_private.cpp
index f259442cc37..5b235fe3129 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi_private.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi_private.cpp
@@ -28,6 +28,10 @@
 #include "mesa/program/prog_instruction.h"
 #include "mesa/program/prog_print.h"
 
+#ifndef NDEBUG
+#include <ostream>
+#endif
+
 static int swizzle_for_type(const glsl_type *type, int component = 0)
 {
    unsigned num_elements = 4;
@@ -223,6 +227,7 @@ bool operator == (const st_src_reg& lhs, const st_src_reg& rhs)
 
 static const char swz_txt[] = "xyzw";
 
+#ifndef NDEBUG
 std::ostream& operator << (std::ostream& os, const st_src_reg& reg)
 {
    if (reg.negate)
@@ -258,6 +263,7 @@ std::ostream& operator << (std::ostream& os, const st_src_reg& reg)
       os << "|";
    return os;
 }
+#endif
 
 st_dst_reg::st_dst_reg(st_src_reg reg)
 {
@@ -363,6 +369,7 @@ bool operator == (const st_dst_reg& lhs, const st_dst_reg& rhs)
    return result;
 }
 
+#ifndef NDEBUG
 std::ostream& operator << (std::ostream& os, const st_dst_reg& reg)
 {
    os << _mesa_register_file_name(reg.file);
@@ -421,3 +428,4 @@ void glsl_to_tgsi_instruction::print(std::ostream& os) const
       }
    }
 }
+#endif
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi_private.h b/src/mesa/state_tracker/st_glsl_to_tgsi_private.h
index 0b24e2ea774..2abab643f94 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi_private.h
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi_private.h
@@ -31,7 +31,7 @@
 #include "compiler/glsl_types.h"
 #include "compiler/glsl/ir.h"
 #include "tgsi/tgsi_info.h"
-#include <ostream>
+#include <iosfwd>
 
 int swizzle_for_size(int size);
 
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index cc1572bcc31..b96e7931d3b 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -994,8 +994,10 @@ st_api_create_context(struct st_api *stapi, struct st_manager *smapi,
    st->iface.teximage = st_context_teximage;
    st->iface.copy = st_context_copy;
    st->iface.share = st_context_share;
+#ifndef __SWITCH__
    st->iface.start_thread = st_start_thread;
    st->iface.thread_finish = st_thread_finish;
+#endif
    st->iface.st_context_private = (void *) smapi;
    st->iface.cso_context = st->cso_context;
    st->iface.pipe = st->pipe;
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index ee5ee2df598..3ebb149b6aa 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -293,6 +293,7 @@ void *
 st_pbo_create_vs(struct st_context *st)
 {
    struct pipe_screen *pscreen = st->pipe->screen;
+#ifndef __SWITCH__
    bool use_nir = PIPE_SHADER_IR_NIR ==
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
                                 PIPE_SHADER_CAP_PREFERRED_IR);
@@ -306,6 +307,7 @@ st_pbo_create_vs(struct st_context *st)
                                             st->pbo.layers ? 2 : 1,
                                             inputs, outputs, NULL, (1 << 1));
    }
+#endif
 
    struct ureg_program *ureg;
    struct ureg_src in_pos;
@@ -726,6 +728,7 @@ create_fs(struct st_context *st, bool download,
           enum pipe_texture_target target,
           enum st_pbo_conversion conversion)
 {
+#ifndef __SWITCH__
    struct pipe_screen *pscreen = st->pipe->screen;
    bool use_nir = PIPE_SHADER_IR_NIR ==
       pscreen->get_shader_param(pscreen, PIPE_SHADER_VERTEX,
@@ -733,6 +736,7 @@ create_fs(struct st_context *st, bool download,
 
    if (use_nir)
       return create_fs_nir(st, download, target, conversion);
+#endif
 
    return create_fs_tgsi(st, download, target, conversion);
 }
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index cb9fcfdbdd6..47b746bfd6a 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -225,8 +225,10 @@ delete_variant(struct st_context *st, struct st_variant *v, GLenum target)
    if (v->driver_shader) {
       if (target == GL_VERTEX_PROGRAM_ARB &&
           ((struct st_common_variant*)v)->key.is_draw_shader) {
+#ifndef __SWITCH__
          /* Draw shader. */
          draw_delete_vertex_shader(st->draw, v->driver_shader);
+#endif
       } else if (st->has_shareable_shaders || v->st == st) {
          /* The shader's context matches the calling context, or we
           * don't care.
@@ -351,6 +353,8 @@ st_release_program(struct st_context *st, struct st_program **p)
    st_reference_prog(st, p, NULL);
 }
 
+#ifndef __SWITCH__
+
 void
 st_finalize_nir_before_variants(struct nir_shader *nir)
 {
@@ -402,6 +406,8 @@ st_translate_prog_to_nir(struct st_context *st, struct gl_program *prog,
    return nir;
 }
 
+#endif
+
 void
 st_prepare_vertex_program(struct st_program *stp)
 {
@@ -509,6 +515,7 @@ st_translate_vertex_program(struct st_context *st,
       if (stp->Base.Parameters->NumParameters)
          stp->affected_states |= ST_NEW_VS_CONSTANTS;
 
+#ifndef __SWITCH__
       /* Translate to NIR if preferred. */
       if (st->pipe->screen->get_shader_param(st->pipe->screen,
                                              PIPE_SHADER_VERTEX,
@@ -550,6 +557,7 @@ st_translate_vertex_program(struct st_context *st,
             return true;
          }
       }
+#endif
    }
 
    st_prepare_vertex_program(stp);
@@ -645,6 +653,8 @@ st_translate_vertex_program(struct st_context *st,
    return stp->state.tokens != NULL;
 }
 
+#ifndef __SWITCH__
+
 static struct nir_shader *
 get_nir_shader(struct st_context *st, struct st_program *stp)
 {
@@ -668,6 +678,8 @@ get_nir_shader(struct st_context *st, struct st_program *stp)
    return nir_deserialize(NULL, options, &blob_reader);
 }
 
+#endif
+
 static const gl_state_index16 depth_range_state[STATE_LENGTH] =
    { STATE_DEPTH_RANGE };
 
@@ -689,6 +701,7 @@ st_create_vp_variant(struct st_context *st,
 
    state.stream_output = stvp->state.stream_output;
 
+#ifndef __SWITCH__
    if (stvp->state.type == PIPE_SHADER_IR_NIR &&
        (!key->is_draw_shader || draw_has_llvm())) {
       bool finalize = false;
@@ -756,6 +769,7 @@ st_create_vp_variant(struct st_context *st,
 
       return vpv;
    }
+#endif
 
    state.type = PIPE_SHADER_IR_TGSI;
    state.tokens = tgsi_dup_tokens(stvp->state.tokens);
@@ -792,9 +806,11 @@ st_create_vp_variant(struct st_context *st,
    if (ST_DEBUG & DEBUG_PRINT_IR)
       tgsi_dump(state.tokens, 0);
 
+#ifndef __SWITCH__
    if (key->is_draw_shader)
       vpv->base.driver_shader = draw_create_vertex_shader(st->draw, &state);
    else
+#endif
       vpv->base.driver_shader = pipe->create_vs_state(pipe, &state);
 
    if (state.tokens) {
@@ -881,6 +897,7 @@ st_translate_fragment_program(struct st_context *st,
                                      ST_NEW_FS_SAMPLERS;
       }
 
+#ifndef __SWITCH__
       /* Translate to NIR. */
       if (!stfp->ati_fs &&
           st->pipe->screen->get_shader_param(st->pipe->screen,
@@ -899,6 +916,7 @@ st_translate_fragment_program(struct st_context *st,
          stfp->Base.nir = nir;
          return true;
       }
+#endif
    }
 
    ubyte outputMapping[2 * FRAG_RESULT_MAX];
@@ -1248,6 +1266,7 @@ st_create_fp_variant(struct st_context *st,
    if (!variant)
       return NULL;
 
+#ifndef __SWITCH__
    if (stfp->state.type == PIPE_SHADER_IR_NIR) {
       bool finalize = false;
 
@@ -1384,6 +1403,7 @@ st_create_fp_variant(struct st_context *st,
 
       return variant;
    }
+#endif
 
    state.tokens = stfp->state.tokens;
 
@@ -1780,6 +1800,7 @@ st_get_common_variant(struct st_context *st,
       v = (struct st_variant*)CALLOC_STRUCT(st_common_variant);
       if (v) {
 	 if (prog->state.type == PIPE_SHADER_IR_NIR) {
+#ifndef __SWITCH__
             bool finalize = false;
 
 	    state.type = PIPE_SHADER_IR_NIR;
@@ -1799,6 +1820,7 @@ st_get_common_variant(struct st_context *st,
 
             if (ST_DEBUG & DEBUG_PRINT_IR)
                nir_print_shader(state.ir.nir, stderr);
+#endif
          } else {
             if (key->lower_depth_clamp) {
                struct gl_program_parameter_list *params = prog->Base.Parameters;
@@ -1838,9 +1860,11 @@ st_get_common_variant(struct st_context *st,
             cs.ir_type = state.type;
             cs.req_local_mem = prog->Base.info.cs.shared_size;
 
+#ifndef __SWITCH__
             if (state.type == PIPE_SHADER_IR_NIR)
                cs.prog = state.ir.nir;
             else
+#endif
                cs.prog = state.tokens;
 
             v->driver_shader = pipe->create_compute_state(pipe, &cs);
@@ -2021,6 +2045,8 @@ st_precompile_shader_variant(struct st_context *st,
    }
 }
 
+#ifndef __SWITCH__
+
 void
 st_serialize_nir(struct st_program *stp)
 {
@@ -2035,6 +2061,8 @@ st_serialize_nir(struct st_program *stp)
    }
 }
 
+#endif
+
 void
 st_finalize_program(struct st_context *st, struct gl_program *prog)
 {
@@ -2045,6 +2073,7 @@ st_finalize_program(struct st_context *st, struct gl_program *prog)
          st->dirty |= ((struct st_program *)prog)->affected_states;
    }
 
+#ifndef __SWITCH__
    if (prog->nir) {
       nir_sweep(prog->nir);
 
@@ -2054,6 +2083,7 @@ st_finalize_program(struct st_context *st, struct gl_program *prog)
        */
       st_serialize_nir(st_program(prog));
    }
+#endif
 
    /* Create Gallium shaders now instead of on demand. */
    if (ST_DEBUG & DEBUG_PRECOMPILE ||
diff --git a/src/mesa/state_tracker/st_shader_cache.c b/src/mesa/state_tracker/st_shader_cache.c
index 000d1c2688b..3382b6539ab 100644
--- a/src/mesa/state_tracker/st_shader_cache.c
+++ b/src/mesa/state_tracker/st_shader_cache.c
@@ -72,6 +72,8 @@ write_tgsi_to_cache(struct blob *blob, const struct tgsi_token *tokens,
    copy_blob_to_driver_cache_blob(blob, prog);
 }
 
+#ifndef __SWITCH__
+
 static void
 write_nir_to_cache(struct blob *blob, struct gl_program *prog)
 {
@@ -85,6 +87,8 @@ write_nir_to_cache(struct blob *blob, struct gl_program *prog)
    copy_blob_to_driver_cache_blob(blob, prog);
 }
 
+#endif
+
 static void
 st_serialise_ir_program(struct gl_context *ctx, struct gl_program *prog,
                         bool nir)
@@ -113,9 +117,11 @@ st_serialise_ir_program(struct gl_context *ctx, struct gl_program *prog,
        prog->info.stage == MESA_SHADER_GEOMETRY)
       write_stream_out_to_cache(&blob, &stp->state);
 
+#ifndef __SWITCH__
    if (nir)
       write_nir_to_cache(&blob, prog);
    else
+#endif
       write_tgsi_to_cache(&blob, stp->state.tokens, prog);
 
    blob_finish(&blob);
@@ -207,6 +213,7 @@ st_deserialise_ir_program(struct gl_context *ctx,
       read_stream_out_from_cache(&blob_reader, &stp->state);
 
    if (nir) {
+#ifndef __SWITCH__
       assert(prog->nir == NULL);
       assert(stp->serialized_nir == NULL);
 
@@ -215,6 +222,7 @@ st_deserialise_ir_program(struct gl_context *ctx,
       stp->serialized_nir = malloc(stp->serialized_nir_size);
       blob_copy_bytes(&blob_reader, stp->serialized_nir, stp->serialized_nir_size);
       stp->shader_program = shProg;
+#endif
    } else {
       read_tgsi_from_cache(&blob_reader, &stp->state.tokens);
    }
@@ -292,6 +300,8 @@ st_deserialise_tgsi_program(struct gl_context *ctx,
    st_deserialise_ir_program(ctx, shProg, prog, false);
 }
 
+#ifndef __SWITCH__
+
 void
 st_serialise_nir_program(struct gl_context *ctx, struct gl_program *prog)
 {
@@ -313,3 +323,5 @@ st_deserialise_nir_program(struct gl_context *ctx,
 {
    st_deserialise_ir_program(ctx, shProg, prog, true);
 }
+
+#endif
diff --git a/src/meson.build b/src/meson.build
index bdc6a54cc3f..88b607c8a77 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -23,6 +23,7 @@ inc_mapi = include_directories('mapi')
 inc_src = include_directories('.')
 inc_gallium = include_directories('gallium/include')
 inc_gallium_aux = include_directories('gallium/auxiliary')
+inc_gallium_winsys = include_directories('gallium/winsys')
 inc_amd_common = include_directories('amd/common')
 inc_amd_common_llvm = include_directories('amd/llvm')
 
@@ -99,9 +100,6 @@ if with_gbm
 else
   inc_gbm = []
 endif
-if with_egl
-  subdir('egl')
-endif
 if with_gallium
   subdir('gallium')
   # This has to be here since it requires libgallium, and subdir cannot
@@ -110,6 +108,9 @@ if with_gallium
     subdir('mesa/state_tracker/tests')
   endif
 endif
+if with_egl
+  subdir('egl')
+endif
 
 # This must be after at least mesa, glx, and gallium, since libgl will be
 # defined in one of those subdirs depending on the glx provider.
diff --git a/src/util/detect_os.h b/src/util/detect_os.h
index 6506948e035..5f81ec6e72e 100644
--- a/src/util/detect_os.h
+++ b/src/util/detect_os.h
@@ -28,6 +28,10 @@
 #define DETECT_OS_ANDROID 1
 #endif
 
+#if defined(__SWITCH__)
+#define DETECT_OS_SWITCH 1
+#endif
+
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #define DETECT_OS_FREEBSD 1
 #define DETECT_OS_BSD 1
diff --git a/src/util/disk_cache.h b/src/util/disk_cache.h
index 09b316e6e8d..e5dca8e7137 100644
--- a/src/util/disk_cache.h
+++ b/src/util/disk_cache.h
@@ -91,10 +91,10 @@ disk_cache_format_hex_id(char *buf, const uint8_t *hex_id, unsigned size)
    return buf;
 }
 
-#ifdef HAVE_DLADDR
 static inline bool
 disk_cache_get_function_timestamp(void *ptr, uint32_t* timestamp)
 {
+#ifdef HAVE_DLADDR
    Dl_info info;
    struct stat st;
    if (!dladdr(ptr, &info) || !info.dli_fname) {
@@ -131,8 +131,16 @@ disk_cache_get_function_identifier(void *ptr, struct mesa_sha1 *ctx)
    } else
       return false;
    return true;
+#else
+   return false;
 }
+
+static inline bool
+disk_cache_get_function_identifier(void *ptr, struct mesa_sha1 *ctx)
+{
+   return false;
 #endif
+}
 
 /* Provide inlined stub functions if the shader cache is disabled. */
 
diff --git a/src/util/macros.h b/src/util/macros.h
index fcace4e351d..079e78cb1a4 100644
--- a/src/util/macros.h
+++ b/src/util/macros.h
@@ -152,11 +152,13 @@ do {                       \
 /* Used to optionally mark structures with misaligned elements or size as
  * packed, to trade off performance for space.
  */
+#ifndef PACKED
 #ifdef HAVE_FUNC_ATTRIBUTE_PACKED
 #define PACKED __attribute__((__packed__))
 #else
 #define PACKED
 #endif
+#endif
 
 /* Attribute pure is used for functions that have no effects other than their
  * return value.  As a result, calls to it can be dead code eliminated.
diff --git a/src/util/os_memory_aligned.h b/src/util/os_memory_aligned.h
index 08f12062a7f..48b21e50925 100644
--- a/src/util/os_memory_aligned.h
+++ b/src/util/os_memory_aligned.h
@@ -1,8 +1,8 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2008-2010 VMware, Inc.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,7 +22,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 
 
@@ -48,7 +48,17 @@ add_overflow_size_t(size_t a, size_t b, size_t *res)
 }
 
 
-#if defined(HAVE_POSIX_MEMALIGN)
+#if defined(_ISOC11_SOURCE)
+
+static inline void *
+os_malloc_aligned(size_t size, size_t alignment)
+{
+   return aligned_alloc(alignment, (size + alignment - 1) &~ (alignment - 1));
+}
+
+#define os_free_aligned(_ptr) free(_ptr)
+
+#elif defined(HAVE_POSIX_MEMALIGN)
 
 static inline void *
 os_malloc_aligned(size_t size, size_t alignment)
diff --git a/src/util/os_memory_stdc.h b/src/util/os_memory_stdc.h
index bda5715998f..b9b7fa91e5a 100644
--- a/src/util/os_memory_stdc.h
+++ b/src/util/os_memory_stdc.h
@@ -1,8 +1,8 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2008-2010 VMware, Inc.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,7 +22,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 
 
diff --git a/src/util/os_misc.c b/src/util/os_misc.c
index e6894731b63..c4df72a657e 100644
--- a/src/util/os_misc.c
+++ b/src/util/os_misc.c
@@ -60,6 +60,8 @@
 #  include <kernel/OS.h>
 #elif DETECT_OS_WINDOWS
 #  include <windows.h>
+#elif DETECT_OS_SWITCH
+#  include <switch.h>
 #else
 #error unexpected platform in os_sysinfo.c
 #endif
@@ -104,6 +106,8 @@ os_log_message(const char *message)
       fputs(message, fout);
       fflush(fout);
    }
+#elif DETECT_OS_SWITCH
+   svcOutputDebugString(message, __builtin_strlen(message) + 1);
 #else /* !DETECT_OS_WINDOWS */
    fflush(stdout);
    fputs(message, fout);
@@ -177,6 +181,8 @@ os_get_total_physical_memory(uint64_t *size)
    ret = GlobalMemoryStatusEx(&status);
    *size = status.ullTotalPhys;
    return (ret == TRUE);
+#elif DETECT_OS_SWITCH
+   return R_SUCCEEDED(svcGetInfo(size, InfoType_TotalMemorySize, CUR_PROCESS_HANDLE, 0));
 #else
 #error unexpected platform in os_sysinfo.c
    return false;
diff --git a/src/util/os_time.c b/src/util/os_time.c
index 92fc3638ddb..2896b200d58 100644
--- a/src/util/os_time.c
+++ b/src/util/os_time.c
@@ -28,7 +28,7 @@
 /**
  * @file
  * OS independent time-manipulation functions.
- * 
+ *
  * @author Jose Fonseca <jfonseca@vmware.com>
  */
 
@@ -36,8 +36,9 @@
 #include "detect_os.h"
 
 #include "util/u_atomic.h"
+#include "c11/threads.h"
 
-#if DETECT_OS_UNIX
+#if DETECT_OS_UNIX || DETECT_OS_SWITCH
 #  include <unistd.h> /* usleep */
 #  include <time.h> /* timeval */
 #  include <sys/time.h> /* timeval */
@@ -49,6 +50,10 @@
 #  error Unsupported OS
 #endif
 
+#if defined(DETECT_OS_SWITCH)
+#  include <switch/kernel/svc.h>
+#endif
+
 
 int64_t
 os_time_get_nano(void)
@@ -59,7 +64,7 @@ os_time_get_nano(void)
    clock_gettime(CLOCK_MONOTONIC, &tv);
    return tv.tv_nsec + tv.tv_sec*INT64_C(1000000000);
 
-#elif DETECT_OS_UNIX
+#elif DETECT_OS_UNIX || DETECT_OS_SWITCH
 
    struct timeval tv;
    gettimeofday(&tv, NULL);
@@ -108,6 +113,8 @@ os_time_sleep(int64_t usecs)
    if (dwMilliseconds) {
       Sleep(dwMilliseconds);
    }
+#elif DETECT_OS_SWITCH
+   svcSleepThread((u64)usecs * 1000);
 #else
 #  error Unsupported OS
 #endif
@@ -146,9 +153,7 @@ os_wait_until_zero(volatile int *var, uint64_t timeout)
 
    if (timeout == OS_TIMEOUT_INFINITE) {
       while (p_atomic_read(var)) {
-#if DETECT_OS_UNIX
-         sched_yield();
-#endif
+         thrd_yield();
       }
       return true;
    }
@@ -160,9 +165,7 @@ os_wait_until_zero(volatile int *var, uint64_t timeout)
          if (os_time_timeout(start_time, end_time, os_time_get_nano()))
             return false;
 
-#if DETECT_OS_UNIX
-         sched_yield();
-#endif
+         thrd_yield();
       }
       return true;
    }
@@ -182,9 +185,7 @@ os_wait_until_zero_abs_timeout(volatile int *var, int64_t timeout)
       if (os_time_get_nano() >= timeout)
          return false;
 
-#if DETECT_OS_UNIX
-      sched_yield();
-#endif
+      thrd_yield();
    }
    return true;
 }
diff --git a/src/util/slab.c b/src/util/slab.c
index 62634034fdc..cfe0ddcf0d0 100644
--- a/src/util/slab.c
+++ b/src/util/slab.c
@@ -27,6 +27,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <string.h>
+#include <stdlib.h>
 
 #define SLAB_MAGIC_ALLOCATED 0xcafe4321
 #define SLAB_MAGIC_FREE 0x7ee01234
diff --git a/src/util/u_endian.h b/src/util/u_endian.h
index 6bbae3c444c..fd9e02f1daa 100644
--- a/src/util/u_endian.h
+++ b/src/util/u_endian.h
@@ -1,8 +1,8 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2007-2008 VMware, Inc.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,7 +22,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 #ifndef U_ENDIAN_H
 #define U_ENDIAN_H
@@ -73,7 +73,7 @@
 # define UTIL_ARCH_BIG_ENDIAN 1
 #endif
 
-#elif defined(_WIN32) || defined(ANDROID)
+#elif defined(_WIN32) || defined(ANDROID) || defined(__SWITCH__)
 
 #define UTIL_ARCH_LITTLE_ENDIAN 1
 #define UTIL_ARCH_BIG_ENDIAN 0
